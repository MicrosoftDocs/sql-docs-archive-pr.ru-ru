---
title: Создание синхронного преобразования с помощью компонента скрипта | Документы Майкрософт
ms.custom: ''
ms.date: 04/27/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: integration-services
ms.topic: reference
dev_langs:
- VB
helpviewer_keywords:
- synchronous outputs [Integration Services]
- transformation components [Integration Services]
- Script component [Integration Services], transformation components
ms.assetid: aa1bee1a-ab06-44d8-9944-4bff03d73016
author: chugugrace
ms.author: chugu
ms.openlocfilehash: 34252f1caba4e2c1b3b99788d32527a33793b6ab
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87664993"
---
# <a name="creating-a-synchronous-transformation-with-the-script-component"></a>Создание синхронного преобразования с помощью компонента скрипта
  Компонент преобразования используется в потоке данных пакета служб [!INCLUDE[ssISnoversion](../../includes/ssisnoversion-md.md)] для изменения и анализа данных, передаваемых из источника в назначение. Преобразование с синхронными выходами обрабатывает каждую входную строку, проходящую через компонент. Преобразование с асинхронными выходами ожидает, пока не получит все входные строки, чтобы завершить обработку. В этом разделе рассматривается синхронное преобразование. Сведения об асинхронных преобразованиях см. в разделе [Создание асинхронного преобразования с помощью компонента скрипта](../extending-packages-scripting-data-flow-script-component-types/creating-an-asynchronous-transformation-with-the-script-component.md). Дополнительные сведения о различиях между синхронными и асинхронными компонентами см. в разделе [Основные сведения о синхронных и асинхронных преобразованиях](../understanding-synchronous-and-asynchronous-transformations.md).

 Общие сведения о компоненте скрипта см. в разделе [Расширение потока данных с помощью компонента скрипта](../extending-packages-scripting/data-flow-script-component/extending-the-data-flow-with-the-script-component.md).

 Компонент скрипта и формируемый им код инфраструктуры значительно упрощают процесс создания пользовательских компонентов потока данных. Однако, чтобы понять, как работает компонент скрипта, может быть полезно ознакомиться с шагами по разработке пользовательских компонентов потока данных, описанными в разделе [Разработка пользовательского компонента потока данных](../extending-packages-custom-objects/data-flow/developing-a-custom-data-flow-component.md) и в особенности в разделе [Разработка пользовательского компонента преобразования с синхронными выходами](../extending-packages-custom-objects-data-flow-types/developing-a-custom-transformation-component-with-synchronous-outputs.md).

## <a name="getting-started-with-a-synchronous-transformation-component"></a>Приступая к работе над компонентом синхронного преобразования
 При добавлении компонента скриптов на панель "Поток данных" конструктора служб [!INCLUDE[ssIS](../../includes/ssis-md.md)] открывается диалоговое окно **Выбор типа компонента скрипта**, где нужно выбрать тип компонента — источник, назначение или преобразование. В этом диалоговом окне выберите пункт **Преобразование**.

## <a name="configuring-a-synchronous-transformation-component-in-metadata-design-mode"></a>Настройка компонента синхронного преобразования в режиме конструктора метаданных
 После выбора варианта для создания компонента преобразования выполняется настройка компонента с помощью **редактора преобразования "Скрипт"** . Дополнительные сведения см. в разделе [Настройка компонента скрипта в редакторе компонента скрипта](../extending-packages-scripting/data-flow-script-component/configuring-the-script-component-in-the-script-component-editor.md).

 Чтобы определить язык скрипта для компонента скрипта, необходимо задать свойство **ScriptLanguage** на странице **Скрипт** в **редакторе преобразования "Скрипт"** .

> [!NOTE]
>  Чтобы установить язык скрипта по умолчанию для компонента скрипта, воспользуйтесь параметром **Язык сценариев** на странице **Общие** диалогового окна **Параметры**. Дополнительные сведения см. в разделе [General Page](../general-page-of-integration-services-designers-options.md).

 Компонент преобразования потока данных имеет один вход и поддерживает один или несколько выходов. Настройка входа и выходов компонента является одним из шагов, которые необходимо выполнить в режиме конструктора метаданных с использованием **редактора преобразования "Скрипт"** , прежде чем приступать к написанию пользовательского скрипта.

### <a name="configuring-input-columns"></a>Настройка входных столбцов
 Компонент преобразования имеет один вход.

 На странице **Входные столбцы** в **редакторе преобразования "Скрипт"** список столбцов содержит доступные столбцы на выходе вышестоящего компонента в потоке данных. Выделите столбцы, которые хотите преобразовать или передать. Пометьте все столбцы, участвующие в преобразовании, как доступные для чтения и записи.

 Дополнительные сведения о странице **Входные столбцы** **редактора преобразования "Скрипт"** см. в разделе [Редактор преобразования "Скрипт" (страница "Входные столбцы")](../script-transformation-editor-input-columns-page.md).

### <a name="configuring-inputs-outputs-and-output-columns"></a>Настройка входов, выходов и выходных столбцов
 Компонент преобразования поддерживает один или несколько выходов.

 На странице **Входы и выходы** в **редакторе преобразования "Скрипт"** можно убедиться в том, что создан один выход, который не имеет столбцов. На этой странице редактора может понадобиться настроить следующие элементы.

-   Создайте один или несколько дополнительных выходов, например, имитацию вывода ошибок для строк, содержащих непредвиденные значения. Используйте кнопки **Добавить выход** и **Удалить выход** для управления выходами компонента синхронного преобразования. Все входные строки направляются во все доступные выходы, если не указано, что необходимо перенаправлять каждую строку в тот или иной определенный выход. Чтобы указать на необходимость перенаправления строк, следует присвоить свойству `ExclusionGroup` для выходов ненулевое целочисленное значение. Конкретное целочисленное значение, заданное для свойства `ExclusionGroup`, не имеет принципиальной важности, однако необходимо использовать одно и то же число последовательно в указанной группе выходов.

    > [!NOTE]
    >  Также можно использовать ненулевое значение для свойства `ExclusionGroup` с единственным выходом, если не нужно выводить все строки. Однако в этом случае необходимо явно вызывать метод **DirectRowTo\<outputbuffer>** для каждой строки, которую следует отправить на выход.

-   Присвойте как можно более описательные имена входу и выходам. Компонент скрипта использует эти имена для создания типизированных свойств метода доступа, с помощью которых в скрипте выполняется обращение к входам и выходам.

-   Для синхронных преобразований оставьте столбцы без изменения. Обычно синхронное преобразование не добавляет столбцы в поток данных. Данные изменяются на месте, прямо в буфере, который передается в следующий компонент потока данных. В подобной ситуации нет необходимости добавлять и настраивать выходные столбцы явным образом для выходов преобразования. Выходы отображаются в редакторе без явно определенных столбцов.

-   Добавьте новые столбцы для имитации вывода ошибок для ошибок на уровне строк. Обычно несколько выходов в одной и той же группе `ExclusionGroup` имеют один и тот же набор выходных столбцов. Однако при создании имитации вывода ошибок может оказаться целесообразным добавление нескольких столбцов, содержащих сведения об ошибках. Сведения об обработке ошибочных строк в подсистеме обработки потока данных см. в разделе [Использование выводов ошибок в компоненте потока данных](../extending-packages-custom-objects/data-flow/using-error-outputs-in-a-data-flow-component.md). Обратите внимание на то, что в компоненте скрипта необходимо написать собственный код для заполнения дополнительных столбцов соответствующими сведениями об ошибках. Дополнительные сведения см. в разделе [Имитация вывода ошибок для компонента скрипта](../extending-packages-scripting-data-flow-script-component-examples/simulating-an-error-output-for-the-script-component.md).

 Дополнительные сведения о странице **Входы и выходы** **редактора преобразования "Скрипт"** см. в разделе [Редактор преобразования "Скрипт" (страница "Входы и выходы")](../script-transformation-editor-inputs-and-outputs-page.md).

### <a name="adding-variables"></a>Добавление переменных
 Если вы хотите использовать в скрипте существующие переменные, их можно добавить в `ReadOnlyVariables` `ReadWriteVariables` поля свойств и на странице **Скрипт** в **редакторе преобразования "Скрипт**".

 Если в поле свойства добавляются несколько переменных, их имена нужно разделять запятыми. Можно также выбрать несколько переменных, нажав кнопку с многоточием (**...**) рядом с `ReadOnlyVariables` `ReadWriteVariables` полями свойств и, а затем выбрав переменные в диалоговом окне **Выбор переменных** .

 Общие сведения об использовании переменных в компоненте скрипта см. в разделе [Использование переменных в компоненте скрипта](../extending-packages-scripting/data-flow-script-component/using-variables-in-the-script-component.md).

 Дополнительные сведения о странице **Скрипт** в окне **Редактор преобразования "Скрипт"** см. в разделе [Редактор преобразования "Скрипт" (страница "Скрипт")](../script-transformation-editor-script-page.md).

## <a name="scripting-a-synchronous-transformation-component-in-code-design-mode"></a>Создание скрипта компонента синхронного преобразования в режиме конструктора кода
 После настройки метаданных для компонента можно написать пользовательский скрипт. В **редакторе преобразования "Скрипт"** на странице **Скрипт** нажмите кнопку **Изменить скрипт**, чтобы открыть интегрированную среду разработки средств [!INCLUDE[msCoName](../../includes/msconame-md.md)] [!INCLUDE[vsprvs](../../includes/vsprvs-md.md)] для приложений (VSTA), где можно добавить пользовательский скрипт. Используемый язык скриптов зависит от значения свойства **ScriptLanguage**, указанного на странице **Скрипт**. В качестве значения можно выбрать язык [!INCLUDE[msCoName](../../includes/msconame-md.md)] Visual Basic или [!INCLUDE[msCoName](../../includes/msconame-md.md)] Visual C#.

 Важные сведения, относящиеся ко всем типам компонентов, создаваемым с помощью компонента скрипта, см. в разделе [Кодирование и отладка компонента скрипта](../extending-packages-scripting/data-flow-script-component/using-variables-in-the-script-component.md).

### <a name="understanding-the-auto-generated-code"></a>Основные сведения об автоматически создаваемом коде
 При открытии интегрированной среды разработки VSTA после создания и настройки компонента преобразования, изменяемый класс `ScriptMain` отображается в редакторе кода с заглушкой для метода `ProcessInputRow`. Пользовательский код создается в классе `ScriptMain`, а самым важным методом в компоненте преобразования является `ProcessInputRow`.

 Если открыть окно **обозревателя проектов** в VSTA, то можно увидеть, что компонент скрипта также создал элементы проекта только для чтения `BufferWrapper` и `ComponentWrapper` . Класс `ScriptMain` наследует класс `UserComponent` в элементе проекта `ComponentWrapper`.

 Во время выполнения подсистема обработки потока данных вызывает метод `ProcessInput` в классе `UserComponent`, который переопределяет метод <xref:Microsoft.SqlServer.Dts.Pipeline.ScriptComponent.ProcessInput%2A> родительского класса <xref:Microsoft.SqlServer.Dts.Pipeline.ScriptComponent>. В свою очередь, метод `ProcessInput` проходит по строкам во входном буфере и вызывает для каждой строки метод `ProcessInputRow`.

### <a name="writing-your-custom-code"></a>Написание пользовательского кода
 Компонент преобразования с синхронными выходами является наиболее простым для написания компонентом потока данных. Например, в образце с единственным выходом, который приведен далее в этом разделе, содержится следующий пользовательский код:

```vb
Row.City = UCase(Row.City)
```

```csharp
Row.City = (Row.City).ToUpper();

```

 Чтобы завершить создание пользовательского компонента синхронного преобразования, необходимо переопределить метод `ProcessInputRow` для преобразования данных в каждой строке входного буфера. Когда этот буфер оказывается заполненным, подсистема обработки потока данных передает его следующему компоненту в потоке данных.

 В зависимости от потребностей, возможно, понадобится написать скрипт с методами `PreExecute` и `PostExecute`, доступными в классе `ScriptMain`, чтобы обеспечить предварительную или итоговую обработку.

### <a name="working-with-multiple-outputs"></a>Работа с несколькими выходами
 Направление входных строк в один из двух или более возможных выходов не требует большого объема дополнительного пользовательского кода по сравнению со скриптом с единственным выходом, который был рассмотрен выше. Например, в примере с двумя выходами, который приведен далее в этом разделе, содержится следующий пользовательский код:

```vb
Row.City = UCase(Row.City)
If Row.City = "REDMOND" Then
    Row.DirectRowToMyRedmondAddresses()
Else
    Row.DirectRowToMyOtherAddresses()
End If
```

```csharp
Row.City = (Row.City).ToUpper();

if (Row.City=="REDMOND")
{
    Row.DirectRowToMyRedmondAddresses();
}
else
{
    Row.DirectRowToMyOtherAddresses();
}
```

 В этом примере компонент скрипта формирует методы **DirectRowTo\<OutputBufferX>** на основе имен выходов, настроенных пользователем. Можно использовать аналогичный код для направления строк ошибок в имитированный вывод ошибок.

## <a name="examples"></a>Примеры
 В приведенных здесь примерах демонстрируется пользовательский код, который необходимо использовать в классе `ScriptMain` для создания компонента синхронного преобразования.

> [!NOTE]
>  В этих примерах используется таблица **Person. Address** в `AdventureWorks` образце базы данных и передайте ее первый и четвертый столбцы, столбцы **интаддрессид** и **nvarchar (30) City** через поток данных. Эти же данные используются в образцах источника, преобразования и назначения, приведенных в этом разделе. Для каждого примера приведены необходимые дополнительные условия и принимаемые предположения.

### <a name="single-output-synchronous-transformation-example"></a>Пример синхронного преобразования с единственным выходом
 В этом примере демонстрируется компонент синхронного преобразования с единственным выходом. Это преобразование передает столбец **AddressID** без обработки, а столбец **City** преобразует к верхнему регистру.

 Для запуска этого образца кода необходимо настроить пакет и компонент следующим образом.

1.  Добавьте новый компонент скрипта в область конструктора потока данных и настройте его в качестве преобразования.

2.  Соедините выход источника или другого преобразования с новым компонентом преобразования в конструкторе служб [!INCLUDE[ssIS](../../includes/ssis-md.md)]. Этот вывод должен предоставлять данные из таблицы **Person. Address** `AdventureWorks` образца базы данных, содержащей столбцы **AddressID** и **City** .

3.  Откройте **редактор преобразования "Скрипт"** . На странице **Входные столбцы** выберите столбцы **AddressID** и **City**. Пометьте столбец **City** как доступный для чтения и записи.

4.  На странице **Входы и выходы** переименуйте вход и выход, дав им более описательные имена, например **MyAddressInput** и **MyAddressOutput**. Обратите внимание, что идентификатор `SynchronousInputID` выхода соответствует идентификатору `ID` входа. Таким образом, нет необходимости добавлять и настраивать выходные столбцы.

5.  На странице **Скрипт** нажмите кнопку **Изменить скрипт** и введите следующий скрипт. Затем закройте среду разработки скриптов и **редактор преобразования "скрипт"** .

6.  Создайте и настройте компонент назначения, ожидающий столбцы **AddressID** и **City**, например назначение [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] или образец компонента назначения, показанный в разделе [Создание назначения с помощью компонента скрипта](../extending-packages-scripting-data-flow-script-component-types/creating-a-destination-with-the-script-component.md). Затем соедините выход преобразования с компонентом назначения. Можно создать целевую таблицу, выполнив следующую команду [!INCLUDE[tsql](../../includes/tsql-md.md)] в базе данных `AdventureWorks`:

    ```
    CREATE TABLE [Person].[Address2]([AddressID] [int] NOT NULL,
        [City] [nvarchar](30) NOT NULL)
    ```

7.  Запустите образец.

```vb
Public Class ScriptMain
    Inherits UserComponent

    Public Overrides Sub MyAddressInput_ProcessInputRow(ByVal Row As MyAddressInputBuffer)

        Row.City = UCase(Row.City)

    End Sub

End Class
```

```csharp
public class ScriptMain:
    UserComponent

{
    public override void MyAddressInput_ProcessInputRow(MyAddressInputBuffer Row)
    {

        Row.City = (Row.City).ToUpper();

    }

}
```

### <a name="two-output-synchronous-transformation-example"></a>Пример синхронного преобразования с двумя выходами
 В этом примере демонстрируется компонент синхронного преобразования с двумя выходами. Это преобразование передает столбец **AddressID** без обработки, а столбец **City** преобразует к верхнему регистру. Если названием города является «Redmond», строка направляется в один выход. Все остальные строки направляются в другой выход.

 Для запуска этого образца кода необходимо настроить пакет и компонент следующим образом.

1.  Добавьте новый компонент скрипта в область конструктора потока данных и настройте его в качестве преобразования.

2.  Соедините выход источника или другого преобразования с новым компонентом преобразования в конструкторе служб [!INCLUDE[ssIS](../../includes/ssis-md.md)]. Этот вывод должен предоставлять данные из таблицы **Person. Address** `AdventureWorks` образца базы данных, содержащей по крайней мере столбцы **AddressID** и **City** .

3.  Откройте **редактор преобразования "Скрипт"** . На странице **Входные столбцы** выберите столбцы **AddressID** и **City**. Пометьте столбец **City** как доступный для чтения и записи.

4.  На странице **Входы и выходы** создайте второй выход. После создания нового выхода убедитесь в том, что идентификатору `SynchronousInputID` присвоено значение, совпадающее с идентификатором `ID` входа. Это свойство уже задано для первого выхода, создаваемого по умолчанию. Для каждого выхода присвойте свойству `ExclusionGroup` одно и то же ненулевое значение, чтобы предписать распределение входных строк между двумя взаимоисключающими выходами. Нет необходимости добавлять какие-либо выходные столбцы в выходы.

5.  Переименуйте вход и выходы, дав им более описательные имена, например **MyAddressInput**, **MyRedmondAddresses** и **MyOtherAddresses**.

6.  На странице **Скрипт** нажмите кнопку **Изменить скрипт** и введите следующий скрипт. Затем закройте среду разработки скриптов и **редактор преобразования "скрипт"** .

7.  Создайте и настройте два компонента назначения, ожидающие столбцы **AddressID** и **City**, например назначение [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], назначение "Неструктурированный файл" или образец компонента назначения, показанный в разделе [Создание назначения с помощью компонента скрипта](../extending-packages-scripting-data-flow-script-component-types/creating-a-destination-with-the-script-component.md). Затем соедините каждый из выходов преобразования с одним из компонентов назначения. Можно создать целевые таблицы, выполнив команду [!INCLUDE[tsql](../../includes/tsql-md.md)], аналогичную следующей (с соответствующими уникальными именами таблиц) в базе данных `AdventureWorks`:

    ```
    CREATE TABLE [Person].[Address2](
        [AddressID] [int] NOT NULL,
        [City] [nvarchar](30) NOT NULL
    ```

8.  Запустите образец.

```vb
Public Class ScriptMain
    Inherits UserComponent

    Public Overrides Sub MyAddressInput_ProcessInputRow(ByVal Row As MyAddressInputBuffer)

        Row.City = UCase(Row.City)

        If Row.City = "REDMOND" Then
            Row.DirectRowToMyRedmondAddresses()
        Else
            Row.DirectRowToMyOtherAddresses()
        End If

    End Sub

End Class
```

```csharp
public class ScriptMain:
    UserComponent

public override void MyAddressInput_ProcessInputRow(MyAddressInputBuffer Row)
    {

        Row.City = (Row.City).ToUpper();

        if (Row.City == "REDMOND")
        {
            Row.DirectRowToMyRedmondAddresses();
        }
        else
        {
            Row.DirectRowToMyOtherAddresses();
        }

    }
}
```

|![](./media/creating-a-synchronous-transformation-with-the-script-component/dts-16.gif)  **Следите за обновлениями Integration Services**<br /> Чтобы загрузить новейшую документацию, статьи, образцы и видеоматериалы корпорации Майкрософт, а также лучшие решения участников сообщества, посетите страницу служб [!INCLUDE[ssISnoversion](../../includes/msconame-md.md)] на сайте MSDN:<br /><br /> [Посетить страницу «Службы Integration Services» на сайте MSDN](https://go.microsoft.com/fwlink/?LinkId=136655)<br /><br /> Чтобы получать автоматические уведомления об этих обновлениях, подпишитесь на RSS-каналы, предлагаемые на этой странице.

## <a name="see-also"></a>См. также:
 [Основные сведения о синхронных и асинхронных преобразованиях](../understanding-synchronous-and-asynchronous-transformations.md) [Создание асинхронного преобразования с помощью компонента скрипта](../extending-packages-scripting-data-flow-script-component-types/creating-an-asynchronous-transformation-with-the-script-component.md) [Разработка пользовательского компонента преобразования с синхронными выходами](../extending-packages-custom-objects-data-flow-types/developing-a-custom-transformation-component-with-synchronous-outputs.md)



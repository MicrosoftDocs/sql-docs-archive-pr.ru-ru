---
title: Определение готовности информации об изменениях данных | Документы Майкрософт
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: integration-services
ms.topic: conceptual
helpviewer_keywords:
- incremental load [Integration Services],determining readiness
ms.assetid: 04935f35-96cc-4d70-a250-0fd326f8daff
author: chugugrace
ms.author: chugu
ms.openlocfilehash: 5e672440938e366e53ba150f65d7bcd6aed8a58c
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87740214"
---
# <a name="determine-whether-the-change-data-is-ready"></a>Определение готовности информации об  изменениях данных
  В потоке управления пакета служб [!INCLUDE[ssISnoversion](../../includes/ssisnoversion-md.md)] , который выполняет добавочную загрузку измененных данных, вторая задача состоит в том, чтобы убедиться, что изменения данных за выбранный интервал времени подготовлены. Этот шаг необходим потому, что процесс асинхронной записи, возможно, еще не дошел до выбранной конечной точки.  
  
> [!NOTE]  
>  Первая задача потока управления — вычислить конечные точки интервала изменений. Дополнительные сведения об этой задаче см. в разделе [Задание интервала для информации об изменениях данных](specify-an-interval-of-change-data.md) Описание общего процесса по проектированию потока управления см. в разделе [Система отслеживания измененных данных (SSIS)](change-data-capture-ssis.md).  
  
## <a name="understanding-the-components-of-the-solution"></a>Основные сведения о компонентах решения  
 В решении, которое описывается в настоящем разделе, используется 4 компонента служб [!INCLUDE[ssISnoversion](../../includes/ssisnoversion-md.md)] .  
  
-   Контейнер «цикл по элементам», который регулярно оценивает выходные данные задачи «Выполнение SQL».  
  
-   Задача «Выполнение SQL», которая опрашивает обслуживаемые системой отслеживания измененных данных специальные таблицы, а затем использует полученную информацию, чтобы определить, готовы ли данные.  
  
-   Компонент, обеспечивающий задержку в процессе обработки в случаях, когда данные еще не готовы. Это может быть либо задача «Скрипт», либо задача «Выполнение SQL».  
  
-   При необходимости используется компонент, извещающий об ошибке или о времени ожидания, если задача «Выполнение SQL» возвращает значение, указывающее на ошибку либо на время ожидания.  
  
 Эти компоненты задают или считывают значения нескольких переменных пакета, чтобы управлять потоком выполнения внутри цикла и позднее в пакете.  
  
#### <a name="to-set-up-package-variables"></a>Настройка переменных пакета  
  
1.  В окне [!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)]Переменные **среды** создайте следующие переменные.  
  
    1.  Создайте переменную с типом данных integer для хранения значения состояния, возвращаемого задачей «Выполнение SQL».  
  
         В этом примере используется переменная с именем DataReady с исходным значением 0.  
  
    2.  Создайте переменную для хранения периода времени задержки в случае, если данные не готовы. Если планируется реализовать задержку с помощью задачи «Скрипт», тип данных переменной должен быть integer. Если будет использоваться задача «Выполнение SQL» с инструкцией WAITFOR, переменная должна иметь строковый тип данных, чтобы переменная могла принимать значения типа «00:00:10».  
  
         В этом примере используется переменная с именем DelaySeconds с исходным значением 10.  
  
    3.  Создайте переменную с типом данных integer для хранения текущей итерации цикла.  
  
         В этом примере используется переменная с именем TimeoutCount с исходным значением 0.  
  
    4.  Создайте переменную типа данных integer, чтобы указать, сколько раз цикл должен проверить данные перед созданием отчета об истечении времени ожидания.  
  
         В этом примере используется переменная с именем TimeoutCeiling с исходным значением 20.  
  
    5.  Создайте переменную с типом данных integer, которую можно использовать для указания первой загрузки измененных данных (необязательно).  
  
         В этом примере используется переменная с именем IntervalID и проверяется только значение 0, указывающее на первоначальную загрузку.  
  
## <a name="configuring-a-for-loop-container"></a>Настройка контейнера «цикл по элементам»  
 Вместе с набором переменных первым добавляемым компонентом является контейнер «цикл по элементам».  
  
#### <a name="to-configure-a-for-loop-container-to-wait-until-change-data-is-ready"></a>Настройка контейнера «цикл по элементам» для ожидания готовности измененных данных  
  
1.  На вкладке **Поток управления** конструктора служб [!INCLUDE[ssIS](../../includes/ssis-md.md)] добавьте к потоку управления контейнер «цикл по элементам».  
  
2.  Соедините задачу «Выполнение SQL», вычисляющую конечные точки интервала, с контейнером «цикл по элементам».  
  
3.  В окне **Редактор циклов по элементам**выберите следующие параметры.  
  
    1.  В поле **InitExpression**введите выражение `@DataReady = 0`.  
  
         Это выражение задает исходное значение для переменной цикла.  
  
    2.  В поле **EvalExpression**введите `@DataReady == 0`.  
  
         Когда это выражение принимает значение **False**, выполнение цикла прекращается и начинается добавочная загрузка.  
  
## <a name="configuring-the-execute-sql-task-that-queries-for-change-data"></a>Настройка задачи «Выполнение SQL» для запроса об измененных данных  
 Внутри контейнера «цикл по элементам» добавьте задачу «Выполнение SQL». Эта задача направляет запросы к таблицам, которые обслуживаются системой отслеживания измененных данных в базах данных. Результат этого запроса — значение состояния, указывающее на готовность измененных данных.  
  
 В первом столбце следующей таблицы показаны значения, возвращаемые из задачи «Выполнение SQL» образцом запроса на языке Transact-SQL. Второй столбец показывает, как реагируют на эти значения остальные компоненты.  
  
|Возвращаемое значение|Значение|Ответ|  
|------------------|-------------|--------------|  
|0|Показывает, что измененные данные не готовы.<br /><br /> Отсутствуют записи системы отслеживания измененных данных за период после конечной точки выбранного интервала.|Выполнение продолжает компонент, реализующий задержку. Затем управление возвращается контейнеру «цикл по элементам», который продолжает проверку задачи «Выполнение SQL» до тех пор, пока возвращается значение 0.|  
|1|Может означать, что измененные данные не были отслежены на протяжении всего интервала, либо они были удалены. Это считается ошибкой.<br /><br /> Отсутствуют записи системы отслеживания измененных данных за период до начальной точки выбранного интервала.|Выполнение продолжает дополнительный компонент, который регистрирует ошибку.|  
|2|Указывает, что данные готовы.<br /><br /> Имеются записи системы отслеживания измененных данных как за период до начальной точки выбранного интервала, так и за период после конечной точки.|Вычисление выходит за пределы контейнера «цикл по элементам», и начинается добавочная загрузка.|  
|3|Указывает на первоначальную загрузку всех доступных измененных данных.<br /><br /> Условная логика получает это значение от специальной переменной пакета, которая используется только для этой цели.|Вычисление выходит за пределы контейнера «цикл по элементам», и начинается добавочная загрузка.|  
|5|Указывает на то, что достигнуто значение TimeoutCeiling.<br /><br /> Цикл произвел проверку на наличие данных указанное число раз, а данные все еще недоступны. Если не выполнять эту или аналогичную ей проверку, пакет может выполняться неограниченно долго.|Выполнение продолжает дополнительный компонент, который регистрирует истечение времени ожидания.|  
  
#### <a name="to-configure-an-execute-sql-task-to-query-whether-change-data-is-ready"></a>Настройка задачи «Выполнение SQL» для запроса готовности измененных данных  
  
1.  В пределах контейнера «цикл по элементам» добавьте задачу «Выполнение SQL».  
  
2.  В окне **Редактор задачи «Выполнение SQL»** на странице **Общие** выберите следующие параметры:  
  
    1.  Для параметра **ResultSet**выберите значение **Одна строка**.  
  
    2.  Настройте допустимое соединение с базой данных-источником.  
  
    3.  Для параметра **SQLSourceType**выберите значение **Прямой ввод**.  
  
    4.  В поле **SQLStatement**введите приведенную ниже инструкцию SQL:  
  
        ```  
        declare @DataReady int, @TimeoutCount int  
  
        if not exists (select tran_end_time from cdc.lsn_time_mapping  
                where tran_end_time > ?  )  
            select @DataReady = 0  
        else  
            if ? = 0  
                select @DataReady = 3   
        else  
            if not exists (select tran_end_time from cdc.lsn_time_mapping  
                    where tran_end_time <= ? )  
                select @DataReady = 1   
        else  
            select @DataReady = 2  
  
        select @TimeoutCount = ?  
        if (@DataReady = 0)  
            select @TimeoutCount = @TimeoutCount + 1  
        else  
            select @TimeoutCount = 0  
  
        if (@TimeoutCount > ?)  
            select @DataReady = 5  
  
        select @DataReady as DataReady, @TimeoutCount as TimeoutCount  
  
        ```  
  
3.  На странице **Сопоставление параметров** средства **Редактор задачи «Выполнение SQL»** произведите следующие сопоставления.  
  
    1.  Сопоставьте переменную ExtractEndTime с параметром 0.  
  
    2.  Сопоставьте переменную IntervalID с параметром 1.  
  
    3.  Сопоставьте переменную ExtractStartTime с параметром 2.  
  
    4.  Сопоставьте переменную TimeoutCount с параметром 3.  
  
    5.  Сопоставьте переменную TimeoutCeiling с параметром 4.  
  
4.  На странице **Результирующий набор** средства **Редактор задачи «Выполнение SQL»** сопоставьте результат DataReady с переменной DataReady и результат TimeoutCount с переменной TimeoutCount.  
  
## <a name="waiting-until-the-change-data-is-ready"></a>Ожидание готовности измененных данных  
 Если измененные данные не готовы, можно использовать один из нескольких методов реализации задержки. Две следующие процедуры показывают, как реализуется задержка с помощью задачи «Скрипт» или задачи «Выполнение SQL».  
  
> [!NOTE]  
>  Выполнение предварительно скомпилированных скриптов требует меньше ресурсов, чем использование задачи «Выполнение SQL».  
  
#### <a name="to-implement-a-delay-by-using-a-script-task"></a>Реализация задержки с помощью задачи «Скрипт»  
  
1.  В пределах контейнера «цикл по элементам» добавьте задачу «Скрипт».  
  
2.  Соедините задачу «Выполнение SQL», которая запрашивает готовность системы отслеживания измененных данных, с новой задачей «Скрипт».  
  
3.  Для управления очередностью, соединяющего задачу «Выполнение SQL» с задачей «Скрипт», откройте **Редактор управления очередностью** и выберите следующие параметры:  
  
    1.  В списке **Вычислительная операция**выберите пункт **Выражение и ограничение**.  
  
    2.  Для параметра **Значение**выберите значение **Успех**.  
  
         Ограничение по значению **Успех** относится к успешности выполнения предыдущей задачи. В этом случае это означает успешное выполнение задачи «Выполнение SQL».  
  
    3.  В поле **Выражение**введите `@DataReady == 0 && @TimeoutCount <= @TimeoutCeiling`.  
  
    4.  Установите флажок **Логическое И. Все аргументы должны иметь значение True**, если он еще не выбран.  
  
4.  В средстве **Редактор задачи «Скрипт»** на странице **Скрипт** для свойства **ReadOnlyVariables**выберите из списка целочисленную переменную **User::DelaySeconds** .  
  
5.  В окне **Редактор задачи «Скрипт»** на странице **Скрипт** нажмите кнопку **Изменить скрипт** , чтобы открыть среду разработки скриптов.  
  
6.  В главной процедуре введите одну из следующих строк кода.  
  
    -   При программировании на языке C# введите следующую строку кода:  
  
        ```  
        System.Threading.Thread.Sleep((int)Dts.Variables["DelaySeconds"].Value * 1000);  
        ```  
  
         \- или -  
  
    -   При программировании на языке [!INCLUDE[vbprvb](../../includes/vbprvb-md.md)], введите следующую строку кода:  
  
        ```  
        System.Threading.Thread.Sleep(Ctype(Dts.Variables("DelaySeconds").Value, Integer) * 1000)  
  
        ```  
  
        > [!NOTE]  
        >  Метод `Thread.Sleep` ожидает аргумент, указанный в миллисекундах.  
  
7.  Оставьте без изменений создаваемую по умолчанию строку кода, которая возвращает `DtsExecResult.Success` в результате выполнения скрипта.  
  
8.  Закройте среду разработки скриптов и **Редактор задачи «Скрипт»** .  
  
#### <a name="to-implement-a-delay-by-using-an-execute-sql-task"></a>Реализация задержки с помощью задачи «Выполнение SQL»  
  
1.  В пределах контейнера «цикл по элементам» добавьте задачу «Выполнение SQL».  
  
2.  Соедините задачу «Выполнение SQL», которая направляет запросы для выявления готовности измененных данных, с новой задачей «Выполнение SQL».  
  
3.  Для управления очередностью, которое соединяет две задачи «Выполнение SQL», откройте средство **Редактор управления очередностью** и выберите следующие параметры.  
  
    1.  В списке **Вычислительная операция**выберите пункт **Выражение и ограничение**.  
  
    2.  Для параметра **Значение**выберите значение **Успех**.  
  
         Ограничение по значению **Успешно** указывает на успешное завершение предшествующей задачи «Выполнение SQL».  
  
    3.  В поле **Выражение**введите `@DataReady == 0`.  
  
    4.  Установите флажок **Логическое И. Все аргументы должны иметь значение True**, если он еще не выбран.  
  
         При выборе этого варианта оба условия (ограничение и выражение) должны иметь значение true.  
  
4.  В окне **Редактор задачи «Выполнение SQL»** на странице **Общие** выберите следующие параметры:  
  
    1.  Для параметра **ResultSet**выберите значение **Одна строка**.  
  
    2.  Настройте допустимое соединение с базой данных-источником.  
  
    3.  Для параметра **SQLSourceType**выберите значение **Прямой ввод**.  
  
    4.  В поле **SQLStatement**введите приведенную ниже инструкцию SQL:  
  
        ```  
        WAITFOR DELAY ?  
  
        ```  
  
5.  На странице **Сопоставление параметров** редактора сопоставьте строковую переменную DelaySeconds с параметром 0.  
  
## <a name="handling-an-error-condition"></a>Обработка ошибки  
 При необходимости можно настроить внутри цикла дополнительный компонент для регистрации ошибок или превышении времени ожидания.  
  
-   Этот компонент может регистрировать ошибку, если значение переменной DataReady = 1. Это значение указывает на то, что измененных данных за период до начала выбранного интервала нет.  
  
-   Данный компонент может также регистрировать превышение времени ожидания по достижении указанного значения переменной TimeoutCeiling. Это значение указывает на то, что цикл выполнил проверку на наличие данных указанное число раз, но данные все еще недоступны. Если не выполнять эту или аналогичную ей проверку, пакет может выполняться неограниченно долго.  
  
#### <a name="to-configure-an-optional-script-task-to-log-an-error-condition"></a>Настройка дополнительной задачи «Скрипт» для регистрации ошибки  
  
1.  Если необходимо создать отчет об ошибке или превышении времени ожидания, записав сообщение в журнал, настройте ведение журнала для пакета. Дополнительные сведения см. в разделе [Включение средств ведения журналов в SQL Server Data Tools](../enable-package-logging-in-sql-server-data-tools.md).  
  
2.  В пределах контейнера «цикл по элементам» добавьте задачу «Скрипт».  
  
3.  Соедините задачу «Выполнение SQL», которая запрашивает готовность системы отслеживания измененных данных, с новой задачей «Скрипт».  
  
4.  Для управления очередностью, соединяющего задачу «Выполнение SQL» с задачей «Скрипт», откройте **Редактор управления очередностью** и выберите следующие параметры:  
  
    1.  В списке **Вычислительная операция**выберите пункт **Выражение и ограничение**.  
  
    2.  Для параметра **Значение**выберите значение **Успех**.  
  
         Ограничение по значению **Успех** относится к успешности выполнения предыдущей задачи. В этом случае это означает успешное выполнение задачи «Выполнение SQL».  
  
    3.  В поле **Выражение**введите `@DataReady == 1 || @DataReady == 5`.  
  
    4.  Установите флажок **Логическое И. Все аргументы должны иметь значение True**, если он еще не выбран.  
  
         При выборе этого варианта оба условия (ограничение и выражение) должны иметь значение true.  
  
5.  В средстве **Редактор задачи «Скрипт»** на странице **Скрипт** для свойства **ReadOnlyVariables**выберите из списка параметры **User::DataReady** и **User::ExtractStartTime** , чтобы их значения были доступны для скрипта.  
  
     Если необходимо включить в записываемые в журнал сведения данные из определенных системных переменных (например, System::PackageName), выберите и эти переменные.  
  
6.  В окне **Редактор задачи «Скрипт»** на странице **Скрипт** нажмите кнопку **Изменить скрипт** , чтобы открыть среду разработки скриптов.  
  
7.  В главную процедуру добавьте код для регистрации ошибки путем вызова метода `Dts.Log` или создайте событие, путем вызова одного из методов интерфейса `Dts.Events`. Информируйте пакет об ошибке, вернув `Dts.TaskResult = Dts.Results.Failure`.  
  
     Следующий образец показывает, как записать сообщение в журнал. Дополнительные сведения см. в разделах [Logging in the Script Task](../extending-packages-scripting/task/logging-in-the-script-task.md), [Raising Events in the Script Task](../extending-packages-scripting/task/raising-events-in-the-script-task.md)и [Returning Results from the Script Task](../extending-packages-scripting/task/returning-results-from-the-script-task.md).  
  
    ```  
    ' User variables.  
    Dim dataReady As Integer = _  
      CType(Dts.Variables("DataReady").Value, Integer)  
    Dim extractStartTime As Date = _  
      CType(Dts.Variables("ExtractStartTime").Value, DateTime)  
  
    ' System variables.  
    Dim packageName As String = _  
      Dts.Variables("PackageName").Value.ToString()  
    Dim executionStartTime As Date = _  
      CType(Dts.Variables("StartTime").Value, DateTime)  
  
    Dim eventMessage As New System.Text.StringBuilder()  
  
    If dataReady = 1 OrElse dataReady = 5 Then  
  
      If dataReady = 1 Then  
        eventMessage.AppendLine("Start Time Error")  
      Else  
        eventMessage.AppendLine("Timeout Error")  
      End If  
  
      With eventMessage  
        .Append("The package ")  
        .Append(packageName)  
        .Append(" started at ")  
        .Append(executionStartTime.ToString())  
        .Append(" and ended at ")  
        .AppendLine(DateTime.Now().ToString())  
        If dataReady = 1 Then  
          .Append("The specified ExtractStartTime was ")  
          .AppendLine(extractStartTime.ToString())  
        End If  
      End With  
  
      System.Windows.Forms.MessageBox.Show(eventMessage.ToString())  
  
      Dts.Log(eventMessage.ToString(), 0, Nothing)  
  
      Dts.TaskResult = Dts.Results.Failure  
  
    Else  
  
      Dts.TaskResult = Dts.Results.Success  
  
    End If  
  
    ```  
  
8.  Закройте среду разработки скриптов и **Редактор задачи «Скрипт»** .  
  
## <a name="next-step"></a>Следующий шаг  
 Убедившись, что информация об изменениях готова, выполните следующий шаг — подготовьте запрос для получения измененных данных.  
  
 **Следующая статья:** [Подготовка к запросу информации об изменениях данных](prepare-to-query-for-the-change-data.md)  
  
  

---
title: Вложенные таблицы (Analysis Services — интеллектуальный анализ данных) | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: analysis-services
ms.topic: conceptual
helpviewer_keywords:
- data mining [Analysis Services], nested tables
- tables [Analysis Services], nested
- nested tables
ms.assetid: cb192aa2-597e-4d4f-ac34-3556d037fed4
author: minewiskan
ms.author: owend
ms.openlocfilehash: 78b1022751ae6d381b86512f45f7232bebe7fcd0
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87728962"
---
# <a name="nested-tables-analysis-services---data-mining"></a><span data-ttu-id="65db1-102">Вложенные таблицы (службы Analysis Services — интеллектуальный анализ данных)</span><span class="sxs-lookup"><span data-stu-id="65db1-102">Nested Tables (Analysis Services - Data Mining)</span></span>
  <span data-ttu-id="65db1-103">В [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] данные должны передаваться в алгоритм интеллектуального анализа данных в виде последовательности вариантов, содержащихся в таблице вариантов.</span><span class="sxs-lookup"><span data-stu-id="65db1-103">In [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)], data must be fed to a data mining algorithm as a series of cases that are contained within a case table.</span></span> <span data-ttu-id="65db1-104">Но не все варианты можно описать одной строкой данных.</span><span class="sxs-lookup"><span data-stu-id="65db1-104">However, not all cases can be described by a single row of data.</span></span> <span data-ttu-id="65db1-105">Например, некоторый вариант может быть выведен на основании двух таблиц: таблицы, содержащей данные о заказчике, и таблицы, содержащей сведения о покупках заказчика.</span><span class="sxs-lookup"><span data-stu-id="65db1-105">For example, a case might be derived from two tables: one table that contains customer information, and another table that contains customer purchases.</span></span> <span data-ttu-id="65db1-106">Одному заказчику из таблицы заказчиков может соответствовать несколько элементов в таблице покупок, что усложняет описание данных в одной строке.</span><span class="sxs-lookup"><span data-stu-id="65db1-106">A single customer in the customer information table might have multiple items in the customer purchases table, which makes it difficult to describe the data by using a single row.</span></span> [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)]<span data-ttu-id="65db1-107">предоставляет уникальный метод для обработки этих вариантов с помощью *вложенных таблиц*.</span><span class="sxs-lookup"><span data-stu-id="65db1-107">provides a unique method for handling these cases, by using *nested tables*.</span></span> <span data-ttu-id="65db1-108">Понятие вложенной таблицы демонстрируется на следующей схеме.</span><span class="sxs-lookup"><span data-stu-id="65db1-108">The concept of a nested table is demonstrated in the following illustration.</span></span>  
  
 <span data-ttu-id="65db1-109">![Две таблицы, объединенные с помощью вложенной таблицы](../media/nested-tables.gif "Две таблицы, объединенные с помощью вложенной таблицы")</span><span class="sxs-lookup"><span data-stu-id="65db1-109">![Two tables combined by using a nested table](../media/nested-tables.gif "Two tables combined by using a nested table")</span></span>  
  
 <span data-ttu-id="65db1-110">На этой диаграмме первая таблица, являющаяся «родительской» таблицей, содержит данные о заказчиках и связывает уникальный идентификатор с каждым заказчиком.</span><span class="sxs-lookup"><span data-stu-id="65db1-110">In this diagram, the first table, which is the parent table, contains information about customers, and associates a unique identifier for each customer.</span></span> <span data-ttu-id="65db1-111">Вторая таблица, «дочерняя», содержит покупки каждого заказчика.</span><span class="sxs-lookup"><span data-stu-id="65db1-111">The second table, the child table, contains the purchases for each customer.</span></span> <span data-ttu-id="65db1-112">Покупки в дочерней таблице связаны с родительской таблицей уникальным идентификатором — столбцом **CustomerKey** .</span><span class="sxs-lookup"><span data-stu-id="65db1-112">The purchases in the child table are related to the parent table by the unique identifier, the **CustomerKey** column.</span></span> <span data-ttu-id="65db1-113">Третья таблица на диаграмме показывает комбинацию этих двух таблиц.</span><span class="sxs-lookup"><span data-stu-id="65db1-113">The third table in the diagram shows the two tables combined.</span></span>  
  
 <span data-ttu-id="65db1-114">Вложенная таблица представлена в таблице вариантов специальным столбцом с типом данных **TABLE**.</span><span class="sxs-lookup"><span data-stu-id="65db1-114">A nested table is represented in the case table as a special column that has a data type of **TABLE**.</span></span> <span data-ttu-id="65db1-115">Для каждой конкретной строки варианта этот тип столбца содержит выбранные строки из «дочерней» таблицы, относящиеся в «родительской» таблице.</span><span class="sxs-lookup"><span data-stu-id="65db1-115">For any particular case row, this kind of column contains selected rows from the child table that pertain to the parent table.</span></span>  
  
 <span data-ttu-id="65db1-116">Данные во вложенной таблице могут быть использованы для прогноза, для ввода или для обеих операций.</span><span class="sxs-lookup"><span data-stu-id="65db1-116">The data in a nested table can be used for prediction or for input, or for both.</span></span> <span data-ttu-id="65db1-117">Например, в модели есть два столбца вложенной таблицы: один столбец может содержать список продуктов, приобретенных покупателем, а другой — сведения о хобби и интересах покупателя, например, полученных из его анкеты.</span><span class="sxs-lookup"><span data-stu-id="65db1-117">For example, you might have two nested table columns in a model: one nested table column might contain a list of the products that a customer has purchased, while the other nested table column contains information about the customer's hobbies and interests, possibly obtained from a survey.</span></span> <span data-ttu-id="65db1-118">В данном сценарии необходимо использовать хобби и интересы покупателя в качестве входных данных для анализа поведения при покупке и прогнозирования вероятных покупок.</span><span class="sxs-lookup"><span data-stu-id="65db1-118">In this scenario, you could use the customer's hobbies and interests as an input for analyzing purchasing behavior, and predicting likely purchases.</span></span>  
  
## <a name="joining-case-tables-and-nested-tables"></a><span data-ttu-id="65db1-119">Соединение таблиц вариантов и вложенных таблиц</span><span class="sxs-lookup"><span data-stu-id="65db1-119">Joining Case Tables and Nested Tables</span></span>  
 <span data-ttu-id="65db1-120">Чтобы создать вложенную таблицу, две таблицы источника должны содержать определенную связь, чтобы элементы в одной таблице могли быть связаны с другой таблицей.</span><span class="sxs-lookup"><span data-stu-id="65db1-120">In order to create a nested table, the two source tables must contain a defined relationship so that the items in one table can be related to the other table.</span></span> <span data-ttu-id="65db1-121">В среде [!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)]можно определять эту связь в представлении источника данных.</span><span class="sxs-lookup"><span data-stu-id="65db1-121">In [!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)], you can define this relationship in the data source view.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="65db1-122">Поле **CustomerKey** представляет собой реляционный ключ, который используется для связывания таблицы вариантов и вложенной таблицы в определении представления источников данных, а также для установления связи столбцов в структуре интеллектуального анализа данных.</span><span class="sxs-lookup"><span data-stu-id="65db1-122">The **CustomerKey** field is the relational key that is used to link the case table and the nested table within the data source view definition, and to establish the relationship of the columns within the mining structure.</span></span> <span data-ttu-id="65db1-123">Но, как правило, не следует использовать указанный реляционный ключ в моделях интеллектуального анализа данных, основанных на этой структуре.</span><span class="sxs-lookup"><span data-stu-id="65db1-123">However, typically you should not use this relational key in mining models built on that structure.</span></span> <span data-ttu-id="65db1-124">Обычно лучше исключить из модели интеллектуального анализа данных столбец реляционного ключа, предназначенный исключительно для соединения таблиц и не содержащий данных, интересных для анализа.</span><span class="sxs-lookup"><span data-stu-id="65db1-124">Usually it is best to omit the relational key column from the mining model if it serves only to join the tables and does not provide information that is interesting for analysis.</span></span>  
  
 <span data-ttu-id="65db1-125">Можно создавать вложенные таблицы программным путем, используя либо расширения интеллектуального анализа данных, либо объекты AMO, или можно использовать мастер интеллектуального анализа данных в конструкторе интеллектуального анализа данных в среде [!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)].</span><span class="sxs-lookup"><span data-stu-id="65db1-125">You can create nested tables programmatically by either using Data Mining Extensions (DMX) or Analysis Management Objects (AMO), or you can use the Data Mining Wizard and Data Mining Designer in [!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)].</span></span>  
  
## <a name="using-nested-table-columns-in-a-mining-model"></a><span data-ttu-id="65db1-126">Использование столбцов вложенной таблицы в модели интеллектуального анализа данных</span><span class="sxs-lookup"><span data-stu-id="65db1-126">Using Nested Table Columns in a Mining Model</span></span>  
 <span data-ttu-id="65db1-127">В таблице вариантов ключами часто являются идентификаторы заказчиков, названия продуктов или последовательные значения дат, то есть данные, которые однозначно определяют строку в таблице.</span><span class="sxs-lookup"><span data-stu-id="65db1-127">In the case table, the key is often a customer ID, a product name, or date in a series: data that uniquely identifies a row in the table.</span></span> <span data-ttu-id="65db1-128">.</span><span class="sxs-lookup"><span data-stu-id="65db1-128">.</span></span> <span data-ttu-id="65db1-129">Но во вложенных таблицах ключом обычно является не реляционный ключ (или внешний ключ), а, скорее, столбец, представляющий моделируемый атрибут.</span><span class="sxs-lookup"><span data-stu-id="65db1-129">However, in nested tables, the key is typically not the relational key (or foreign key) but rather the column that represents the attribute that you are modeling.</span></span>  
  
 <span data-ttu-id="65db1-130">Например, если таблица вариантов содержит заказы, а вложенная таблица содержит продукты из заказов, то может оказаться интересным моделирование связи между продуктами, хранящимися во вложенной таблице, с охватом нескольких заказов, которые хранятся в таблице вариантов.</span><span class="sxs-lookup"><span data-stu-id="65db1-130">For example, if the case table contains orders, and the nested table contains items in the order, you would be interested in modeling the relationship between items stored in the nested table across multiple orders, which are stored in the case table.</span></span> <span data-ttu-id="65db1-131">Таким образом, несмотря на то что вложенная таблица **Items** соединяется с таблицей вариантов **Orders** по реляционному ключу **OrderID**, сам идентификатор заказа **OrderID** не должен использоваться как ключ вложенной таблицы.</span><span class="sxs-lookup"><span data-stu-id="65db1-131">Therefore, although the **Items** nested table is joined to the **Orders** case table by the relational key **OrderID**, you should not use **OrderID** as the nested table key.</span></span> <span data-ttu-id="65db1-132">Вместо этого в качестве ключа вложенной таблицы следует выбрать столбец **Items** , поскольку этот столбец содержит данные, которые должны быть промоделированы.</span><span class="sxs-lookup"><span data-stu-id="65db1-132">Instead, you would select the **Items** column as the nested table key, because that column contains the data that you want to model.</span></span> <span data-ttu-id="65db1-133">В большинстве случаев можно без опасений пропустить столбец **OrderID** в модели интеллектуального анализа данных, поскольку связь между таблицей вариантов и вложенной таблицей уже установлена с помощью определения представления источников данных.</span><span class="sxs-lookup"><span data-stu-id="65db1-133">In most cases, you can safely ignore **OrderID** in the mining model, because the relationship between the case table and the nested table has already been established by the data source view definition.</span></span>  
  
 <span data-ttu-id="65db1-134">При выборе столбца, предназначенного для использования в качестве ключа вложенной таблицы, необходимо убедиться в том, что значения в этом столбце являются уникальными для каждого варианта.</span><span class="sxs-lookup"><span data-stu-id="65db1-134">When you choose a column to use as the nested table key, you must ensure that the values in that column are unique for each case.</span></span> <span data-ttu-id="65db1-135">Например, если таблица вариантов представляет заказчиков, а вложенная таблица представляет продукты, приобретенные конкретным заказчиком, то необходимо обеспечить, чтобы ни один продукт не был перечислен больше одного раза для каждого заказчика.</span><span class="sxs-lookup"><span data-stu-id="65db1-135">For example, if the case table represents customers and the nested table represents items purchased by the customer, you must ensure that no item is listed more than one time per customer.</span></span> <span data-ttu-id="65db1-136">Если заказчик приобретал одни и те же продукты больше одного раза, то может потребоваться создать другое представление, имеющее столбец, накапливающий количество покупок, относящихся к каждому продукту.</span><span class="sxs-lookup"><span data-stu-id="65db1-136">If a customer has purchased the same item more than one time, you might want to create a different view that has a column that aggregates the count of purchases for each unique product.</span></span>  
  
 <span data-ttu-id="65db1-137">Должно быть принято решение о том, как следует обрабатывать повторяющиеся значения во вложенной таблице, в зависимости от того, какая модель интеллектуального анализа данных создается и какова конкретная решаемая экономическая задача.</span><span class="sxs-lookup"><span data-stu-id="65db1-137">How you decide to handle duplicate values in a nested table depends on the mining model that you are creating and the business problem that you are solving.</span></span> <span data-ttu-id="65db1-138">В некоторых сценариях может не иметь значения то, сколько раз заказчик приобретал конкретный продукт, но требуется проверить наличие по меньшей мере одной покупки этого продукта.</span><span class="sxs-lookup"><span data-stu-id="65db1-138">In some scenarios you might not care how many times a customer has purchased a particular product, but want to check for the existence of at least one purchase.</span></span> <span data-ttu-id="65db1-139">В других сценариях могут оказаться очень важными количество и последовательность приобретений.</span><span class="sxs-lookup"><span data-stu-id="65db1-139">In other scenarios, the quantity and sequence of purchases might be very important.</span></span>  
  
 <span data-ttu-id="65db1-140">Если имеет значение то, в каком порядке приобретались продукты, может потребоваться дополнительный столбец, который будет отображать эту последовательность.</span><span class="sxs-lookup"><span data-stu-id="65db1-140">If the order of items is important, you might need an additional column that indicates the sequence.</span></span> <span data-ttu-id="65db1-141">Если для создания модели используется алгоритм кластеризации последовательности, то необходимо выбрать дополнительный столбец *ключевой последовательности* для представления порядка элементов.</span><span class="sxs-lookup"><span data-stu-id="65db1-141">When you use the sequence clustering algorithm to create a model, you must choose an additional *key sequence* column to represent the order of the items.</span></span> <span data-ttu-id="65db1-142">Столбец ключевой последовательности представляет собой вложенный ключ особого вида, который используется только в моделях кластеризации последовательностей и требует применения уникального числового типа данных.</span><span class="sxs-lookup"><span data-stu-id="65db1-142">The key sequence column is a special kind of nested key that is used only in sequence clustering models, and requires a unique numeric data type.</span></span> <span data-ttu-id="65db1-143">Например, в качестве значений столбца ключевой последовательности могут использоваться и целые числа, и даты, но все значения последовательности должны быть уникальными.</span><span class="sxs-lookup"><span data-stu-id="65db1-143">For example, integers and dates can both be used as a key sequence column, but all sequence values must be unique.</span></span> <span data-ttu-id="65db1-144">Кроме столбца ключевой последовательности в модели кластеризации последовательностей имеется также ключ вложенной таблицы, который представляет моделируемый атрибут, такой как приобретаемые товары.</span><span class="sxs-lookup"><span data-stu-id="65db1-144">In addition to the key sequence column, a sequence clustering model also has a nested table key that represents the attribute that is being modeled, such as the products that have been purchased.</span></span>  
  
### <a name="using-non-key-nested-columns-from-a-nested-table"></a><span data-ttu-id="65db1-145">Использование неключевых вложенных столбцов из вложенной таблицы</span><span class="sxs-lookup"><span data-stu-id="65db1-145">Using Non-Key Nested Columns from a Nested Table</span></span>  
 <span data-ttu-id="65db1-146">После определения соединения между таблицей вариантов и вложенной таблицей и выбора столбца, содержащего интересующие и уникальные атрибуты, предназначенные для использования в качестве ключа вложенной таблицы, можно включить другие столбцы из вложенной таблицы, чтобы использовать их в качестве входных данных для модели.</span><span class="sxs-lookup"><span data-stu-id="65db1-146">After you have defined the join between the case table and the nested table, and you have chosen a column that contains interesting and unique attributes to use as the nested table key, you can include other columns from the nested table to use as input to the model.</span></span> <span data-ttu-id="65db1-147">Все столбцы вложенной таблицы могут использоваться в качестве входных, прогнозируемых и входных или только прогнозируемых.</span><span class="sxs-lookup"><span data-stu-id="65db1-147">All columns from the nested table can be used for input, prediction and input, or for prediction only.</span></span>  
  
 <span data-ttu-id="65db1-148">Например, если вложенная таблица содержит столбцы **Product**, **ProductQuantity**и **ProductPrice**, можно выбрать **Product** в качестве ключа вложенной таблицы, но добавить столбец **ProductQuantity** к структуре интеллектуального анализа данных, чтобы использовать его данные в качестве входных.</span><span class="sxs-lookup"><span data-stu-id="65db1-148">For example, if the nested table contains the columns **Product**, **ProductQuantity**, and **ProductPrice**, you might choose **Product** as the nested table key, but add **ProductQuantity** to the mining structure to use as input.</span></span>  
  
## <a name="filtering-nested-table-data"></a><span data-ttu-id="65db1-149">Фильтрация данных вложенной таблицы</span><span class="sxs-lookup"><span data-stu-id="65db1-149">Filtering Nested Table Data</span></span>  
 <span data-ttu-id="65db1-150">В [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)]предусмотрена возможность создавать фильтры для данных, используемых для обучения или проверки модели интеллектуального анализа данных.</span><span class="sxs-lookup"><span data-stu-id="65db1-150">In [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)], you can create filters on the data that is used to train or test a data mining model.</span></span> <span data-ttu-id="65db1-151">Фильтр может также применяться для воздействия на компоновку модели или для проверки модели на подмножестве вариантов.</span><span class="sxs-lookup"><span data-stu-id="65db1-151">A filer can be used to affect the composition of the model, or to test the model on a subset of cases.</span></span> <span data-ttu-id="65db1-152">Фильтры могут также применяться к вложенным таблицам.</span><span class="sxs-lookup"><span data-stu-id="65db1-152">Filters can also be applied to nested tables.</span></span> <span data-ttu-id="65db1-153">Тем не менее существуют ограничения, касающиеся того, какой синтаксис может использоваться применительно к вложенным таблицам.</span><span class="sxs-lookup"><span data-stu-id="65db1-153">However, there are limitations on the syntax that can be used with nested tables.</span></span>  
  
 <span data-ttu-id="65db1-154">Применение фильтра к вложенной таблице часто осуществляется для проверки на существование атрибута.</span><span class="sxs-lookup"><span data-stu-id="65db1-154">Often when you apply a filter to a nested table you are testing for the existence or nonexistence of an attribute.</span></span> <span data-ttu-id="65db1-155">Например, может быть применен фильтр, который ограничивает количество вариантов, используемых в модели, только теми вариантами, которые имеют указанное значение во вложенной таблице.</span><span class="sxs-lookup"><span data-stu-id="65db1-155">For example, you can apply a filter that restricts the cases used in the model to only those cases that have a specified value in the nested table.</span></span> <span data-ttu-id="65db1-156">Кроме того, варианты, используемые в модели, можно ограничить заказчиками, которые не приобретали конкретный продукт.</span><span class="sxs-lookup"><span data-stu-id="65db1-156">Or, you could restrict the cases used in the model to customers who have not purchased a particular item.</span></span>  
  
 <span data-ttu-id="65db1-157">При создании фильтров на вложенной таблице можно также использовать такие операторы, как больше или меньше.</span><span class="sxs-lookup"><span data-stu-id="65db1-157">When you create filters on a nested table, you can also use operators such as greater than or less than.</span></span> <span data-ttu-id="65db1-158">Например, можно ограничить варианты, используемые в модели, заказчиками, которые приобрели не менее n единиц целевого продукта.</span><span class="sxs-lookup"><span data-stu-id="65db1-158">For example, you could restrict the cases used in the model to customers who had purchased at least n units of the target product.</span></span> <span data-ttu-id="65db1-159">Возможность применения фильтра к атрибутам вложенной таблицы способствует значительному повышению гибкости при настройке модели.</span><span class="sxs-lookup"><span data-stu-id="65db1-159">The ability to filter on nested table attributes provides great flexibility for customizing models.</span></span>  
  
 <span data-ttu-id="65db1-160">Дополнительные сведения о создании и использовании фильтров для моделей см. в разделе [Фильтры для моделей интеллектуального анализа данных (службы Analysis Services — интеллектуальный анализ данных)](mining-models-analysis-services-data-mining.md).</span><span class="sxs-lookup"><span data-stu-id="65db1-160">For more information about how to create and use model filters, see [Filters for Mining Models &#40;Analysis Services - Data Mining&#41;](mining-models-analysis-services-data-mining.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="65db1-161">См. также:</span><span class="sxs-lookup"><span data-stu-id="65db1-161">See Also</span></span>  
 <span data-ttu-id="65db1-162">[Алгоритмы интеллектуального анализа данных &#40;Analysis Services — интеллектуальный анализ данных&#41;](data-mining-algorithms-analysis-services-data-mining.md) </span><span class="sxs-lookup"><span data-stu-id="65db1-162">[Data Mining Algorithms &#40;Analysis Services - Data Mining&#41;](data-mining-algorithms-analysis-services-data-mining.md) </span></span>  
 [<span data-ttu-id="65db1-163">Структуры интеллектуального анализа данных (службы Analysis Services — интеллектуальный анализ данных)</span><span class="sxs-lookup"><span data-stu-id="65db1-163">Mining Structures &#40;Analysis Services - Data Mining&#41;</span></span>](mining-structures-analysis-services-data-mining.md)  
  
  

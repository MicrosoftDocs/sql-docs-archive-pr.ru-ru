---
title: Хранение строк и параметры сортировки в табличных моделях | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: analysis-services
ms.topic: conceptual
ms.assetid: 8516f0ad-32ee-4688-a304-e705143642ca
author: minewiskan
ms.author: owend
ms.openlocfilehash: 3aad4cf16c39897bc0796f4fb161eaf39abdb5fd
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87738819"
---
# <a name="string-storage-and-collation-in-tabular-models"></a>Хранение строк и параметры сортировки в табличных моделях
  Строки (текстовые значения) хранятся в формате с большим сжатием в табличных моделях. В силу сжатия при извлечении полных или частичных строк можно получить неверные результаты. Кроме того, поскольку языковой стандарт и параметры сортировки строки наследуются в иерархическом порядке у ближайшего родительского объекта, если язык строки не определен явным образом, локаль и параметры сортировки родительского элемента могут повлиять на то, как каждая строка хранится, является строка уникальной или объединена с похожими строками согласно определению параметров сортировки родительского элемента.  
  
 В этом разделе содержится описание механизма, с помощью которого сжимаются и сохраняются строки, а также примеры того, как параметры сортировки и язык влияют на результаты текстовых формул в табличных моделях.  
  
## <a name="storage"></a>Память  
 В табличных моделях все данные сильно сжаты для того, чтобы занимать меньше места в памяти. Как следствие, все строки, которые могут считаться лексически эквивалентными, сохраняются только один раз. Первый экземпляр строки используется в качестве канонического представления, после которой каждая эквивалентная строка индексируется с тем же сжатым значением, что и первый экземпляр.  
  
 Ключевой вопрос заключается в том, что такое лексически эквивалентная строка? Две строки считаются лексически эквивалентными, если они могут рассматриваться как одно и то же слово. Например, если искать в словаре русского языка слово **скрипка** , можно найти запись **Скрипка** или **скрипка**, в зависимости от политики редактирования словаря, однако оба слова считаются эквивалентными, и разница заглавной или прописной буквы не учитывается. В табличной модели коэффициент, который определяет, являются ли две строки лексически эквивалентными, не является политикой редактирования или даже предпочтением пользователя, он представляет собой локаль и порядок сортировки, заданные столбцу.  
  
 Таким образом, решение о том, является ли верхний и нижний регистр отличием двух слов, зависит от параметров сортировки и локали. Для любого слова локали первый экземпляр слова, находящийся в определенном столбце, служит каноническим представлением слова и строки, которая хранится в несжатом формате.  Все остальные строки проходят проверку относительно первого экземпляра, и если они не проходят тест на соответствие, то приписываются к сжатому значению первого экземпляра. В дальнейшем при извлечении сжатых значений они будут представлены с помощью несжатого значения первого экземпляра строки.  
  
 Следующий пример позволяет понять, как это работает. Следующий столбец «Классификация ― английский» был взят из таблицы, содержащей сведения о растениях и деревьях. Для каждого растения (имена растений не показаны) столбец классификации показывает общую категорию растения.  
  
|Классификация ― английский|  
|-------------------------------|  
|дереВО|  
|РасТениЕ|  
|дереВО|  
|РасТениЕ|  
|РасТениЕ|  
|Дерево|  
|РасТениЕ|  
|дереВО|  
|tree|  
|РасТениЕ|  
|дереВО|  
  
 Возможно, данные были получены из многих различных источников, поэтому регистр и использование диакритических знаков было неверным и реляционная база данных сохранила эти отличия как есть. Однако в целом это либо значения **Растение** , либо **Дерево**просто с разным регистром.  
  
 Когда эти значения загружаются в табличную модель, которая использует параметры сортировки по умолчанию и порядок сортировки для английского языка (США), регистр не имеет значения, поэтому для всего столбца будут храниться только два значения:  
  
|Классификация ― английский|  
|-------------------------------|  
|дереВО|  
|РасТениЕ|  
  
 Если в модели используется столбец " **классификация — Английский**", то при отображении классификации завода будут отображаться не исходные значения, а их различные варианты использования верхнего и нижнего регистра, но только первый экземпляр. Причина в том, что все варианты верхнего и нижнего регистров слова **дерево** считаются эквивалентными при этих параметрах сортировки и локали. Таким образом, была оставлена только одна строка, и только первый экземпляр этой строки, найденный системой, будет сохранен.  
  
> [!WARNING]  
>  Можно решить, какая строка будет сохранена первой, в соответствии с тем, какая строка признана верной, однако реализовать это будет сложно. Не существует простых путей для определения того, какая строка должна быть обработана ядром первой, если учитывать, что все значения считаются одинаковыми. Вместо этого, если необходимо задать стандартное значение, очистите все строки, прежде чем загружать модель.  
  
## <a name="locale-and-collation-order"></a>Локаль и порядок сортировки  
 При сравнении строк (текстовых значений) эквивалентность определяется культурным аспектом интерпретации этих строк. В некоторых странах диакритический знак или верхний регистр символа может полностью изменить значение строки. Поэтому обычно такие отличия учитываются при определении эквивалентности для какого-либо языка или региона.  
  
 Обычно компьютер уже настроен и соответствует определенному лингвистическому стилю, поэтому строковые операции, такие как сортировка и сравнение текстовых значений, выполняются в соответствии с ожиданиями. Параметры, определяющие зависящее от языка поведение, определяются в настройках **Языки и региональные стандарты** в Windows. Приложения считывают эти параметры и изменяют свое поведение соответствующим образом. В некоторых случаях приложение может иметь функцию, которая позволит изменить культурное поведение приложения или способ сравнения строк.  
  
 При создании табличных шаблонов баз данных по умолчанию база данных наследует эти культурные и лингвистические параметры в форме языкового идентификатора и параметров сортировки.  
  
-   Языковой идентификатор определяет набор символов, которые будут использованы для сравнения строк в соответствии с языковой средой.  
  
-   Параметры сортировки определяют порядок символов и их эквивалентность.  
  
 Следует отметить, что языковой идентификатор не только определяет язык, но также и страну или регион, где этот язык используется. Каждый языковой идентификатор также имеет определение параметров сортировки по умолчанию. Дополнительные сведения об идентификаторах языков см. в разделе [Номера локалей, назначаемые Microsoft](https://msdn.microsoft.com/goglobal/bb964664.aspx). При ручной вставке значения можно использовать столбец LCID Dec для получения нужного идентификатора. Дополнительные сведения об SQL-концепциях параметров сортировки см. в разделе [COLLATE (Transact-SQL)](/sql/t-sql/statements/collations). Дополнительные сведения об обозначениях параметров сортировки и стилях сравнения для имен параметров сортировки в Windows см. в разделе [Имя параметров сортировки Windows (Transact-SQL)](/sql/t-sql/statements/windows-collation-name-transact-sql). В разделе [Имя параметров сортировки SQL Server (Transact-SQL)](/sql/t-sql/statements/sql-server-collation-name-transact-sql) имена параметров сортировки Windows сопоставляются с именами, которые используются для SQL.  
  
 После создания табличных шаблонов баз данных все новые объекты в модели унаследуют атрибуты языка и параметры сортировки базы данных. Это верно для всех объектов. Путь наследования начинается от объекта, находит родительский объект для определения наследуемых атрибутов языка и параметры сортировки, если таковые не найдены, продолжает движение вверх и находит атрибуты языка и сортировки на уровне базы данных. Другими словами, если не указать атрибуты языка и параметры сортировки для объекта, то по умолчанию объект унаследует атрибуты своего ближайшего родительского элемента.  
  
 Для столбцов атрибуты языка и параметры сортировки наследуются при создании в соответствии со следующими правилами.  
  
1.  Выполняется поиск атрибутов языка и параметров сортировки в родительском объекте измерения. Если существуют оба значения, они копируются в атрибуты столбца. Если существует только одно значение, второе будет вычислено, после чего оба значения будут присвоены. Если оба значения не найдены, выполняется переход к следующему уровню.  
  
2.  Поиск объекта базы данных осуществляется с использованием того же процесса, который был описан в шаге 1 для измерений. Если атрибуты не найдены, выполняется переход к следующему шагу.  
  
3.  Поиск серверного объекта выполняется с помощью того же процесса, который был описан в шаге 1 для измерений. Если атрибуты не найдены, столбец использует языковой идентификатор Windows и получает атрибут параметра сортировки от этого значения.  
  
 Следует отметить, что обычно языковой идентификатор и порядок параметра сортировки в базе данных-источнике практически не влияет на способ хранения значений в столбце табличной модели. Исключение возникает, если база данных-источник преобразует или фильтрует запрошенные значения.  
  
  

---
title: Руководство по проектированию индексов SQL Server | Документация Майкрософт
ms.custom: ''
ms.date: 06/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
ms.assetid: b856ee9a-49e7-4fab-a88d-48a633fce269
author: rothja
ms.author: jroth
ms.openlocfilehash: 1f5ad72413fe71004fb1c5f125969b984db815d3
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87655464"
---
# <a name="sql-server-index-design-guide"></a><span data-ttu-id="20e4a-102">Руководство по проектированию индексов SQL Server</span><span class="sxs-lookup"><span data-stu-id="20e4a-102">SQL Server Index Design Guide</span></span>

  <span data-ttu-id="20e4a-103">Плохо спроектированные индексы и их недостаточное количество — основной источник узких мест в приложениях баз данных.</span><span class="sxs-lookup"><span data-stu-id="20e4a-103">Poorly designed indexes and a lack of indexes are primary sources of database application bottlenecks.</span></span> <span data-ttu-id="20e4a-104">Проектирование эффективных индексов имеет первостепенную важность для достижения высокой производительности баз данных и приложений.</span><span class="sxs-lookup"><span data-stu-id="20e4a-104">Designing efficient indexes is paramount to achieving good database and application performance.</span></span> <span data-ttu-id="20e4a-105">Это руководство по проектированию индексов SQL Server содержит сведения и рекомендации, руководствуясь которыми вы сможете создавать эффективные индексы, удовлетворяющие потребностям ваших приложений.</span><span class="sxs-lookup"><span data-stu-id="20e4a-105">This SQL Server index design guide contains information and best practices to help you design effective indexes to meet the needs of your application.</span></span>  
  
<span data-ttu-id="20e4a-106">**Применимо к:,** [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] если не указано иное.</span><span class="sxs-lookup"><span data-stu-id="20e4a-106">**Applies to**: [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] through [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] unless noted otherwise.</span></span>  
  
 <span data-ttu-id="20e4a-107">Предполагается, что читатель обладает общими знаниями типов индексов, которые есть в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="20e4a-107">This guide assumes the reader has a general understanding of the index types available in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="20e4a-108">Общее описание типов индексов приведено в разделе [Типы индексов](../relational-databases/indexes/indexes.md).</span><span class="sxs-lookup"><span data-stu-id="20e4a-108">For a general description of index types, see [Index Types](../relational-databases/indexes/indexes.md).</span></span>  
  
##  <a name="in-this-guide"></a><a name="Top"></a><span data-ttu-id="20e4a-109">В этом пошаговом окне</span><span class="sxs-lookup"><span data-stu-id="20e4a-109">In This Guide</span></span>  

 [<span data-ttu-id="20e4a-110">Основы проектирования индексов</span><span class="sxs-lookup"><span data-stu-id="20e4a-110">Index Design Basics</span></span>](#Basics)  
  
 [<span data-ttu-id="20e4a-111">Общие рекомендации по проектированию индексов</span><span class="sxs-lookup"><span data-stu-id="20e4a-111">General Index Design Guidelines</span></span>](#General_Design)  
  
 [<span data-ttu-id="20e4a-112">Рекомендации по проектированию кластеризованных индексов</span><span class="sxs-lookup"><span data-stu-id="20e4a-112">Clustered Index Design Guidelines</span></span>](#Clustered)  
  
 [<span data-ttu-id="20e4a-113">Рекомендации по проектированию некластеризованных индексов</span><span class="sxs-lookup"><span data-stu-id="20e4a-113">Nonclustered Index Design Guidelines</span></span>](#Nonclustered)  
  
 [<span data-ttu-id="20e4a-114">Рекомендации по проектированию уникальных индексов</span><span class="sxs-lookup"><span data-stu-id="20e4a-114">Unique Index Design Guidelines</span></span>](#Unique)  
  
 [<span data-ttu-id="20e4a-115">Рекомендации по проектированию фильтруемых индексов</span><span class="sxs-lookup"><span data-stu-id="20e4a-115">Filtered Index Design Guidelines</span></span>](#Filtered)  
  
 [<span data-ttu-id="20e4a-116">Дополнительные материалы</span><span class="sxs-lookup"><span data-stu-id="20e4a-116">Additional Reading</span></span>](#Additional_Reading)  
  
##  <a name="index-design-basics"></a><a name="Basics"></a> <span data-ttu-id="20e4a-117">Основы проектирования индексов</span><span class="sxs-lookup"><span data-stu-id="20e4a-117">Index Design Basics</span></span>  

 <span data-ttu-id="20e4a-118">Индекс является структурой на диске, которая связана с таблицей или представлением и ускоряет получение строк из таблицы или представления.</span><span class="sxs-lookup"><span data-stu-id="20e4a-118">An index is an on-disk structure associated with a table or view that speeds retrieval of rows from the table or view.</span></span> <span data-ttu-id="20e4a-119">Индекс содержит ключи, построенные из одного или нескольких столбцов в таблице или представлении.</span><span class="sxs-lookup"><span data-stu-id="20e4a-119">An index contains keys built from one or more columns in the table or view.</span></span> <span data-ttu-id="20e4a-120">Эти ключи хранятся в виде структуры сбалансированного дерева, которая поддерживает быстрый поиск строк по их ключевым значениям в SQL Server.</span><span class="sxs-lookup"><span data-stu-id="20e4a-120">These keys are stored in a structure (B-tree) that enables SQL Server to find the row or rows associated with the key values quickly and efficiently.</span></span>  
  
 <span data-ttu-id="20e4a-121">Выбор правильных индексов для базы данных и ее рабочей нагрузки — это решение сложной задачи о соотношении скорости обработки запроса и стоимости обновления.</span><span class="sxs-lookup"><span data-stu-id="20e4a-121">The selection of the right indexes for a database and its workload is a complex balancing act between query speed and update cost.</span></span> <span data-ttu-id="20e4a-122">Узкие индексы, то есть индексы, в ключе которых мало столбцов, требуют меньше места на диске и меньше текущих издержек.</span><span class="sxs-lookup"><span data-stu-id="20e4a-122">Narrow indexes, or indexes with few columns in the index key, require less disk space and maintenance overhead.</span></span> <span data-ttu-id="20e4a-123">С другой стороны, широкие индексы охватывают больше запросов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-123">Wide indexes, on the other hand, cover more queries.</span></span> <span data-ttu-id="20e4a-124">Прежде чем удастся найти наиболее эффективный индекс, возможно, придется поэкспериментировать с несколькими различными вариантами.</span><span class="sxs-lookup"><span data-stu-id="20e4a-124">You may have to experiment with several different designs before finding the most efficient index.</span></span> <span data-ttu-id="20e4a-125">Добавление, изменение и удаление индексов не влияет на схему базы данных или конструкцию приложений.</span><span class="sxs-lookup"><span data-stu-id="20e4a-125">Indexes can be added, modified, and dropped without affecting the database schema or application design.</span></span> <span data-ttu-id="20e4a-126">Следовательно, эксперименты с различными индексами можно проводить без каких-либо опасений.</span><span class="sxs-lookup"><span data-stu-id="20e4a-126">Therefore, you should not hesitate to experiment with different indexes.</span></span>  
  
 <span data-ttu-id="20e4a-127">Оптимизатор запросов в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] с большой вероятностью выбирает наилучший индекс в подавляющем большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="20e4a-127">The query optimizer in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] reliably chooses the most effective index in the vast majority of cases.</span></span> <span data-ttu-id="20e4a-128">Общая стратегия разработки индексов должна давать оптимизатору запросов по возможности разнообразные варианты, чтобы ему было из чего выбирать. Следует довериться его решению.</span><span class="sxs-lookup"><span data-stu-id="20e4a-128">Your overall index design strategy should provide a variety of indexes for the query optimizer to choose from and trust it to make the right decision.</span></span> <span data-ttu-id="20e4a-129">Это уменьшит время анализа и обеспечит высокую производительность в различных ситуациях.</span><span class="sxs-lookup"><span data-stu-id="20e4a-129">This reduces analysis time and produces good performance over a variety of situations.</span></span> <span data-ttu-id="20e4a-130">Чтобы выяснить, какие индексы оптимизатор запросов использует для отдельных запросов, в меню **Запрос** среды [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] выберите **Включить действительный план выполнения**.</span><span class="sxs-lookup"><span data-stu-id="20e4a-130">To see which indexes the query optimizer uses for a specific query, in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], on the **Query** menu, select **Include Actual Execution Plan**.</span></span>  
  
 <span data-ttu-id="20e4a-131">Использование индекса не всегда означает высокую производительность, а высокая производительность не всегда означает эффективное использование индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-131">Do not always equate index usage with good performance, and good performance with efficient index use.</span></span> <span data-ttu-id="20e4a-132">Если бы использование индекса всегда способствовало производительности, то работа оптимизатора запросов была бы очень простой.</span><span class="sxs-lookup"><span data-stu-id="20e4a-132">If using an index always helped produce the best performance, the job of the query optimizer would be simple.</span></span> <span data-ttu-id="20e4a-133">На самом деле, неверный выбор индекса может привести к неоптимальной производительности.</span><span class="sxs-lookup"><span data-stu-id="20e4a-133">In reality, an incorrect index choice can cause less than optimal performance.</span></span> <span data-ttu-id="20e4a-134">Следовательно, задача оптимизатора запросов состоит в том, чтобы выбрать индекс или комбинацию индексов, если это улучшит производительность, и избежать индексированного поиска, если это ее понизит.</span><span class="sxs-lookup"><span data-stu-id="20e4a-134">Therefore, the task of the query optimizer is to select an index, or combination of indexes, only when it will improve performance, and to avoid indexed retrieval when it will hinder performance.</span></span>  
  
### <a name="index-design-tasks"></a><span data-ttu-id="20e4a-135">Задачи проектирования индексов</span><span class="sxs-lookup"><span data-stu-id="20e4a-135">Index Design Tasks</span></span>  

 <span data-ttu-id="20e4a-136">Рекомендуемая стратегия проектирования индексов включает в себя следующие задачи:</span><span class="sxs-lookup"><span data-stu-id="20e4a-136">The follow tasks make up our recommended strategy for designing indexes:</span></span>  
  
1.  <span data-ttu-id="20e4a-137">Прежде всего следует понять характеристики самой базы данных.</span><span class="sxs-lookup"><span data-stu-id="20e4a-137">Understand the characteristics of the database itself.</span></span> <span data-ttu-id="20e4a-138">Например, будет ли это база данных оперативной обработки транзакций (OLTP) с часто изменяющимися данными, или система поддержки решений (DDS), или хранилище данных (OLAP), предназначенное в основном для чтения, которое должно быстро обрабатывать большие объемы данных.</span><span class="sxs-lookup"><span data-stu-id="20e4a-138">For example, is it an online transaction processing (OLTP) database with frequent data modifications, or a Decision Support System (DSS) or data warehousing (OLAP) database that contains primarily read-only data and must process very large data sets quickly.</span></span> <span data-ttu-id="20e4a-139">В [!INCLUDE[ssSQL11](../includes/sssql11-md.md)]индексы *columnstore, оптимизированные для памяти xVelocity* особенно хорошо подходят для стандартных наборов данных хранилищ данных.</span><span class="sxs-lookup"><span data-stu-id="20e4a-139">In [!INCLUDE[ssSQL11](../includes/sssql11-md.md)], *xVelocity memory optimized columnstore* index is especially appropriate for typical data warehousing data sets.</span></span> <span data-ttu-id="20e4a-140">Индексы columnstore могут изменить работу пользователей с хранилищем данных, обеспечивая более высокую производительность для таких стандартных запросов хранилища данных, как фильтрация, статистическая обработка, группирование и запросы соединения типа «звезда».</span><span class="sxs-lookup"><span data-stu-id="20e4a-140">Columnstore indexes can transform the data warehousing experience for users by enabling faster performance for common data warehousing queries such as filtering, aggregating, grouping, and star-join queries.</span></span> <span data-ttu-id="20e4a-141">Дополнительные сведения см. в разделе [Описание индексов columnstore](../relational-databases/indexes/columnstore-indexes-described.md).</span><span class="sxs-lookup"><span data-stu-id="20e4a-141">For more information, see [Columnstore Indexes Described](../relational-databases/indexes/columnstore-indexes-described.md).</span></span>  
  
2.  <span data-ttu-id="20e4a-142">Определите наиболее часто используемые запросы.</span><span class="sxs-lookup"><span data-stu-id="20e4a-142">Understand the characteristics of the most frequently used queries.</span></span> <span data-ttu-id="20e4a-143">Например, если известно, что часто используется запрос на соединение двух и более таблиц, это поможет определить наилучший тип индексов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-143">For example, knowing that a frequently used query joins two or more tables will help you determine the best type of indexes to use.</span></span>  
  
3.  <span data-ttu-id="20e4a-144">Выясните характеристики столбцов, используемых в запросах.</span><span class="sxs-lookup"><span data-stu-id="20e4a-144">Understand the characteristics of the columns used in the queries.</span></span> <span data-ttu-id="20e4a-145">Например, идеальным будет индекс для столбцов с типом данных integer, которые к тому же имеют уникальные или отличные от NULL значения.</span><span class="sxs-lookup"><span data-stu-id="20e4a-145">For example, an index is ideal for columns that have an integer data type and are also unique or nonnull columns.</span></span> <span data-ttu-id="20e4a-146">Для столбцов с хорошо определенными подмножествами данных в [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] и более поздних версиях можно использовать отфильтрованный индекс.</span><span class="sxs-lookup"><span data-stu-id="20e4a-146">For columns that have well-defined subsets of data, you can use a filtered index in [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] and higher versions.</span></span> <span data-ttu-id="20e4a-147">Дополнительные сведения см. в разделе [Рекомендации по проектированию отфильтрованных индексов](#Filtered) этого руководства.</span><span class="sxs-lookup"><span data-stu-id="20e4a-147">For more information, see [Filtered Index Design Guidelines](#Filtered) in this guide.</span></span>  
  
4.  <span data-ttu-id="20e4a-148">Определите, какие параметры индексов могут повысить производительность при создании индекса или при его поддержке.</span><span class="sxs-lookup"><span data-stu-id="20e4a-148">Determine which index options might enhance performance when the index is created or maintained.</span></span> <span data-ttu-id="20e4a-149">Например, при создании кластеризованного индекса для существующей большой таблицы очень выгодно будет использовать параметр ONLINE.</span><span class="sxs-lookup"><span data-stu-id="20e4a-149">For example, creating a clustered index on an existing large table would benefit from the ONLINE index option.</span></span> <span data-ttu-id="20e4a-150">Параметр ONLINE позволяет продолжать параллельную обработку базовых данных во время создания или повторного построения индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-150">The ONLINE option allows for concurrent activity on the underlying data to continue while the index is being created or rebuilt.</span></span> <span data-ttu-id="20e4a-151">Дополнительные сведения см. в разделе [Установка параметров индекса](../relational-databases/indexes/set-index-options.md).</span><span class="sxs-lookup"><span data-stu-id="20e4a-151">For more information, see [Set Index Options](../relational-databases/indexes/set-index-options.md).</span></span>  
  
5.  <span data-ttu-id="20e4a-152">Определите оптимальное расположение для хранения индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-152">Determine the optimal storage location for the index.</span></span> <span data-ttu-id="20e4a-153">Некластеризованный индекс может храниться в той же файловой группе, что и базовая таблица, или в другой группе.</span><span class="sxs-lookup"><span data-stu-id="20e4a-153">A nonclustered index can be stored in the same filegroup as the underlying table, or on a different filegroup.</span></span> <span data-ttu-id="20e4a-154">Правильный выбор расположения для хранения индексов может повысить производительность запросов за счет повышения скорости дискового ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="20e4a-154">The storage location of indexes can improve query performance by increasing disk I/O performance.</span></span> <span data-ttu-id="20e4a-155">Например, если некластеризованный индекс хранится в файловой группе не на том диске, на котором расположены файловые группы таблицы, то производительность может повыситься, поскольку это позволяет одновременно обращаться к нескольким дискам.</span><span class="sxs-lookup"><span data-stu-id="20e4a-155">For example, storing a nonclustered index on a filegroup that is on a different disk than the table filegroup can improve performance because multiple disks can be read at the same time.</span></span>  
  
     <span data-ttu-id="20e4a-156">Кластеризованные и некластеризованные индексы могут использовать схему секционирования, которая охватывает несколько файловых групп.</span><span class="sxs-lookup"><span data-stu-id="20e4a-156">Alternatively, clustered and nonclustered indexes can use a partition scheme across multiple filegroups.</span></span> <span data-ttu-id="20e4a-157">Секционирование делает большие таблицы и индексы более управляемыми, позволяет быстро и эффективно получать доступ к наборам данных и управлять ими, при этом сохраняя целостность всей коллекции.</span><span class="sxs-lookup"><span data-stu-id="20e4a-157">Partitioning makes large tables or indexes more manageable by letting you access or manage subsets of data quickly and efficiently, while maintaining the integrity of the overall collection.</span></span> <span data-ttu-id="20e4a-158">Дополнительные сведения см. в разделе [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span><span class="sxs-lookup"><span data-stu-id="20e4a-158">For more information, see [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span></span> <span data-ttu-id="20e4a-159">При выборе секционирования определите, требуется ли выравнивание индекса, то есть должен ли индекс быть секционирован точно так же, как и таблицы, или он может быть секционирован иным образом.</span><span class="sxs-lookup"><span data-stu-id="20e4a-159">When you consider partitioning, determine whether the index should be aligned, that is, partitioned in essentially the same manner as the table, or partitioned independently.</span></span>  
  
##  <a name="general-index-design-guidelines"></a><a name="General_Design"></a> <span data-ttu-id="20e4a-160">Общие рекомендации по проектированию индексов</span><span class="sxs-lookup"><span data-stu-id="20e4a-160">General Index Design Guidelines</span></span>  

 <span data-ttu-id="20e4a-161">Опытный администратор базы данных может спроектировать хороший набор индексов, но эта задача очень сложна, требует много времени и сопряжена с ошибками даже для рабочих нагрузок и баз данных средней сложности.</span><span class="sxs-lookup"><span data-stu-id="20e4a-161">Experienced database administrators can design a good set of indexes, but this task is very complex, time-consuming, and error-prone even for moderately complex databases and workloads.</span></span> <span data-ttu-id="20e4a-162">В разработке оптимальных индексов может помочь понимание характеристик базы данных, запросов и столбцов данных.</span><span class="sxs-lookup"><span data-stu-id="20e4a-162">Understanding the characteristics of your database, queries, and data columns can help you design optimal indexes.</span></span>  
  
### <a name="database-considerations"></a><span data-ttu-id="20e4a-163">Соображения, связанные с базами данных</span><span class="sxs-lookup"><span data-stu-id="20e4a-163">Database Considerations</span></span>  

 <span data-ttu-id="20e4a-164">При проектировании индекса следует учитывать следующие рекомендации:</span><span class="sxs-lookup"><span data-stu-id="20e4a-164">When you design an index, consider the following database guidelines:</span></span>  
  
-   <span data-ttu-id="20e4a-165">Большое количество индексов в таблице снижает производительность инструкций INSERT, UPDATE, DELETE и MERGE, потому что при изменении данных в таблице все индексы должны быть соответствующим образом изменены.</span><span class="sxs-lookup"><span data-stu-id="20e4a-165">Large numbers of indexes on a table affect the performance of INSERT, UPDATE, DELETE, and MERGE statements because all indexes must be adjusted appropriately as data in the table changes.</span></span> <span data-ttu-id="20e4a-166">Например, если столбец используется в нескольких индексах и выполняется инструкция UPDATE, которая изменяет данные из этого столбца, каждый индекс, содержащий этот столбец, должен быть обновлен, как и столбец в базовой таблице (куча или кластеризованный индекс).</span><span class="sxs-lookup"><span data-stu-id="20e4a-166">For example, if a column is used in several indexes and you execute an UPDATE statement that modifies that column's data, each index that contains that column must be updated as well as the column in the underlying base table (heap or clustered index).</span></span>  
  
    -   <span data-ttu-id="20e4a-167">Избегайте использования чрезмерного количества индексов для интенсивно обновляемых таблиц и следите, чтобы индексы были узкими, то есть содержали как можно меньше столбцов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-167">Avoid over-indexing heavily updated tables and keep indexes narrow, that is, with as few columns as possible.</span></span>  
  
    -   <span data-ttu-id="20e4a-168">Используйте большое количество индексов, чтобы улучшить производительность запросов для таблиц с низкими требованиями к обновлениям, но большими объемами данных.</span><span class="sxs-lookup"><span data-stu-id="20e4a-168">Use many indexes to improve query performance on tables with low update requirements, but large volumes of data.</span></span> <span data-ttu-id="20e4a-169">Большое число индексов может повысить производительность запросов, которые не изменяют данных, таких как инструкции SELECT, поскольку у оптимизатора запросов будет больший выбор индексов при определении самого быстрого способа доступа.</span><span class="sxs-lookup"><span data-stu-id="20e4a-169">Large numbers of indexes can help the performance of queries that do not modify data, such as SELECT statements, because the query optimizer has more indexes to choose from to determine the fastest access method.</span></span>  
  
-   <span data-ttu-id="20e4a-170">Индексирование маленьких таблиц может оказаться не лучшим выбором, так как поиск данных в индексе может потребовать у оптимизатора запросов больше времени, чем простой просмотр таблицы.</span><span class="sxs-lookup"><span data-stu-id="20e4a-170">Indexing small tables may not be optimal because it can take the query optimizer longer to traverse the index searching for data than to perform a simple table scan.</span></span> <span data-ttu-id="20e4a-171">Следовательно, для маленьких таблиц индексы могут вообще не использоваться, но тем не менее их необходимо поддерживать при изменении данных в таблице.</span><span class="sxs-lookup"><span data-stu-id="20e4a-171">Therefore, indexes on small tables might never be used, but must still be maintained as data in the table changes.</span></span>  
  
-   <span data-ttu-id="20e4a-172">Индексы представлений могут дать значительное улучшение производительности, если представление содержит агрегаты, соединения таблиц или сочетание того и другого.</span><span class="sxs-lookup"><span data-stu-id="20e4a-172">Indexes on views can provide significant performance gains when the view contains aggregations, table joins, or a combination of aggregations and joins.</span></span> <span data-ttu-id="20e4a-173">Необязательно явно ссылаться в запросе на представление, чтобы его мог использовать оптимизатор запросов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-173">The view does not have to be explicitly referenced in the query for the query optimizer to use it.</span></span>  
  
-   <span data-ttu-id="20e4a-174">Для анализа базы данных и получения рекомендаций по созданию индексов следует использовать помощник по настройке ядра СУБД.</span><span class="sxs-lookup"><span data-stu-id="20e4a-174">Use the Database Engine Tuning Advisor to analyze your database and make index recommendations.</span></span> <span data-ttu-id="20e4a-175">Дополнительные сведения см. в разделе [Database Engine Tuning Advisor](../relational-databases/performance/database-engine-tuning-advisor.md).</span><span class="sxs-lookup"><span data-stu-id="20e4a-175">For more information, see [Database Engine Tuning Advisor](../relational-databases/performance/database-engine-tuning-advisor.md).</span></span>  
  
### <a name="query-considerations"></a><span data-ttu-id="20e4a-176">Вопросы работы с запросами</span><span class="sxs-lookup"><span data-stu-id="20e4a-176">Query Considerations</span></span>  

 <span data-ttu-id="20e4a-177">При проектировании индекса следует принимать во внимание следующие рекомендации, связанные с обработкой запросов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-177">When you design an index, consider the following query guidelines:</span></span>  
  
-   <span data-ttu-id="20e4a-178">Следует создавать некластеризованные индексы для столбцов, которые часто используются в предикатах и условиях соединения в запросах.</span><span class="sxs-lookup"><span data-stu-id="20e4a-178">Create nonclustered indexes on the columns that are frequently used in predicates and join conditions in queries.</span></span> <span data-ttu-id="20e4a-179">Однако следует избегать добавления столбцов без необходимости.</span><span class="sxs-lookup"><span data-stu-id="20e4a-179">However, you should avoid adding unnecessary columns.</span></span> <span data-ttu-id="20e4a-180">Добавление слишком большого числа индексных столбцов может отрицательно повлиять на количество свободного места на диске и на производительность поддержания индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-180">Adding too many index columns can adversely affect disk space and index maintenance performance.</span></span>  
  
-   <span data-ttu-id="20e4a-181">Покрывающие индексы могут повысить производительность запросов, так как данные, необходимые для удовлетворения требований запроса, присутствуют в самом индексе.</span><span class="sxs-lookup"><span data-stu-id="20e4a-181">Covering indexes can improve query performance because all the data needed to meet the requirements of the query exists within the index itself.</span></span> <span data-ttu-id="20e4a-182">Таким образом, для получения запрашиваемых данных требуются только страницы индекса, а не страницы данных таблицы или кластеризованного индекса. Следовательно, уменьшается общий объем операций дискового ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="20e4a-182">That is, only the index pages, and not the data pages of the table or clustered index, are required to retrieve the requested data; therefore, reducing overall disk I/O.</span></span> <span data-ttu-id="20e4a-183">Например, запрос по столбцам **a** и **b** таблицы, у которой есть составной индекс, созданный на основе столбцов **a**, **b**и **c** , может найти нужные данные, пользуясь только этим индексом.</span><span class="sxs-lookup"><span data-stu-id="20e4a-183">For example, a query of columns **a** and **b** on a table that has a composite index created on columns **a**, **b**, and **c** can retrieve the specified data from the index alone.</span></span>  
  
-   <span data-ttu-id="20e4a-184">Запросы следует составлять так, чтобы они вставляли или изменяли как можно больше строк одной инструкцией, вместо того, чтобы использовать для обновления тех же строк нескольких запросов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-184">Write queries that insert or modify as many rows as possible in a single statement, instead of using multiple queries to update the same rows.</span></span> <span data-ttu-id="20e4a-185">Используя только одну инструкцию, можно воспользоваться возможностями, которые обеспечивает поддержание оптимизированного индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-185">By using only one statement, optimized index maintenance could be exploited.</span></span>  
  
-   <span data-ttu-id="20e4a-186">Определите тип запроса и то, как в нем используются столбцы.</span><span class="sxs-lookup"><span data-stu-id="20e4a-186">Evaluate the query type and how columns are used in the query.</span></span> <span data-ttu-id="20e4a-187">Например: столбец, который используется в запросе с точным соответствием, может оказаться подходящим кандидатом для создания кластеризованного или некластеризованного индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-187">For example, a column used in an exact-match query type would be a good candidate for a nonclustered or clustered index.</span></span>  
  
### <a name="column-considerations"></a><span data-ttu-id="20e4a-188">Вопросы работы со столбцами</span><span class="sxs-lookup"><span data-stu-id="20e4a-188">Column Considerations</span></span>  

 <span data-ttu-id="20e4a-189">При проектировании индекса, следует принимать во внимание следующие рекомендации, относящиеся к столбцам.</span><span class="sxs-lookup"><span data-stu-id="20e4a-189">When you design an index consider the following column guidelines:</span></span>  
  
-   <span data-ttu-id="20e4a-190">Нужно следить, чтобы длина ключа для кластеризованных индексов была небольшой.</span><span class="sxs-lookup"><span data-stu-id="20e4a-190">Keep the length of the index key short for clustered indexes.</span></span> <span data-ttu-id="20e4a-191">Кроме того, кластеризованные индексы только выиграют при создании на основе уникальных или не принимающих значения NULL столбцах.</span><span class="sxs-lookup"><span data-stu-id="20e4a-191">Additionally, clustered indexes benefit from being created on unique or nonnull columns.</span></span>  
  
-   <span data-ttu-id="20e4a-192">Столбцы типа `ntext`, `text`, `image`, `varchar(max)`, `nvarchar(max)` и `varbinary(max)` нельзя указывать в качестве ключевых столбцов индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-192">Columns that are of the `ntext`, `text`, `image`, `varchar(max)`, `nvarchar(max)`, and `varbinary(max)` data types cannot be specified as index key columns.</span></span> <span data-ttu-id="20e4a-193">Однако типы данных `varchar(max)`, `nvarchar(max)`, `varbinary(max)` и `xml` могут участвовать в некластеризованных индексах в качестве их неключевых индексных столбцов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-193">However, `varchar(max)`, `nvarchar(max)`, `varbinary(max)`, and `xml` data types can participate in a nonclustered index as nonkey index columns.</span></span> <span data-ttu-id="20e4a-194">Дополнительные сведения см. в разделе [Индекс с включенными столбцами](#Included_Columns)этого руководства.</span><span class="sxs-lookup"><span data-stu-id="20e4a-194">For more information, see the section ['Index with Included Columns](#Included_Columns)' in this guide.</span></span>  
  
-   <span data-ttu-id="20e4a-195">Столбцы типа `xml` могут быть ключевым столбцом только в XML-индексе.</span><span class="sxs-lookup"><span data-stu-id="20e4a-195">An `xml` data type can only be a key column only in an XML index.</span></span> <span data-ttu-id="20e4a-196">Дополнительные сведения см в разделе [XML-индексы (SQL Server)](../relational-databases/xml/xml-indexes-sql-server.md).</span><span class="sxs-lookup"><span data-stu-id="20e4a-196">For more information, see [XML Indexes &#40;SQL Server&#41;](../relational-databases/xml/xml-indexes-sql-server.md).</span></span> <span data-ttu-id="20e4a-197">С пакетом обновления 1 (SP1) в SQL Server 2012 появился новый тип XML-индекса — выборочный XML-индекс.</span><span class="sxs-lookup"><span data-stu-id="20e4a-197">SQL Server 2012 SP1 introduces a new type of XML index known as a Selective XML Index.</span></span> <span data-ttu-id="20e4a-198">Этот новый индекс повышает производительность запросов для данных, хранимых в виде XML на SQL Server, и тем самым значительно ускоряет индексирование рабочих нагрузок XML-данных большого объема и повышает масштабируемость за счет уменьшения места хранения самого индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-198">This new index can improve querying performance over data stored as XML in SQL Server, allow for much faster indexing of large XML data workloads, and improve scalability by reducing storage costs of the index itself.</span></span> <span data-ttu-id="20e4a-199">Дополнительные сведения см. в разделе [Выборочный XML-индекс (SXI)](../relational-databases/xml/selective-xml-indexes-sxi.md).</span><span class="sxs-lookup"><span data-stu-id="20e4a-199">For more information, see [Selective XML Indexes &#40;SXI&#41;](../relational-databases/xml/selective-xml-indexes-sxi.md).</span></span>  
  
-   <span data-ttu-id="20e4a-200">Проверьте уникальность столбцов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-200">Examine column uniqueness.</span></span> <span data-ttu-id="20e4a-201">Замена неуникального индекса уникальным для той же комбинации столбцов обеспечивает оптимизатору запросов дополнительные сведения, что делает индекс более полезным.</span><span class="sxs-lookup"><span data-stu-id="20e4a-201">A unique index instead of a nonunique index on the same combination of columns provides additional information for the query optimizer that makes the index more useful.</span></span> <span data-ttu-id="20e4a-202">Дополнительные сведения см. в разделе [Правила по созданию уникальных индексов](#Unique) этого руководства.</span><span class="sxs-lookup"><span data-stu-id="20e4a-202">For more information, see [Unique Index Design Guidelines](#Unique) in this guide.</span></span>  
  
-   <span data-ttu-id="20e4a-203">Проверьте распределение данных в столбце.</span><span class="sxs-lookup"><span data-stu-id="20e4a-203">Examine data distribution in the column.</span></span> <span data-ttu-id="20e4a-204">Часто длительное выполнение запроса обусловлено индексированием столбца, в котором мало уникальных значений, или присоединением такого столбца.</span><span class="sxs-lookup"><span data-stu-id="20e4a-204">Frequently, a long-running query is caused by indexing a column with few unique values, or by performing a join on such a column.</span></span> <span data-ttu-id="20e4a-205">Это фундаментальная проблема, связанная с данными и запросом, и обычно она не может быть решена без определения ситуации.</span><span class="sxs-lookup"><span data-stu-id="20e4a-205">This is a fundamental problem with the data and query, and generally cannot be resolved without identifying this situation.</span></span> <span data-ttu-id="20e4a-206">Например: физический телефонный справочник, отсортированный в алфавитном порядке по фамилии, не сможет быстро найти человека, если всех жителей города зовут Смит или Джонс.</span><span class="sxs-lookup"><span data-stu-id="20e4a-206">For example, a physical telephone directory sorted alphabetically on last name will not expedite locating a person if all people in the city are named Smith or Jones.</span></span> <span data-ttu-id="20e4a-207">Дополнительные сведения о распределении данных см. в разделе [Statistics](../relational-databases/statistics/statistics.md).</span><span class="sxs-lookup"><span data-stu-id="20e4a-207">For more information about data distribution, see [Statistics](../relational-databases/statistics/statistics.md).</span></span>  
  
-   <span data-ttu-id="20e4a-208">Попробуйте применить отфильтрованные индексы для столбцов, имеющих точно определенные подмножества, например разреженных столбцов, столбцов, содержащих в основном значения NULL, столбцов с разнородными категориями значений и столбцов с различными диапазонами значений.</span><span class="sxs-lookup"><span data-stu-id="20e4a-208">Consider using filtered indexes on columns that have well-defined subsets, for example sparse columns, columns with mostly NULL values, columns with categories of values, and columns with distinct ranges of values.</span></span> <span data-ttu-id="20e4a-209">Правильно составленный отфильтрованный индекс может увеличить скорость выполнения запроса, уменьшить стоимость обслуживания индекса и стоимость хранения.</span><span class="sxs-lookup"><span data-stu-id="20e4a-209">A well-designed filtered index can improve query performance, reduce index maintenance costs, and reduce storage costs.</span></span>  
  
-   <span data-ttu-id="20e4a-210">Следует учитывать порядок столбцов, если индекс будет включать их несколько.</span><span class="sxs-lookup"><span data-stu-id="20e4a-210">Consider the order of the columns if the index will contain multiple columns.</span></span> <span data-ttu-id="20e4a-211">Столбец, использованный в предложении WHERE в условии поиска равных (=), больших (>), меньших (<) или находящихся в интервале (BETWEEN) значений или участвующий в соединении, должен стоять первым.</span><span class="sxs-lookup"><span data-stu-id="20e4a-211">The column that is used in the WHERE clause in an equal to (=), greater than (>), less than (<), or BETWEEN search condition, or participates in a join, should be placed first.</span></span> <span data-ttu-id="20e4a-212">Дополнительные столбцы должны быть упорядочены по уровню различимости, то есть от наиболее четкого к наименее четкому.</span><span class="sxs-lookup"><span data-stu-id="20e4a-212">Additional columns should be ordered based on their level of distinctness, that is, from the most distinct to the least distinct.</span></span>  
  
     <span data-ttu-id="20e4a-213">Например, если индекс определен как `LastName`, `FirstName` , индекс будет полезным, если критерий поиска — `WHERE LastName = 'Smith'` или `WHERE LastName = Smith AND FirstName LIKE 'J%'`.</span><span class="sxs-lookup"><span data-stu-id="20e4a-213">For example, if the index is defined as `LastName`, `FirstName` the index will be useful when the search criterion is `WHERE LastName = 'Smith'` or `WHERE LastName = Smith AND FirstName LIKE 'J%'`.</span></span> <span data-ttu-id="20e4a-214">Однако оптимизатор запросов не станет использовать этот индекс для запроса только по критерию `FirstName (WHERE FirstName = 'Jane')`.</span><span class="sxs-lookup"><span data-stu-id="20e4a-214">However, the query optimizer would not use the index for a query that searched only on `FirstName (WHERE FirstName = 'Jane')`.</span></span>  
  
-   <span data-ttu-id="20e4a-215">Следует рассмотреть возможность индексирования вычисляемых столбцов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-215">Consider indexing computed columns.</span></span> <span data-ttu-id="20e4a-216">Дополнительные сведения см. в разделе [Индексы вычисляемых столбцов](../relational-databases/indexes/indexes-on-computed-columns.md).</span><span class="sxs-lookup"><span data-stu-id="20e4a-216">For more information, see [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md).</span></span>  
  
### <a name="index-characteristics"></a><span data-ttu-id="20e4a-217">Характеристики индекса</span><span class="sxs-lookup"><span data-stu-id="20e4a-217">Index Characteristics</span></span>  

 <span data-ttu-id="20e4a-218">После того, как определено, что индекс соответствует запросу, можно выбрать наилучший тип индекса для конкретной ситуации.</span><span class="sxs-lookup"><span data-stu-id="20e4a-218">After you have determined that an index is appropriate for a query, you can select the type of index that best fits your situation.</span></span> <span data-ttu-id="20e4a-219">Ниже представлены характеристики индекса:</span><span class="sxs-lookup"><span data-stu-id="20e4a-219">Index characteristics include the following:</span></span>  
  
-   <span data-ttu-id="20e4a-220">кластеризованный или некластеризованный;</span><span class="sxs-lookup"><span data-stu-id="20e4a-220">Clustered versus nonclustered</span></span>  
  
-   <span data-ttu-id="20e4a-221">уникальный или неуникальный;</span><span class="sxs-lookup"><span data-stu-id="20e4a-221">Unique versus nonunique</span></span>  
  
-   <span data-ttu-id="20e4a-222">с одним или несколькими столбцами;</span><span class="sxs-lookup"><span data-stu-id="20e4a-222">Single column versus multicolumn</span></span>  
  
-   <span data-ttu-id="20e4a-223">порядок по возрастанию или по убыванию в столбцах индекса;</span><span class="sxs-lookup"><span data-stu-id="20e4a-223">Ascending or descending order on the columns in the index</span></span>  
  
-   <span data-ttu-id="20e4a-224">полнотабличные или фильтруемые некластеризованные индексы.</span><span class="sxs-lookup"><span data-stu-id="20e4a-224">Full-table versus filtered for nonclustered indexes</span></span>  
  
 <span data-ttu-id="20e4a-225">Также можно задать начальные характеристики хранилища индекса, чтобы оптимизировать его производительность или поддержание, задав такие параметры, как FILLFACTOR.</span><span class="sxs-lookup"><span data-stu-id="20e4a-225">You can also customize the initial storage characteristics of the index to optimize its performance or maintenance by setting an option such as FILLFACTOR.</span></span> <span data-ttu-id="20e4a-226">Чтобы оптимизировать производительность, можно также определить место хранения индекса с помощью файловых групп или схем секционирования.</span><span class="sxs-lookup"><span data-stu-id="20e4a-226">Also, you can determine the index storage location by using filegroups or partition schemes to optimize performance.</span></span>  
  
###  <a name="index-placement-on-filegroups-or-partitions-schemes"></a><a name="Index_placement"></a> <span data-ttu-id="20e4a-227">Размещение индекса в файловых группах или схемах секций</span><span class="sxs-lookup"><span data-stu-id="20e4a-227">Index Placement on Filegroups or Partitions Schemes</span></span>  

 <span data-ttu-id="20e4a-228">Во время разработки стратегии индексирования следует обратить внимание на помещение индексов в файловые группы, связанные с базой данных.</span><span class="sxs-lookup"><span data-stu-id="20e4a-228">As you develop your index design strategy, you should consider the placement of the indexes on the filegroups associated with the database.</span></span> <span data-ttu-id="20e4a-229">Аккуратный выбор схемы файловой группы или секционирования может улучшить производительность.</span><span class="sxs-lookup"><span data-stu-id="20e4a-229">Careful selection of the filegroup or partition scheme can improve query performance.</span></span>  
  
 <span data-ttu-id="20e4a-230">По умолчанию индексы хранятся в той же файловой группе, что и базовая таблица, для которой создается индекс.</span><span class="sxs-lookup"><span data-stu-id="20e4a-230">By default, indexes are stored in the same filegroup as the base table on which the index is created.</span></span> <span data-ttu-id="20e4a-231">Несекционированный некластеризованный индекс и базовая таблица всегда находятся в одной файловой группе.</span><span class="sxs-lookup"><span data-stu-id="20e4a-231">A nonpartitioned clustered index and the base table always reside in the same filegroup.</span></span> <span data-ttu-id="20e4a-232">Однако можно сделать следующее.</span><span class="sxs-lookup"><span data-stu-id="20e4a-232">However, you can do the following:</span></span>  
  
-   <span data-ttu-id="20e4a-233">Создайте некластеризованные индексы в файловой группе, отличной от файловой группы базовой таблицы или кластеризованного индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-233">Create nonclustered indexes on a filegroup other than the filegroup of the base table or clustered index.</span></span>  
  
-   <span data-ttu-id="20e4a-234">Секционировать кластеризованные и некластеризованные индексы, чтобы они размещались в нескольких файловых группах.</span><span class="sxs-lookup"><span data-stu-id="20e4a-234">Partition clustered and nonclustered indexes to span multiple filegroups.</span></span>  
  
-   <span data-ttu-id="20e4a-235">Переместить таблицу из одной файловой группы в другую, удалив кластеризованный индекс и указав новую файловую группу или схему секционирования в предложении MOVE TO инструкции DROP INDEX или выполнив инструкцию CREATE INDEX с предложением DROP_EXISTING.</span><span class="sxs-lookup"><span data-stu-id="20e4a-235">Move a table from one filegroup to another by dropping the clustered index and specifying a new filegroup or partition scheme in the MOVE TO clause of the DROP INDEX statement or by using the CREATE INDEX statement with the DROP_EXISTING clause.</span></span>  
  
 <span data-ttu-id="20e4a-236">Создав некластеризованный индекс в другой файловой группе, можно достичь прироста производительности, если файловые группы находятся на разных физических дисках с собственными контроллерами.</span><span class="sxs-lookup"><span data-stu-id="20e4a-236">By creating the nonclustered index on a different filegroup, you can achieve performance gains if the filegroups are using different physical drives with their own controllers.</span></span> <span data-ttu-id="20e4a-237">Сведения о данных и индексе могут считываться параллельно несколькими головками.</span><span class="sxs-lookup"><span data-stu-id="20e4a-237">Data and index information can then be read in parallel by the multiple disk heads.</span></span> <span data-ttu-id="20e4a-238">Например, если таблица `Table_A` в файловой группе `f1` и индекс `Index_A` в файловой группе `f2` используются в одном и том же запросе, производительность увеличится, так как обе файловые группы используются полностью, не состязаясь между собой.</span><span class="sxs-lookup"><span data-stu-id="20e4a-238">For example, if `Table_A` on filegroup `f1` and `Index_A` on filegroup `f2` are both being used by the same query, performance gains can be achieved because both filegroups are being fully used without contention.</span></span> <span data-ttu-id="20e4a-239">Однако если таблица `Table_A` сканируется запросом, а на индекс `Index_A` ссылки нет, то используется только файловая группа `f1` .</span><span class="sxs-lookup"><span data-stu-id="20e4a-239">However, if `Table_A` is scanned by the query but `Index_A` is not referenced, only filegroup `f1` is used.</span></span> <span data-ttu-id="20e4a-240">В этом случае нет никакого выигрыша в производительности.</span><span class="sxs-lookup"><span data-stu-id="20e4a-240">This creates no performance gain.</span></span>  
  
 <span data-ttu-id="20e4a-241">Поскольку тип и время необходимого доступа спрогнозировать невозможно, лучшим решением может оказаться распределение таблиц и индексов по всем файловым группам.</span><span class="sxs-lookup"><span data-stu-id="20e4a-241">Because you cannot predict what type of access will occur and when it will occur, it could be a better decision to spread your tables and indexes across all filegroups.</span></span> <span data-ttu-id="20e4a-242">Это гарантирует, что доступ будет осуществляться ко всем дискам, так как все данные и индексы равномерно распределены по ним, независимо от способа доступа к данным.</span><span class="sxs-lookup"><span data-stu-id="20e4a-242">This would guarantee that all disks are being accessed because all data and indexes are spread evenly across all disks, regardless of which way the data is accessed.</span></span> <span data-ttu-id="20e4a-243">Для системных администраторов этот подход также более прост.</span><span class="sxs-lookup"><span data-stu-id="20e4a-243">This is also a simpler approach for system administrators.</span></span>  
  
#### <a name="partitions-across-multiple-filegroups"></a><span data-ttu-id="20e4a-244">Секции во многих файловых группах</span><span class="sxs-lookup"><span data-stu-id="20e4a-244">Partitions Across Multiple Filegroups</span></span>  

 <span data-ttu-id="20e4a-245">Можно рассмотреть возможность секционирования кластеризованных и некластеризованных индексов по нескольким файловым группам.</span><span class="sxs-lookup"><span data-stu-id="20e4a-245">You can also consider partitioning clustered and nonclustered indexes across multiple filegroups.</span></span> <span data-ttu-id="20e4a-246">Секционированные индексы разбиваются горизонтально или построчно, в зависимости от функции секционирования.</span><span class="sxs-lookup"><span data-stu-id="20e4a-246">Partitioned indexes are partitioned horizontally, or by row, based on a partition function.</span></span> <span data-ttu-id="20e4a-247">Функция секционирования определяет, как каждая строка сопоставляется с набором секций на основе значений определенных столбцов — столбцов секционирования.</span><span class="sxs-lookup"><span data-stu-id="20e4a-247">The partition function defines how each row is mapped to a set of partitions based on the values of certain columns, called partitioning columns.</span></span> <span data-ttu-id="20e4a-248">Схема секционирования определяет сопоставление секций набору файловых групп.</span><span class="sxs-lookup"><span data-stu-id="20e4a-248">A partition scheme specifies the mapping of the partitions to a set of filegroups.</span></span>  
  
 <span data-ttu-id="20e4a-249">Секционирование индекса может предоставить следующие преимущества.</span><span class="sxs-lookup"><span data-stu-id="20e4a-249">Partitioning an index can provide the following benefits:</span></span>  
  
-   <span data-ttu-id="20e4a-250">Система становится более масштабируемой, а управление большими индексами в ней упрощается.</span><span class="sxs-lookup"><span data-stu-id="20e4a-250">Provide scalable systems that make large indexes more manageable.</span></span> <span data-ttu-id="20e4a-251">Например, в системах OLTP можно реализовать приложения, учитывающие секционирование и работающие с большими индексами.</span><span class="sxs-lookup"><span data-stu-id="20e4a-251">OLTP systems, for example, can implement partition-aware applications that deal with large indexes.</span></span>  
  
-   <span data-ttu-id="20e4a-252">Запросы выполняются быстрее и эффективнее.</span><span class="sxs-lookup"><span data-stu-id="20e4a-252">Make queries run faster and more efficiently.</span></span> <span data-ttu-id="20e4a-253">Когда запросы выполняются в нескольких секциях индекса, оптимизатор запросов может обрабатывать определенные секции в одно и то же время и исключать секции, к которым запрос не относится.</span><span class="sxs-lookup"><span data-stu-id="20e4a-253">When queries access several partitions of an index, the query optimizer can process individual partitions at the same time and exclude partitions that are not affected by the query.</span></span>  
  
 <span data-ttu-id="20e4a-254">Дополнительные сведения см. в разделе [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span><span class="sxs-lookup"><span data-stu-id="20e4a-254">For more information, see [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span></span>  
  
###  <a name="index-sort-order-design-guidelines"></a><a name="Sort_Order"></a> <span data-ttu-id="20e4a-255">Рекомендации по созданию порядка сортировки индексов</span><span class="sxs-lookup"><span data-stu-id="20e4a-255">Index Sort Order Design Guidelines</span></span>  

 <span data-ttu-id="20e4a-256">При определении индексов следует иметь в виду, что данные ключевых столбцов индекса сохраняются в порядке возрастания или убывания.</span><span class="sxs-lookup"><span data-stu-id="20e4a-256">When defining indexes, you should consider whether the data for the index key column should be stored in ascending or descending order.</span></span> <span data-ttu-id="20e4a-257">По умолчанию сортировка производится по возрастанию, как и в предыдущих версиях [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="20e4a-257">Ascending is the default and maintains compatibility with earlier versions of [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="20e4a-258">Синтаксис инструкций CREATE INDEX, CREATE TABLE и ALTER TABLE поддерживает ключевые слова ASC (по возрастанию) и DESC (по убыванию) для конкретных столбцов в индексах и ограничениях.</span><span class="sxs-lookup"><span data-stu-id="20e4a-258">The syntax of the CREATE INDEX, CREATE TABLE, and ALTER TABLE statements supports the keywords ASC (ascending) and DESC (descending) on individual columns in indexes and constraints.</span></span>  
  
 <span data-ttu-id="20e4a-259">Указание порядка, в котором значения ключей хранятся в индексе, полезно тогда, когда запрос ссылается на таблицу с предложением ORDER BY, в котором указано другое направление для ключевого столбца индекса или индексированного столбца.</span><span class="sxs-lookup"><span data-stu-id="20e4a-259">Specifying the order in which key values are stored in an index is useful when queries referencing the table have ORDER BY clauses that specify different directions for the key column or columns in that index.</span></span> <span data-ttu-id="20e4a-260">В этом случае индекс может исключить необходимость в операторе SORT в плане запроса, то есть запрос будет выполняться значительно эффективнее.</span><span class="sxs-lookup"><span data-stu-id="20e4a-260">In these cases, the index can remove the need for a SORT operator in the query plan; therefore, this makes the query more efficient.</span></span> <span data-ttu-id="20e4a-261">Например, покупателю в отделе заказов [!INCLUDE[ssSampleDBCoFull](../includes/sssampledbcofull-md.md)] необходимо определить качество товаров от разных поставщиков.</span><span class="sxs-lookup"><span data-stu-id="20e4a-261">For example, the buyers in the [!INCLUDE[ssSampleDBCoFull](../includes/sssampledbcofull-md.md)] purchasing department have to evaluate the quality of products they purchase from vendors.</span></span> <span data-ttu-id="20e4a-262">Больше всего его интересуют товары тех поставщиков, которые имеют набольшую частоту отказов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-262">The buyers are most interested in finding products sent by these vendors with a high rejection rate.</span></span> <span data-ttu-id="20e4a-263">Как показано в следующем запросе, получение данных по соответствию этому критерию требует, чтобы столбец `RejectedQty` в таблице `Purchasing.PurchaseOrderDetail` был отсортирован в порядке убывания (от большего значения к меньшему), а столбец `ProductID` — в порядке возрастания (от меньшего к большему).</span><span class="sxs-lookup"><span data-stu-id="20e4a-263">As shown in the following query, retrieving the data to meet this criteria requires the `RejectedQty` column in the `Purchasing.PurchaseOrderDetail` table to be sorted in descending order (large to small) and the `ProductID` column to be sorted in ascending order (small to large).</span></span>  
  
```sql
SELECT RejectedQty, ((RejectedQty/OrderQty)*100) AS RejectionRate,  
    ProductID, DueDate  
FROM Purchasing.PurchaseOrderDetail  
ORDER BY RejectedQty DESC, ProductID ASC;  
```  
  
 <span data-ttu-id="20e4a-264">Следующий план выполнения для этого запроса показывает, что оптимизатор запросов применяет оператор SORT для результирующего набора в порядке, указываемом предложением ORDER BY.</span><span class="sxs-lookup"><span data-stu-id="20e4a-264">The following execution plan for this query shows that the query optimizer used a SORT operator to return the result set in the order specified by the ORDER BY clause.</span></span>  
  
 <span data-ttu-id="20e4a-265">![План выполнения показывает, что используется оператор SORT.](media/indexsort1.gif "План выполнения показывает, что используется оператор SORT.")</span><span class="sxs-lookup"><span data-stu-id="20e4a-265">![Execution plan shows a SORT operator is used.](media/indexsort1.gif "Execution plan shows a SORT operator is used.")</span></span>  
  
 <span data-ttu-id="20e4a-266">Если создан индекс для ключевых столбцов, который соответствует индексу, указанному в предложении ORDER BY, оператор SORT может быть исключен из плана запроса, что значительно повысит его эффективность.</span><span class="sxs-lookup"><span data-stu-id="20e4a-266">If an index is created with key columns that match those in the ORDER BY clause in the query, the SORT operator can be eliminated in the query plan and the query plan is more efficient.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX IX_PurchaseOrderDetail_RejectedQty  
ON Purchasing.PurchaseOrderDetail  
    (RejectedQty DESC, ProductID ASC, DueDate, OrderQty);  
```  
  
 <span data-ttu-id="20e4a-267">После повторного выполнения запроса план выполнения показывает, что оператор SORT исключен и используется вновь созданный некластеризованный индекс.</span><span class="sxs-lookup"><span data-stu-id="20e4a-267">After the query is executed again, the following execution plan shows that the SORT operator has been eliminated and the newly created nonclustered index is used.</span></span>  
  
 <span data-ttu-id="20e4a-268">![План выполнения показывает, что оператор SORT не использовался](media/insertsort2.gif "План выполнения показывает, что оператор SORT не использовался")</span><span class="sxs-lookup"><span data-stu-id="20e4a-268">![Execution plan shows a SORT operator is not used](media/insertsort2.gif "Execution plan shows a SORT operator is not used")</span></span>  
  
 <span data-ttu-id="20e4a-269">[!INCLUDE[ssDE](../includes/ssde-md.md)] одинаково эффективно работает в обоих направлениях.</span><span class="sxs-lookup"><span data-stu-id="20e4a-269">The [!INCLUDE[ssDE](../includes/ssde-md.md)] can move equally efficiently in either direction.</span></span> <span data-ttu-id="20e4a-270">Индекс, определенный как `(RejectedQty DESC, ProductID ASC)` , может также быть использован в запросах с порядком сортировки, обратным порядку, определенному в предложении ORDER BY.</span><span class="sxs-lookup"><span data-stu-id="20e4a-270">An index defined as `(RejectedQty DESC, ProductID ASC)` can still be used for a query in which the sort direction of the columns in the ORDER BY clause are reversed.</span></span> <span data-ttu-id="20e4a-271">Например, запрос со следующим предложением ORDER BY-: `ORDER BY RejectedQty ASC, ProductID DESC` может воспользоваться этим индексом.</span><span class="sxs-lookup"><span data-stu-id="20e4a-271">For example, a query with the ORDER BY clause `ORDER BY RejectedQty ASC, ProductID DESC` can use the index.</span></span>  
  
 <span data-ttu-id="20e4a-272">Порядок сортировки может быть указан только для ключевых столбцов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-272">Sort order can be specified only for key columns.</span></span> <span data-ttu-id="20e4a-273">Представление каталога [sys.index_columns](/sql/relational-databases/system-catalog-views/sys-indexes-transact-sql) и функция INDEXKEY_PROPERTY помогут определить, в каком порядке хранится столбец индекса — возрастающем или убывающем.</span><span class="sxs-lookup"><span data-stu-id="20e4a-273">The [sys.index_columns](/sql/relational-databases/system-catalog-views/sys-indexes-transact-sql) catalog view and the INDEXKEY_PROPERTY function report whether an index column is stored in ascending or descending order.</span></span>  
  
 <span data-ttu-id="20e4a-274">![Значок стрелки, используемый в ссылке "назад на начало](media/uparrow16x16.gif "Значок стрелки, используемый со ссылкой В начало") " [в этом пошаговом окне](#Top)</span><span class="sxs-lookup"><span data-stu-id="20e4a-274">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="clustered-index-design-guidelines"></a><a name="Clustered"></a> <span data-ttu-id="20e4a-275">Правила проектирования кластеризованного индекса</span><span class="sxs-lookup"><span data-stu-id="20e4a-275">Clustered Index Design Guidelines</span></span>  

 <span data-ttu-id="20e4a-276">Кластеризованные индексы сортируют и хранят строки данных в таблице, основываясь на их ключевых значениях.</span><span class="sxs-lookup"><span data-stu-id="20e4a-276">Clustered indexes sort and store the data rows in the table based on their key values.</span></span> <span data-ttu-id="20e4a-277">Может быть только один кластеризованный индекс на таблицу, потому что сами строки данных могут быть отсортированы только в одном порядке.</span><span class="sxs-lookup"><span data-stu-id="20e4a-277">There can only be one clustered index per table, because the data rows themselves can only be sorted in one order.</span></span> <span data-ttu-id="20e4a-278">За несколькими исключениями, каждая таблица должна иметь кластеризованный индекс, определенный по столбцу или столбцам и предлагающий следующее:</span><span class="sxs-lookup"><span data-stu-id="20e4a-278">With few exceptions, every table should have a clustered index defined on the column, or columns, that offer the following:</span></span>  
  
-   <span data-ttu-id="20e4a-279">Может применяться для часто используемых запросов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-279">Can be used for frequently used queries.</span></span>  
  
-   <span data-ttu-id="20e4a-280">Обеспечивает высокую степень уникальности.</span><span class="sxs-lookup"><span data-stu-id="20e4a-280">Provide a high degree of uniqueness.</span></span>  
  
    > [!NOTE]  
    >  <span data-ttu-id="20e4a-281">При создании ограничения PRIMARY KEY будет автоматически создан уникальный индекс по столбцу или столбцам.</span><span class="sxs-lookup"><span data-stu-id="20e4a-281">When you create a PRIMARY KEY constraint, a unique index on the column, or columns, is automatically created.</span></span> <span data-ttu-id="20e4a-282">По умолчанию этот индекс кластеризован; однако при создании ограничения можно указать некластеризованный индекс.</span><span class="sxs-lookup"><span data-stu-id="20e4a-282">By default, this index is clustered; however, you can specify a nonclustered index when you create the constraint.</span></span>  
  
-   <span data-ttu-id="20e4a-283">Может использоваться в диапазонных запросах.</span><span class="sxs-lookup"><span data-stu-id="20e4a-283">Can be used in range queries.</span></span>  
  
 <span data-ttu-id="20e4a-284">Если кластеризованный индекс создан не с помощью свойства UNIQUE, то [!INCLUDE[ssDE](../includes/ssde-md.md)] автоматически добавляет 4-байтовый столбец уникализатор в таблицу.</span><span class="sxs-lookup"><span data-stu-id="20e4a-284">If the clustered index is not created with the UNIQUE property, the [!INCLUDE[ssDE](../includes/ssde-md.md)] automatically adds a 4-byte uniquifier column to the table.</span></span> <span data-ttu-id="20e4a-285">Когда это необходимо, [!INCLUDE[ssDE](../includes/ssde-md.md)] автоматически добавляет в строку значение уникализатор, чтобы каждый ключ был уникальным.</span><span class="sxs-lookup"><span data-stu-id="20e4a-285">When it is required, the [!INCLUDE[ssDE](../includes/ssde-md.md)] automatically adds a uniquifier value to a row to make each key unique.</span></span> <span data-ttu-id="20e4a-286">Данный столбец и его значения используются внутри и недоступны пользователям для просмотра или использования.</span><span class="sxs-lookup"><span data-stu-id="20e4a-286">This column and its values are used internally and cannot be seen or accessed by users.</span></span>  
  
### <a name="clustered-index-architecture"></a><span data-ttu-id="20e4a-287">Архитектура кластеризованного индекса</span><span class="sxs-lookup"><span data-stu-id="20e4a-287">Clustered Index Architecture</span></span>  

 <span data-ttu-id="20e4a-288">В [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]индексы организованы в виде сбалансированных деревьев.</span><span class="sxs-lookup"><span data-stu-id="20e4a-288">In [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], indexes are organized as B-trees.</span></span> <span data-ttu-id="20e4a-289">Каждая страница в сбалансированном дереве индекса называется узлом индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-289">Each page in an index B-tree is called an index node.</span></span> <span data-ttu-id="20e4a-290">Верхний узел сбалансированного дерева называется корневым.</span><span class="sxs-lookup"><span data-stu-id="20e4a-290">The top node of the B-tree is called the root node.</span></span> <span data-ttu-id="20e4a-291">Узлы нижнего уровня индекса называются конечными.</span><span class="sxs-lookup"><span data-stu-id="20e4a-291">The bottom nodes in the index are called the leaf nodes.</span></span> <span data-ttu-id="20e4a-292">Все уровни индекса между корневыми и конечными узлами называются промежуточными.</span><span class="sxs-lookup"><span data-stu-id="20e4a-292">Any index levels between the root and the leaf nodes are collectively known as intermediate levels.</span></span> <span data-ttu-id="20e4a-293">В кластеризованном индексе конечные узлы содержат страницы данных базовой таблицы.</span><span class="sxs-lookup"><span data-stu-id="20e4a-293">In a clustered index, the leaf nodes contain the data pages of the underlying table.</span></span> <span data-ttu-id="20e4a-294">На страницах индекса корневого и промежуточного узлов находятся строки индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-294">The root and intermediate level nodes contain index pages holding index rows.</span></span> <span data-ttu-id="20e4a-295">Каждая строка индекса содержит ключевое значение и указатель либо на страницу промежуточного уровня сбалансированного дерева, либо на строку данных на конечном уровне индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-295">Each index row contains a key value and a pointer to either an intermediate level page in the B-tree, or a data row in the leaf level of the index.</span></span> <span data-ttu-id="20e4a-296">Страницы на каждом уровне связаны в двунаправленный список.</span><span class="sxs-lookup"><span data-stu-id="20e4a-296">The pages in each level of the index are linked in a doubly-linked list.</span></span>  
  
 <span data-ttu-id="20e4a-297">Для каждого кластеризованного индекса таблица [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql)содержит одну строку со значением **index_id** , равным 1 для каждой секции, используемой индексом.</span><span class="sxs-lookup"><span data-stu-id="20e4a-297">Clustered indexes have one row in [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql), with **index_id** = 1 for each partition used by the index.</span></span> <span data-ttu-id="20e4a-298">По умолчанию, кластеризованный индекс занимает одну секцию.</span><span class="sxs-lookup"><span data-stu-id="20e4a-298">By default, a clustered index has a single partition.</span></span> <span data-ttu-id="20e4a-299">Если кластеризованный индекс занимает несколько секций, каждая секция содержит сбалансированное дерево, содержащее данные этой секции.</span><span class="sxs-lookup"><span data-stu-id="20e4a-299">When a clustered index has multiple partitions, each partition has a B-tree structure that contains the data for that specific partition.</span></span> <span data-ttu-id="20e4a-300">Например, если кластеризованный индекс занимает четыре секции, существует четыре сбалансированных дерева: по одному в каждой секции.</span><span class="sxs-lookup"><span data-stu-id="20e4a-300">For example, if a clustered index has four partitions, there are four B-tree structures; one in each partition.</span></span>  
  
 <span data-ttu-id="20e4a-301">В зависимости от типов данных, каждая структура кластеризованного индекса состоит из одной или более единиц распределения, которые применяются для хранения и управления данными секции.</span><span class="sxs-lookup"><span data-stu-id="20e4a-301">Depending on the data types in the clustered index, each clustered index structure will have one or more allocation units in which to store and manage the data for a specific partition.</span></span> <span data-ttu-id="20e4a-302">Для каждой секции кластеризованный индекс содержит, как минимум, одну единицу распределения IN_ROW_DATA.</span><span class="sxs-lookup"><span data-stu-id="20e4a-302">At a minimum, each clustered index will have one IN_ROW_DATA allocation unit per partition.</span></span> <span data-ttu-id="20e4a-303">Для хранения столбцов больших объектов (LOB) кластеризованному индексу требуется одна единица распределения LOB_DATA для каждой секции.</span><span class="sxs-lookup"><span data-stu-id="20e4a-303">The clustered index will also have one LOB_DATA allocation unit per partition if it contains large object (LOB) columns.</span></span> <span data-ttu-id="20e4a-304">Кроме того, для хранения строк переменной длины, превышающих ограничение на размер строки, равное 8 060 байтам, для каждой секции требуется одна единица распределения ROW_OVERFLOW_DATA.</span><span class="sxs-lookup"><span data-stu-id="20e4a-304">It will also have one ROW_OVERFLOW_DATA allocation unit per partition if it contains variable length columns that exceed the 8,060 byte row size limit.</span></span>  
  
 <span data-ttu-id="20e4a-305">Страницы в цепочке данных и строки, которые они содержат, упорядочены по значению ключа кластеризованного индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-305">The pages in the data chain and the rows in them are ordered on the value of the clustered index key.</span></span> <span data-ttu-id="20e4a-306">Все строки вставляются так, чтобы значение ключа составляло вместе с существующими строками упорядоченную последовательность.</span><span class="sxs-lookup"><span data-stu-id="20e4a-306">All inserts are made at the point where the key value in the inserted row fits in the ordering sequence among existing rows.</span></span>  
  
 <span data-ttu-id="20e4a-307">На следующем рисунке изображена структура кластеризованного индекса для одной секции.</span><span class="sxs-lookup"><span data-stu-id="20e4a-307">This illustration shows the structure of a clustered index in a single partition.</span></span>  
  
 <span data-ttu-id="20e4a-308">![Уровни кластеризованного индекса](media/bokind2.gif "Уровни кластеризованного индекса")</span><span class="sxs-lookup"><span data-stu-id="20e4a-308">![Levels of a clustered index](media/bokind2.gif "Levels of a clustered index")</span></span>  
  
### <a name="query-considerations"></a><span data-ttu-id="20e4a-309">Вопросы работы с запросами</span><span class="sxs-lookup"><span data-stu-id="20e4a-309">Query Considerations</span></span>  

 <span data-ttu-id="20e4a-310">Прежде чем создать кластеризованные индексы, необходимо понять, как будет происходить обращение к данным.</span><span class="sxs-lookup"><span data-stu-id="20e4a-310">Before you create clustered indexes, understand how your data will be accessed.</span></span> <span data-ttu-id="20e4a-311">Рассмотрим использование кластеризованного индекса для запросов, которые выполняют следующее:</span><span class="sxs-lookup"><span data-stu-id="20e4a-311">Consider using a clustered index for queries that do the following:</span></span>  
  
-   <span data-ttu-id="20e4a-312">Возвращают диапазон значений с помощью операторов, таких как BETWEEN, >, >=, < и <=.</span><span class="sxs-lookup"><span data-stu-id="20e4a-312">Return a range of values by using operators such as BETWEEN, >, >=, <, and <=.</span></span>  
  
     <span data-ttu-id="20e4a-313">После того как строка с первым значением будет найдена с помощью кластеризованного индекса, строки с последующими индексированными значениями гарантированно окажутся физически смежными с этой строкой.</span><span class="sxs-lookup"><span data-stu-id="20e4a-313">After the row with the first value is found by using the clustered index, rows with subsequent indexed values are guaranteed to be physically adjacent.</span></span> <span data-ttu-id="20e4a-314">Например, если запрос получает записи из диапазона порядковых номеров продаж, кластеризованный индекс по столбцу `SalesOrderNumber` может быстро определить расположение строки, содержащей стартовый порядковый номер продаж, и затем извлечь все последующие строки из таблицы, пока не будет достигнут последний порядковый номер продаж.</span><span class="sxs-lookup"><span data-stu-id="20e4a-314">For example, if a query retrieves records between a range of sales order numbers, a clustered index on the column `SalesOrderNumber` can quickly locate the row that contains the starting sales order number, and then retrieve all successive rows in the table until the last sales order number is reached.</span></span>  
  
-   <span data-ttu-id="20e4a-315">Возвращают большие результирующие наборы.</span><span class="sxs-lookup"><span data-stu-id="20e4a-315">Return large result sets.</span></span>  
  
-   <span data-ttu-id="20e4a-316">Используют предложения JOIN; обычно в них участвуют внешние ключевые столбцы.</span><span class="sxs-lookup"><span data-stu-id="20e4a-316">Use JOIN clauses; typically these are foreign key columns.</span></span>  
  
-   <span data-ttu-id="20e4a-317">Используют предложения ORDER BY или GROUP BY.</span><span class="sxs-lookup"><span data-stu-id="20e4a-317">Use ORDER BY, or GROUP BY clauses.</span></span>  
  
     <span data-ttu-id="20e4a-318">Индекс по столбцам, указанным в предложении ORDER BY или GROUP BY, может исключить потребность в сортировке данных для компонента [!INCLUDE[ssDE](../includes/ssde-md.md)] , потому что строки будут уже отсортированы.</span><span class="sxs-lookup"><span data-stu-id="20e4a-318">An index on the columns specified in the ORDER BY or GROUP BY clause may remove the need for the [!INCLUDE[ssDE](../includes/ssde-md.md)] to sort the data, because the rows are already sorted.</span></span> <span data-ttu-id="20e4a-319">Это улучшает производительность запроса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-319">This improves query performance.</span></span>  
  
### <a name="column-considerations"></a><span data-ttu-id="20e4a-320">Вопросы работы со столбцами</span><span class="sxs-lookup"><span data-stu-id="20e4a-320">Column Considerations</span></span>  

 <span data-ttu-id="20e4a-321">В общем случае надо так определить ключ кластеризованного индекса, чтобы в него вошло как можно меньше столбцов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-321">Generally, you should define the clustered index key with as few columns as possible.</span></span> <span data-ttu-id="20e4a-322">Рассмотрите столбцы, которым присущ один или несколько следующих атрибутов:</span><span class="sxs-lookup"><span data-stu-id="20e4a-322">Consider columns that have one or more of the following attributes:</span></span>  
  
-   <span data-ttu-id="20e4a-323">Являются уникальными или содержат много различных значений.</span><span class="sxs-lookup"><span data-stu-id="20e4a-323">Are unique or contain many distinct values</span></span>  
  
     <span data-ttu-id="20e4a-324">Например, идентификатор сотрудника уникально идентифицирует служащих.</span><span class="sxs-lookup"><span data-stu-id="20e4a-324">For example, an employee ID uniquely identifies employees.</span></span> <span data-ttu-id="20e4a-325">Кластеризованный индекс или ограничение PRIMARY KEY на столбец `EmployeeID` улучшило бы производительность запросов, которые производят поиск сведений о сотруднике, основываясь на номере идентификатора сотрудника.</span><span class="sxs-lookup"><span data-stu-id="20e4a-325">A clustered index or PRIMARY KEY constraint on the `EmployeeID` column would improve the performance of queries that search for employee information based on the employee ID number.</span></span> <span data-ttu-id="20e4a-326">В качестве альтернативы кластеризованный индекс мог бы быть создан по столбцам `LastName`, `FirstName`и `MiddleName` , потому что записи сотрудников часто группируются и запрашиваются именно таким образом, так что сочетание этих столбцов обеспечивало бы высокую степень различия.</span><span class="sxs-lookup"><span data-stu-id="20e4a-326">Alternatively, a clustered index could be created on `LastName`, `FirstName`, `MiddleName` because employee records are frequently grouped and queried in this way, and the combination of these columns would still provide a high degree of difference.</span></span>  
  
-   <span data-ttu-id="20e4a-327">Обращение к ним происходит последовательно.</span><span class="sxs-lookup"><span data-stu-id="20e4a-327">Are accessed sequentially</span></span>  
  
     <span data-ttu-id="20e4a-328">Например, код продукта уникально идентифицирует продукты в таблице `Production.Product` в базе данных [!INCLUDE[ssSampleDBobject](../includes/sssampledbobject-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="20e4a-328">For example, a product ID uniquely identifies products in the `Production.Product` table in the [!INCLUDE[ssSampleDBobject](../includes/sssampledbobject-md.md)] database.</span></span> <span data-ttu-id="20e4a-329">Запросы, в которых указан последовательный поиск, например `WHERE ProductID BETWEEN 980 and 999`, извлекут заметную выгоду из кластеризованного индекса по `ProductID`.</span><span class="sxs-lookup"><span data-stu-id="20e4a-329">Queries in which a sequential search is specified, such as `WHERE ProductID BETWEEN 980 and 999`, would benefit from a clustered index on `ProductID`.</span></span> <span data-ttu-id="20e4a-330">Это происходит потому, что строки будут храниться в отсортированном порядке по этому ключевому столбцу.</span><span class="sxs-lookup"><span data-stu-id="20e4a-330">This is because the rows would be stored in sorted order on that key column.</span></span>  
  
-   <span data-ttu-id="20e4a-331">Определен как IDENTITY.</span><span class="sxs-lookup"><span data-stu-id="20e4a-331">Defined as IDENTITY.</span></span>  
  
-   <span data-ttu-id="20e4a-332">Часто используются для сортировки данных, полученных из таблицы.</span><span class="sxs-lookup"><span data-stu-id="20e4a-332">Used frequently to sort the data retrieved from a table.</span></span>  
  
     <span data-ttu-id="20e4a-333">Это может служить хорошей идеей для кластеризации (которая по сути является физической сортировкой) таблицы по этому столбцу, потому что исключит затраты на сортировку при каждом запросе к столбцу.</span><span class="sxs-lookup"><span data-stu-id="20e4a-333">It can be a good idea to cluster, that is physically sort, the table on that column to save the cost of a sort operation every time the column is queried.</span></span>  
  
 <span data-ttu-id="20e4a-334">Кластеризованные индексы — не лучший выбор для следующих атрибутов:</span><span class="sxs-lookup"><span data-stu-id="20e4a-334">Clustered indexes are not a good choice for the following attributes:</span></span>  
  
-   <span data-ttu-id="20e4a-335">столбцов, которые подвергаются частым изменениям;</span><span class="sxs-lookup"><span data-stu-id="20e4a-335">Columns that undergo frequent changes</span></span>  
  
     <span data-ttu-id="20e4a-336">Это приводит к тому, что вся строка перемещается, поскольку параметр [!INCLUDE[ssDE](../includes/ssde-md.md)] должен удержать значения данных строки в физическом порядке.</span><span class="sxs-lookup"><span data-stu-id="20e4a-336">This causes the whole row to move, because the [!INCLUDE[ssDE](../includes/ssde-md.md)] must keep the data values of a row in physical order.</span></span> <span data-ttu-id="20e4a-337">Это важно при работе в крупномасштабных системах обработки транзакций, в которых данные обычно быстро меняются.</span><span class="sxs-lookup"><span data-stu-id="20e4a-337">This is an important consideration in high-volume transaction processing systems in which data is typically volatile.</span></span>  
  
-   <span data-ttu-id="20e4a-338">широких ключей.</span><span class="sxs-lookup"><span data-stu-id="20e4a-338">Wide keys</span></span>  
  
     <span data-ttu-id="20e4a-339">Широкие ключи составлены из нескольких столбцов или нескольких столбцов большого размера.</span><span class="sxs-lookup"><span data-stu-id="20e4a-339">Wide keys are a composite of several columns or several large-size columns.</span></span> <span data-ttu-id="20e4a-340">Ключевые значения из кластеризованного индекса используются всеми некластеризованными индексами как уточняющие запросы.</span><span class="sxs-lookup"><span data-stu-id="20e4a-340">The key values from the clustered index are used by all nonclustered indexes as lookup keys.</span></span> <span data-ttu-id="20e4a-341">Любые некластеризованные индексы, определенные на той же самой таблице, будут значительно больше, потому что записи некластеризованного индекса содержат ключ кластеризации, а также ключевые столбцы, определенные для этого некластеризованного индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-341">Any nonclustered indexes defined on the same table will be significantly larger because the nonclustered index entries contain the clustering key and also the key columns defined for that nonclustered index.</span></span>  
  
 <span data-ttu-id="20e4a-342">![Значок стрелки, используемый в ссылке "назад на начало](media/uparrow16x16.gif "Значок стрелки, используемый со ссылкой В начало") " [в этом пошаговом окне](#Top)</span><span class="sxs-lookup"><span data-stu-id="20e4a-342">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="nonclustered-index-design-guidelines"></a><a name="Nonclustered"></a> <span data-ttu-id="20e4a-343">Рекомендации по созданию некластеризованных индексов</span><span class="sxs-lookup"><span data-stu-id="20e4a-343">Nonclustered Index Design Guidelines</span></span>  

 <span data-ttu-id="20e4a-344">Некластеризованный индекс содержит значения ключей индекса и указатели строк, которые указывают на место хранения табличных данных.</span><span class="sxs-lookup"><span data-stu-id="20e4a-344">A nonclustered index contains the index key values and row locators that point to the storage location of the table data.</span></span> <span data-ttu-id="20e4a-345">Можно создать несколько некластеризованных индексов для таблицы или индексированного представления.</span><span class="sxs-lookup"><span data-stu-id="20e4a-345">You can create multiple nonclustered indexes on a table or indexed view.</span></span> <span data-ttu-id="20e4a-346">Как правило, некластеризованные индексы следует создавать для повышения эффективности часто используемых запросов, не учитываемых кластеризованными индексами.</span><span class="sxs-lookup"><span data-stu-id="20e4a-346">Generally, nonclustered indexes should be designed to improve the performance of frequently used queries that are not covered by the clustered index.</span></span>  
  
 <span data-ttu-id="20e4a-347">Подобно тому, как читатель использует индекс в книге, оптимизатор запросов выискивает значение типа данных, просматривая некластеризованный индекс. Там он находит место расположения интересующего его значения в таблице и затем получает данные непосредственно из этого места.</span><span class="sxs-lookup"><span data-stu-id="20e4a-347">Similar to the way you use an index in a book, the query optimizer searches for a data value by searching the nonclustered index to find the location of the data value in the table and then retrieves the data directly from that location.</span></span> <span data-ttu-id="20e4a-348">Благодаря этому некластеризованные индексы считаются оптимальным выбором для запросов с точным соответствием, поскольку такие индексы содержат записи, описывающие точное расположение в таблице значений типов данных, которые задаются в подобных запросах.</span><span class="sxs-lookup"><span data-stu-id="20e4a-348">This makes nonclustered indexes the optimal choice for exact match queries because the index contains entries describing the exact location in the table of the data values being searched for in the queries.</span></span> <span data-ttu-id="20e4a-349">К примеру, чтобы выбрать в таблице `HumanResources. Employee` всех сотрудников, подчиняющихся тому или иному менеджеру, оптимизатор запросов может воспользоваться некластеризованным индексом `IX_Employee_ManagerID`; ключевым столбцом в нем является `ManagerID` .</span><span class="sxs-lookup"><span data-stu-id="20e4a-349">For example, to query the `HumanResources. Employee` table for all employees that report to a specific manager, the query optimizer might use the nonclustered index `IX_Employee_ManagerID`; this has `ManagerID` as its key column.</span></span> <span data-ttu-id="20e4a-350">Оптимизатор запросов может быстро обнаружить в индексе все записи, соответствующие указанному значению `ManagerID`.</span><span class="sxs-lookup"><span data-stu-id="20e4a-350">The query optimizer can quickly find all entries in the index that match the specified `ManagerID`.</span></span> <span data-ttu-id="20e4a-351">Каждый элемент указателя ссылается на конкретную страницу и строку в таблице или на кластеризованный индекс, в котором можно найти соответствующие данные.</span><span class="sxs-lookup"><span data-stu-id="20e4a-351">Each index entry points to the exact page and row in the table, or clustered index, in which the corresponding data can be found.</span></span> <span data-ttu-id="20e4a-352">После того как оптимизатор запросов обнаружит все записи в индексе, он может переходить непосредственно к нужной странице и строке, откуда он будет получать требуемые данные.</span><span class="sxs-lookup"><span data-stu-id="20e4a-352">After the query optimizer finds all entries in the index, it can go directly to the exact page and row to retrieve the data.</span></span>  
  
### <a name="nonclustered-index-architecture"></a><span data-ttu-id="20e4a-353">Архитектура некластеризованного индекса</span><span class="sxs-lookup"><span data-stu-id="20e4a-353">Nonclustered Index Architecture</span></span>  

 <span data-ttu-id="20e4a-354">Некластеризованные индексы имеют ту же структуру сбалансированного дерева, что и кластеризованные индексы; существуют только следующие различия:</span><span class="sxs-lookup"><span data-stu-id="20e4a-354">Nonclustered indexes have the same B-tree structure as clustered indexes, except for the following significant differences:</span></span>  
  
-   <span data-ttu-id="20e4a-355">строки данных в базовой таблице не сортируются и хранятся в порядке, который основан на их некластеризованных ключах;</span><span class="sxs-lookup"><span data-stu-id="20e4a-355">The data rows of the underlying table are not sorted and stored in order based on their nonclustered keys.</span></span>  
  
-   <span data-ttu-id="20e4a-356">конечный уровень некластеризованного индекса состоит из страниц индекса вместо страниц данных.</span><span class="sxs-lookup"><span data-stu-id="20e4a-356">The leaf layer of a nonclustered index is made up of index pages instead of data pages.</span></span>  
  
 <span data-ttu-id="20e4a-357">Указатели строк на строках некластеризованных индексов являются либо указателем на строку, либо ключом кластеризованного индекса для строки, как описано ниже.</span><span class="sxs-lookup"><span data-stu-id="20e4a-357">The row locators in nonclustered index rows are either a pointer to a row or are a clustered index key for a row, as described in the following:</span></span>  
  
-   <span data-ttu-id="20e4a-358">Если таблица является кучей, что означает, что она не содержит кластеризованный индекс, то обнаружитель строки является указателем на строку.</span><span class="sxs-lookup"><span data-stu-id="20e4a-358">If the table is a heap, which means it does not have a clustered index, the row locator is a pointer to the row.</span></span> <span data-ttu-id="20e4a-359">Указатель строится на основе идентификатора файла (ID), номера страницы и номера строки на странице.</span><span class="sxs-lookup"><span data-stu-id="20e4a-359">The pointer is built from the file identifier (ID), page number, and number of the row on the page.</span></span> <span data-ttu-id="20e4a-360">Весь указатель целиком называется идентификатором строки (RID).</span><span class="sxs-lookup"><span data-stu-id="20e4a-360">The whole pointer is known as a Row ID (RID).</span></span>  
  
-   <span data-ttu-id="20e4a-361">Если для таблицы имеется кластеризованный индекс или индекс построен на индексированном представлении, то указатель строки — это ключ кластеризованного индекса для строки.</span><span class="sxs-lookup"><span data-stu-id="20e4a-361">If the table has a clustered index, or the index is on an indexed view, the row locator is the clustered index key for the row.</span></span>  
  
 <span data-ttu-id="20e4a-362">Для некластеризованных индексов таблица [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql) содержит одну строку со значением столбца **index_id** >1 для каждой секции, используемой индексом.</span><span class="sxs-lookup"><span data-stu-id="20e4a-362">Nonclustered indexes have one row in [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql) with **index_id** >1 for each partition used by the index.</span></span> <span data-ttu-id="20e4a-363">По умолчанию некластеризованный индекс включает одну секцию.</span><span class="sxs-lookup"><span data-stu-id="20e4a-363">By default, a nonclustered index has a single partition.</span></span> <span data-ttu-id="20e4a-364">Если некластеризованный индекс состоит из нескольких секций, то каждая секция имеет структуру сбалансированного дерева, в которой содержатся индексные строки для данной конкретной секции.</span><span class="sxs-lookup"><span data-stu-id="20e4a-364">When a nonclustered index has multiple partitions, each partition has a B-tree structure that contains the index rows for that specific partition.</span></span> <span data-ttu-id="20e4a-365">Например, если некластеризованный индекс состоит из четырех секций, то существуют четыре структуры сбалансированного дерева, по одной на каждую секцию.</span><span class="sxs-lookup"><span data-stu-id="20e4a-365">For example, if a nonclustered index has four partitions, there are four B-tree structures, with one in each partition.</span></span>  
  
 <span data-ttu-id="20e4a-366">В зависимости от типов данных в некластеризованном индексе каждая структура некластеризованного индекса будет содержать одну или более единиц распределения, в которых хранятся данные для определенной секции.</span><span class="sxs-lookup"><span data-stu-id="20e4a-366">Depending on the data types in the nonclustered index, each nonclustered index structure will have one or more allocation units in which to store and manage the data for a specific partition.</span></span> <span data-ttu-id="20e4a-367">Каждый некластеризованный индекс будет содержать по меньшей мере одну единицу распределения IN_ROW_DATA на секцию, в которой хранятся страницы сбалансированного дерева индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-367">At a minimum, each nonclustered index will have one IN_ROW_DATA allocation unit per partition that stores the index B-tree pages.</span></span> <span data-ttu-id="20e4a-368">Некластеризованный индекс будет также содержать одну единицу распределения LOB_DATA на секцию, если в индексе содержатся столбцы типа большого объекта (LOB).</span><span class="sxs-lookup"><span data-stu-id="20e4a-368">The nonclustered index will also have one LOB_DATA allocation unit per partition if it contains large object (LOB) columns .</span></span> <span data-ttu-id="20e4a-369">Кроме того, некластеризованный индекс будет содержать одну единицу распределения ROW_OVERFLOW_DATA на секцию, если в индексе содержатся столбцы переменной длины, в которых превышается максимальный размер строки, равный 8 060 байт.</span><span class="sxs-lookup"><span data-stu-id="20e4a-369">Additionally, it will have one ROW_OVERFLOW_DATA allocation unit per partition if it contains variable length columns that exceed the 8,060 byte row size limit.</span></span>  
  
 <span data-ttu-id="20e4a-370">На следующей иллюстрации показана структура некластеризованного индекса, состоящего из одной секции.</span><span class="sxs-lookup"><span data-stu-id="20e4a-370">The following illustration shows the structure of a nonclustered index in a single partition.</span></span>  
  
 <span data-ttu-id="20e4a-371">![Уровни некластеризованного индекса](media/bokind1.gif "Уровни некластеризованного индекса")</span><span class="sxs-lookup"><span data-stu-id="20e4a-371">![Levels of a nonclustered index](media/bokind1.gif "Levels of a nonclustered index")</span></span>  
  
### <a name="database-considerations"></a><span data-ttu-id="20e4a-372">Соображения, связанные с базами данных</span><span class="sxs-lookup"><span data-stu-id="20e4a-372">Database Considerations</span></span>  

 <span data-ttu-id="20e4a-373">При проектировании некластеризованных индексов следует принимать во внимание характеристики соответствующей базы данных.</span><span class="sxs-lookup"><span data-stu-id="20e4a-373">Consider the characteristics of the database when designing nonclustered indexes.</span></span>  
  
-   <span data-ttu-id="20e4a-374">В базах данных или таблицах, характеризующихся нечастыми обновлениями и большими объемами хранимых данных, запросы могут выполняться быстрее при использовании множества некластеризованных индексов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-374">Databases or tables with low update requirements, but large volumes of data can benefit from many nonclustered indexes to improve query performance.</span></span> <span data-ttu-id="20e4a-375">Рекомендуется создать отфильтрованные индексы для четко определенных подмножеств данных, что позволит повысить производительность запросов, а также снизить затраты на обслуживание и хранение индексов по сравнению с полнотабличными некластеризованными индексами.</span><span class="sxs-lookup"><span data-stu-id="20e4a-375">Consider creating filtered indexes for well-defined subsets of data to improve query performance, reduce index storage costs, and reduce index maintenance costs compared with full-table nonclustered indexes.</span></span>  
  
     <span data-ttu-id="20e4a-376">Производительность приложений систем поддержки принятия решений, а также баз данных может быть увеличена за счет использования большого числа некластеризованных индексов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-376">Decision Support System applications and databases that contain primarily read-only data can benefit from many nonclustered indexes.</span></span> <span data-ttu-id="20e4a-377">В процессе определения наиболее быстрого метода доступа оптимизатор запросов может выбирать из большего числа индексов, а если база данных не предназначена для частых обновлений, это значит, что операции по обслуживанию индексов не будут сказываться на ее быстродействии.</span><span class="sxs-lookup"><span data-stu-id="20e4a-377">The query optimizer has more indexes to choose from to determine the fastest access method, and the low update characteristics of the database mean index maintenance will not impede performance.</span></span>  
  
-   <span data-ttu-id="20e4a-378">При работе с приложениями и базами данных обработки транзакций в сети следует избегать слишком большого числа индексов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-378">Online Transaction Processing applications and databases that contain heavily updated tables should avoid over-indexing.</span></span> <span data-ttu-id="20e4a-379">Кроме того, индексы должны быть узкими, то есть содержать минимальное количество столбцов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-379">Additionally, indexes should be narrow, that is, with as few columns as possible.</span></span>  
  
     <span data-ttu-id="20e4a-380">Большое количество индексов в таблице снижает производительность инструкций INSERT, UPDATE, DELETE и MERGE, потому что при изменении данных в таблице все индексы должны быть соответствующим образом изменены.</span><span class="sxs-lookup"><span data-stu-id="20e4a-380">Large numbers of indexes on a table affect the performance of INSERT, UPDATE, DELETE, and MERGE  statements because all indexes must be adjusted appropriately as data in the table changes.</span></span>  
  
### <a name="query-considerations"></a><span data-ttu-id="20e4a-381">Вопросы работы с запросами</span><span class="sxs-lookup"><span data-stu-id="20e4a-381">Query Considerations</span></span>  

 <span data-ttu-id="20e4a-382">Перед тем как приступать к созданию некластеризованных индексов, необходимо разобраться с тем, каким образом будет организован доступ к данным.</span><span class="sxs-lookup"><span data-stu-id="20e4a-382">Before you create nonclustered indexes, you should understand how your data will be accessed.</span></span> <span data-ttu-id="20e4a-383">Рассмотрите возможность использования некластеризованных индексов для запросов, обладающих следующими атрибутами:</span><span class="sxs-lookup"><span data-stu-id="20e4a-383">Consider using a nonclustered index for queries that have the following attributes:</span></span>  
  
-   <span data-ttu-id="20e4a-384">Используйте предложения JOIN или GROUP BY.</span><span class="sxs-lookup"><span data-stu-id="20e4a-384">Use JOIN or GROUP BY clauses.</span></span>  
  
     <span data-ttu-id="20e4a-385">Создавайте многомерные некластеризованные индексы для столбцов, участвующих в операциях соединения и группирования, а кластеризованный индекс для внешних ключевых столбцов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-385">Create multiple nonclustered indexes on columns involved in join and grouping operations, and a clustered index on any foreign key columns.</span></span>  
  
-   <span data-ttu-id="20e4a-386">Запросы, не возвращающие больших результирующих наборов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-386">Queries that do not return large result sets.</span></span>  
  
     <span data-ttu-id="20e4a-387">Создайте отфильтрованные индексы для использования с запросами, возвращающими четко определенные подмножества строк из большой таблицы.</span><span class="sxs-lookup"><span data-stu-id="20e4a-387">Create filtered indexes to cover queries that return a well-defined subset of rows from a large table.</span></span>  
  
-   <span data-ttu-id="20e4a-388">Содержат столбцы, часто встречающиеся в условиях поиска запроса, таких как предложение WHERE, возвращающих точные соответствия.</span><span class="sxs-lookup"><span data-stu-id="20e4a-388">Contain columns frequently involved in search conditions of a query, such as WHERE clause, that return exact matches.</span></span>  
  
### <a name="column-considerations"></a><span data-ttu-id="20e4a-389">Вопросы работы со столбцами</span><span class="sxs-lookup"><span data-stu-id="20e4a-389">Column Considerations</span></span>  

 <span data-ttu-id="20e4a-390">Рассмотрите столбцы, обладающие одним или несколькими указанными ниже атрибутами:</span><span class="sxs-lookup"><span data-stu-id="20e4a-390">Consider columns that have one or more of these attributes:</span></span>  
  
-   <span data-ttu-id="20e4a-391">Покрытие запроса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-391">Cover the query.</span></span>  
  
     <span data-ttu-id="20e4a-392">Производительность повышается в тех случаях, когда индекс содержит все столбцы запроса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-392">Performance gains are achieved when the index contains all columns in the query.</span></span> <span data-ttu-id="20e4a-393">Оптимизатор запросов может обнаружить все значения столбцов внутри данного индекса; необходимость в обращении к таблицам или данным кластеризованных индексов отпадает, в результате чего снижается интенсивность дисковых операций ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="20e4a-393">The query optimizer can locate all the column values within the index; table or clustered index data is not accessed resulting in fewer disk I/O operations.</span></span> <span data-ttu-id="20e4a-394">Для расширения покрытия столбцов не следует создавать широкий ключ индекса; используйте индекс с включенными столбцами.</span><span class="sxs-lookup"><span data-stu-id="20e4a-394">Use index with included columns to add covering columns instead of creating a wide index key.</span></span>  
  
     <span data-ttu-id="20e4a-395">Если таблица имеет кластеризованный индекс, то столбец или столбцы, определенные в этом кластеризованном индексе, автоматически добавляются к концу каждого некластеризованного индекса таблицы.</span><span class="sxs-lookup"><span data-stu-id="20e4a-395">If the table has a clustered index, the column or columns defined in the clustered index are automatically appended to the end of each nonclustered index on the table.</span></span> <span data-ttu-id="20e4a-396">Это может привести к возникновению покрытого запроса без указания столбцов кластеризованного индекса в определении некластеризованного индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-396">This can produce a covered query without specifying the clustered index columns in the definition of the nonclustered index.</span></span> <span data-ttu-id="20e4a-397">Так, если для таблицы имеется кластеризованный индекс в столбце `C`, то некластеризованный индекс в столбцах `B` и `A` будет иметь в качестве ключевых значений столбцы `B`, `A`и `C`.</span><span class="sxs-lookup"><span data-stu-id="20e4a-397">For example, if a table has a clustered index on column `C`, a nonclustered index on columns `B` and `A` will have as its key values columns `B`, `A`, and `C`.</span></span>  
  
-   <span data-ttu-id="20e4a-398">Множество индивидуальных значений, таких как сочетание фамилии и имени, если кластеризованный индекс используется для других столбцов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-398">Lots of distinct values, such as a combination of last name and first name, if a clustered index is used for other columns.</span></span>  
  
     <span data-ttu-id="20e4a-399">Если имеется очень мало индивидуальных значений, скажем, только 1 и 0, то при выполнении большинства запросов этот индекс не будет использоваться, так как эффективность просмотра таблиц, как правило, выше.</span><span class="sxs-lookup"><span data-stu-id="20e4a-399">If there are very few distinct values, such as only 1 and 0, most queries will not use the index because a table scan is generally more efficient.</span></span> <span data-ttu-id="20e4a-400">Для этого типа данных рекомендуется создать отфильтрованный индекс для определенного значения, которое содержится в небольшом количестве строк.</span><span class="sxs-lookup"><span data-stu-id="20e4a-400">For this type of data, consider creating a filtered index on a distinct value that only occurs in a small number of rows.</span></span> <span data-ttu-id="20e4a-401">Например, если большая часть значений равна 0, то оптимизатор запросов может использовать отфильтрованный индекс для строк данных, в которых содержится 1.</span><span class="sxs-lookup"><span data-stu-id="20e4a-401">For example, if most of the values are 0, the query optimizer might use a filtered index for the data rows that contain 1.</span></span>  
  
####  <a name="use-included-columns-to-extend-nonclustered-indexes"></a><a name="Included_Columns"></a> <span data-ttu-id="20e4a-402">Использование включенных столбцов для расширения некластеризованных индексов</span><span class="sxs-lookup"><span data-stu-id="20e4a-402">Use Included Columns to Extend Nonclustered Indexes</span></span>  

 <span data-ttu-id="20e4a-403">Функциональность некластеризованных индексов можно расширить с помощью добавления неключевых столбцов к конечному уровню некластеризованного индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-403">You can extend the functionality of nonclustered indexes by adding nonkey columns to the leaf level of the nonclustered index.</span></span> <span data-ttu-id="20e4a-404">Добавление неключевых столбцов позволяет создавать некластеризованные индексы, покрывающие больше запросов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-404">By including nonkey columns, you can create nonclustered indexes that cover more queries.</span></span> <span data-ttu-id="20e4a-405">Это обусловлено следующими преимуществами неключевых столбцов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-405">This is because the nonkey columns have the following benefits:</span></span>  
  
-   <span data-ttu-id="20e4a-406">Они могут содержать типы данных, не разрешенные для ключевых столбцов индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-406">They can be data types not allowed as index key columns.</span></span>  
  
-   <span data-ttu-id="20e4a-407">Они не учитываются компонентом [!INCLUDE[ssDE](../includes/ssde-md.md)] при расчете числа ключевых столбцов индекса и размера ключа индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-407">They are not considered by the [!INCLUDE[ssDE](../includes/ssde-md.md)] when calculating the number of index key columns or index key size.</span></span>  
  
 <span data-ttu-id="20e4a-408">Индекс с включенными неключевыми столбцами может значительно повысить производительность запроса, когда все столбцы запроса включены в индекс как ключевые или неключевые.</span><span class="sxs-lookup"><span data-stu-id="20e4a-408">An index with included nonkey columns can significantly improve query performance when all columns in the query are included in the index either as key or nonkey columns.</span></span> <span data-ttu-id="20e4a-409">Производительность повышается благодаря тому, что оптимизатор запросов может найти все значения столбцов в этом индексе; при этом нет обращения к данным таблиц или кластеризованных индексов, что приводит к меньшему количеству дисковых операций ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="20e4a-409">Performance gains are achieved because the query optimizer can locate all the column values within the index; table or clustered index data is not accessed resulting in fewer disk I/O operations.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="20e4a-410">Если индекс содержит все столбцы, ссылаемые в запросе, это называется покрытием запроса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-410">When an index contains all the columns referenced by the query it is typically referred to as covering the query.</span></span>  
  
 <span data-ttu-id="20e4a-411">В то время как ключевые столбцы сохраняются на всех уровнях индекса, неключевые столбцы сохраняются только на конечном уровне.</span><span class="sxs-lookup"><span data-stu-id="20e4a-411">While key columns are stored at all levels of the index, nonkey columns are stored only at the leaf level.</span></span>  
  
##### <a name="using-included-columns-to-avoid-size-limits"></a><span data-ttu-id="20e4a-412">Использование включенных столбцов для обхода ограничений по размеру</span><span class="sxs-lookup"><span data-stu-id="20e4a-412">Using Included Columns to Avoid Size Limits</span></span>  

 <span data-ttu-id="20e4a-413">Можно включать неключевые столбцы в некластеризованный индекс, чтобы избежать превышения текущих ограничений на размер индекса (16 ключевых столбцов) и размер ключа индекса (900 байт).</span><span class="sxs-lookup"><span data-stu-id="20e4a-413">You can include nonkey columns in a nonclustered index to avoid exceeding the current index size limitations of a maximum of 16 key columns and a maximum index key size of 900 bytes.</span></span> <span data-ttu-id="20e4a-414">Компонент [!INCLUDE[ssDE](../includes/ssde-md.md)] не учитывает неключевые столбцы при расчете количества ключевых столбцов индекса и размера ключа индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-414">The [!INCLUDE[ssDE](../includes/ssde-md.md)] does not consider nonkey columns when calculating the number of index key columns or index key size.</span></span>  
  
 <span data-ttu-id="20e4a-415">Например, нужно индексировать следующие столбцы в таблице `Document` :</span><span class="sxs-lookup"><span data-stu-id="20e4a-415">For example, assume that you want to index the following columns in the `Document` table:</span></span>  
  
 `Title nvarchar(50)`  
  
 `Revision nchar(5)`  
  
 `FileName nvarchar(400)`  
  
 <span data-ttu-id="20e4a-416">Поскольку для типов данных `nchar` и `nvarchar` необходимо 2 байта для каждого символа, индекс, содержащий эти три столбца, превысит на 10 байт ограничение на размер в 900 байт (455 \* 2).</span><span class="sxs-lookup"><span data-stu-id="20e4a-416">Because the `nchar` and `nvarchar` data types require 2 bytes for each character, an index that contains these three columns would exceed the 900 byte size limitation by 10 bytes (455 \* 2).</span></span> <span data-ttu-id="20e4a-417">Использование предложения `INCLUDE` в инструкции `CREATE INDEX` позволит определить ключ индекса как (`Title, Revision`), а `FileName` определить как неключевой столбец.</span><span class="sxs-lookup"><span data-stu-id="20e4a-417">By using the `INCLUDE` clause of the `CREATE INDEX` statement, the index key could be defined as (`Title, Revision`) and `FileName` defined as a nonkey column.</span></span> <span data-ttu-id="20e4a-418">Таким образом, размер ключа индекса составит 110 байт (55 \* 2), при этом индекс будет по-прежнему содержать все нужные столбцы.</span><span class="sxs-lookup"><span data-stu-id="20e4a-418">In this way, the index key size would be 110 bytes (55 \* 2), and the index would still contain all the required columns.</span></span> <span data-ttu-id="20e4a-419">Следующая инструкция создает такой индекс:</span><span class="sxs-lookup"><span data-stu-id="20e4a-419">The following statement creates such an index.</span></span>  
  
```sql
CREATE INDEX IX_Document_Title   
ON Production.Document (Title, Revision)   
INCLUDE (FileName);   
```  
  
##### <a name="index-with-included-columns-guidelines"></a><span data-ttu-id="20e4a-420">Правила для индекса с включенными столбцами</span><span class="sxs-lookup"><span data-stu-id="20e4a-420">Index with Included Columns Guidelines</span></span>  

 <span data-ttu-id="20e4a-421">При проектировании некластеризованных индексов с включенными столбцами пользуйтесь следующими правилами.</span><span class="sxs-lookup"><span data-stu-id="20e4a-421">When you design nonclustered indexes with included columns consider the following guidelines:</span></span>  
  
-   <span data-ttu-id="20e4a-422">Неключевые столбцы определяются предложением INCLUDE инструкции CREATE INDEX.</span><span class="sxs-lookup"><span data-stu-id="20e4a-422">Nonkey columns are defined in the INCLUDE clause of the CREATE INDEX statement.</span></span>  
  
-   <span data-ttu-id="20e4a-423">Неключевые столбцы можно определять только для некластеризованных индексов по таблицам или индексированным представлениям.</span><span class="sxs-lookup"><span data-stu-id="20e4a-423">Nonkey columns can only be defined on nonclustered indexes on tables or indexed views.</span></span>  
  
-   <span data-ttu-id="20e4a-424">Допускаются данные всех типов, за исключением `text`, `ntext` и `image`.</span><span class="sxs-lookup"><span data-stu-id="20e4a-424">All data types are allowed except `text`, `ntext`, and `image`.</span></span>  
  
-   <span data-ttu-id="20e4a-425">Вычисляемые столбцы, являющиеся детерминированными и точными или неточными, могут быть включенными столбцами.</span><span class="sxs-lookup"><span data-stu-id="20e4a-425">Computed columns that are deterministic and either precise or imprecise can be included columns.</span></span> <span data-ttu-id="20e4a-426">Дополнительные сведения см. в разделе [Индексы вычисляемых столбцов](../relational-databases/indexes/indexes-on-computed-columns.md).</span><span class="sxs-lookup"><span data-stu-id="20e4a-426">For more information, see [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md).</span></span>  
  
-   <span data-ttu-id="20e4a-427">Как и ключевые столбцы, вычисляемые столбцы, полученные на основе типов данных `image`, `ntext` и `text`, могут быть неключевыми (включенными) столбцами до тех пор, пока тип данных этого вычисляемого столбца допустим в качестве неключевого индексного столбца.</span><span class="sxs-lookup"><span data-stu-id="20e4a-427">As with key columns, computed columns derived from `image`, `ntext`, and `text` data types can be nonkey (included) columns as long as the computed column data type is allowed as a nonkey index column.</span></span>  
  
-   <span data-ttu-id="20e4a-428">Имена столбцов нельзя указывать ни в списке INCLUDE, ни в списке ключевых столбцов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-428">Column names cannot be specified in both the INCLUDE list and in the key column list.</span></span>  
  
-   <span data-ttu-id="20e4a-429">Имена столбцов в списке INCLUDE нельзя повторять.</span><span class="sxs-lookup"><span data-stu-id="20e4a-429">Column names cannot be repeated in the INCLUDE list.</span></span>  
  
##### <a name="column-size-guidelines"></a><span data-ttu-id="20e4a-430">Требования к размеру столбцов</span><span class="sxs-lookup"><span data-stu-id="20e4a-430">Column Size Guidelines</span></span>  
  
-   <span data-ttu-id="20e4a-431">Должен быть определен как минимум один ключевой столбец.</span><span class="sxs-lookup"><span data-stu-id="20e4a-431">At least one key column must be defined.</span></span> <span data-ttu-id="20e4a-432">Максимальное количество неключевых столбцов равно 1023.</span><span class="sxs-lookup"><span data-stu-id="20e4a-432">The maximum number of nonkey columns is 1023 columns.</span></span> <span data-ttu-id="20e4a-433">Это на 1 меньше, чем максимальное количество столбцов таблицы.</span><span class="sxs-lookup"><span data-stu-id="20e4a-433">This is the maximum number of table columns minus 1.</span></span>  
  
-   <span data-ttu-id="20e4a-434">Ключевые столбцы индекса, в отличие от неключевых, должны удовлетворять текущим ограничениям на максимальное количество столбцов (16) и общий размер ключа индекса (900 байт).</span><span class="sxs-lookup"><span data-stu-id="20e4a-434">Index key columns, excluding nonkeys, must follow the existing index size restrictions of 16 key columns maximum, and a total index key size of 900 bytes.</span></span>  
  
-   <span data-ttu-id="20e4a-435">Общий размер всех неключевых столбцов ограничен только размером столбцов, указанных в предложении INCLUDE, например столбцы `varchar(max)` могут иметь размер до 2 ГБ.</span><span class="sxs-lookup"><span data-stu-id="20e4a-435">The total size of all nonkey columns is limited only by the size of the columns specified in the INCLUDE clause; for example, `varchar(max)` columns are limited to 2 GB.</span></span>  
  
##### <a name="column-modification-guidelines"></a><span data-ttu-id="20e4a-436">Правила изменения столбца</span><span class="sxs-lookup"><span data-stu-id="20e4a-436">Column Modification Guidelines</span></span>  

 <span data-ttu-id="20e4a-437">При изменении столбца таблицы, определенного как включенный столбец, действуют следующие ограничения.</span><span class="sxs-lookup"><span data-stu-id="20e4a-437">When you modify a table column that has been defined as an included column, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="20e4a-438">Неключевые столбцы нельзя удалять из таблицы до удаления соответствующего индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-438">Nonkey columns cannot be dropped from the table unless the index is dropped first.</span></span>  
  
-   <span data-ttu-id="20e4a-439">Неключевые столбцы нельзя изменять, за исключением следующих операций:</span><span class="sxs-lookup"><span data-stu-id="20e4a-439">Nonkey columns cannot be changed, except to do the following:</span></span>  
  
    -   <span data-ttu-id="20e4a-440">изменение поведения столбца в отношении значения NULL с NOT NULL на NULL;</span><span class="sxs-lookup"><span data-stu-id="20e4a-440">Change the nullability of the column from NOT NULL to NULL.</span></span>  
  
    -   <span data-ttu-id="20e4a-441">Увеличение длины столбцов типов `varchar`, `nvarchar` и `varbinary`.</span><span class="sxs-lookup"><span data-stu-id="20e4a-441">Increase the length of `varchar`, `nvarchar`, or `varbinary` columns.</span></span>  
  
        > [!NOTE]  
        >  <span data-ttu-id="20e4a-442">Эти ограничения на изменение столбца также применяются к ключевым столбцам индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-442">These column modification restrictions also apply to index key columns.</span></span>  
  
##### <a name="design-recommendations"></a><span data-ttu-id="20e4a-443">Рекомендации по проектированию</span><span class="sxs-lookup"><span data-stu-id="20e4a-443">Design Recommendations</span></span>  

 <span data-ttu-id="20e4a-444">Переопределите некластеризованные индексы с большим размером ключа индекса, чтобы только столбцы, используемые для поиска и уточняющего запроса, были ключевыми.</span><span class="sxs-lookup"><span data-stu-id="20e4a-444">Redesign nonclustered indexes with a large index key size so that only columns used for searching and lookups are key columns.</span></span> <span data-ttu-id="20e4a-445">Все остальные столбцы, покрывающие запрос, сделайте включенными неключевыми столбцами.</span><span class="sxs-lookup"><span data-stu-id="20e4a-445">Make all other columns that cover the query included nonkey columns.</span></span> <span data-ttu-id="20e4a-446">Таким образом, в наличии будут все столбцы, покрывающие запрос, но сам ключ индекса будет небольшим и эффективным.</span><span class="sxs-lookup"><span data-stu-id="20e4a-446">In this way, you will have all columns needed to cover the query, but the index key itself is small and efficient.</span></span>  
  
 <span data-ttu-id="20e4a-447">Например, нужно спроектировать индекс, покрывающий следующий запрос:</span><span class="sxs-lookup"><span data-stu-id="20e4a-447">For example, assume that you want to design an index to cover the following query.</span></span>  
  
```sql
SELECT AddressLine1, AddressLine2, City, StateProvinceID, PostalCode  
FROM Person.Address  
WHERE PostalCode BETWEEN N'98000' and N'99999';  
```  
  
 <span data-ttu-id="20e4a-448">Для покрытия запроса необходимо включить в индекс все его столбцы.</span><span class="sxs-lookup"><span data-stu-id="20e4a-448">To cover the query, each column must be defined in the index.</span></span> <span data-ttu-id="20e4a-449">Хотя можно определить все столбцы как ключевые, размер ключа составит 334 байт.</span><span class="sxs-lookup"><span data-stu-id="20e4a-449">Although you could define all columns as key columns, the key size would be 334 bytes.</span></span> <span data-ttu-id="20e4a-450">Поскольку в качестве критерия поиска реально используется только столбец `PostalCode` , имеющий длину 30 байт, более эффективный индекс определит `PostalCode` в качестве ключевого столбца, а все остальные столбцы включит как неключевые.</span><span class="sxs-lookup"><span data-stu-id="20e4a-450">Because the only column actually used as search criteria is the `PostalCode` column, having a length of 30 bytes, a better index design would define `PostalCode` as the key column and include all other columns as nonkey columns.</span></span>  
  
 <span data-ttu-id="20e4a-451">Следующая инструкция создает индекс с включенными столбцами, покрывающий данный запрос.</span><span class="sxs-lookup"><span data-stu-id="20e4a-451">The following statement creates an index with included columns to cover the query.</span></span>  
  
```sql
CREATE INDEX IX_Address_PostalCode  
ON Person.Address (PostalCode)  
INCLUDE (AddressLine1, AddressLine2, City, StateProvinceID);  
```  
  
##### <a name="performance-considerations"></a><span data-ttu-id="20e4a-452">Вопросы производительности</span><span class="sxs-lookup"><span data-stu-id="20e4a-452">Performance Considerations</span></span>  

 <span data-ttu-id="20e4a-453">Избегайте добавления неиспользуемых столбцов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-453">Avoid adding unnecessary columns.</span></span> <span data-ttu-id="20e4a-454">Добавление слишком большого количества столбцов, ключевых или неключевых, может оказать следующее влияние на производительность.</span><span class="sxs-lookup"><span data-stu-id="20e4a-454">Adding too many index columns, key or nonkey, can have the following performance implications:</span></span>  
  
-   <span data-ttu-id="20e4a-455">На странице будет помещаться меньше строк индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-455">Fewer index rows will fit on a page.</span></span> <span data-ttu-id="20e4a-456">Это может привести к увеличению количества операций ввода-вывода и снизить эффективность кэша.</span><span class="sxs-lookup"><span data-stu-id="20e4a-456">This could create I/O increases and reduced cache efficiency.</span></span>  
  
-   <span data-ttu-id="20e4a-457">Увеличение места на диске, требуемого для хранения индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-457">More disk space will be required to store the index.</span></span> <span data-ttu-id="20e4a-458">В частности, добавление типов данных `varchar(max)`, `nvarchar(max)`, `varbinary(max)` и `xml` в качестве неключевых индексных столбцов может значительно повысить требования к месту на диске.</span><span class="sxs-lookup"><span data-stu-id="20e4a-458">In particular, adding `varchar(max)`, `nvarchar(max)`, `varbinary(max)`, or `xml` data types as nonkey index columns may significantly increase disk space requirements.</span></span> <span data-ttu-id="20e4a-459">Это обусловлено тем, что значения столбцов копируются на конечный уровень индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-459">This is because the column values are copied into the index leaf level.</span></span> <span data-ttu-id="20e4a-460">Поэтому они находятся и в индексе, и в базовой таблице.</span><span class="sxs-lookup"><span data-stu-id="20e4a-460">Therefore, they reside in both the index and the base table.</span></span>  
  
-   <span data-ttu-id="20e4a-461">Обслуживание индекса может увеличить время выполнения операций изменения, вставки, обновления и удаления в базовой таблице или индексированном представлении.</span><span class="sxs-lookup"><span data-stu-id="20e4a-461">Index maintenance may increase the time that it takes to perform modifications, inserts, updates, or deletes, to the underlying table or indexed view.</span></span>  
  
 <span data-ttu-id="20e4a-462">Необходимо определить, что важнее — повышение производительности запросов или производительность при изменении данных и дополнительные требования к месту на диске.</span><span class="sxs-lookup"><span data-stu-id="20e4a-462">You will have to determine whether the gains in query performance outweigh the affect to performance during data modification and in additional disk space requirements.</span></span>  
  
 <span data-ttu-id="20e4a-463">![Значок стрелки, используемый в ссылке "назад на начало](media/uparrow16x16.gif "Значок стрелки, используемый со ссылкой В начало") " [в этом пошаговом окне](#Top)</span><span class="sxs-lookup"><span data-stu-id="20e4a-463">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="unique-index-design-guidelines"></a><a name="Unique"></a> <span data-ttu-id="20e4a-464">Правила по созданию уникальных индексов</span><span class="sxs-lookup"><span data-stu-id="20e4a-464">Unique Index Design Guidelines</span></span>  

 <span data-ttu-id="20e4a-465">Уникальный индекс гарантирует, что ключ индекса не будет содержать одинаковых значений, а значит, каждая строка в таблице будет уникальна.</span><span class="sxs-lookup"><span data-stu-id="20e4a-465">A unique index guarantees that the index key contains no duplicate values and therefore every row in the table is in some way unique.</span></span> <span data-ttu-id="20e4a-466">Создание уникального индекса имеет смысл, только если данные сами по себе могут быть уникальными.</span><span class="sxs-lookup"><span data-stu-id="20e4a-466">Specifying a unique index makes sense only when uniqueness is a characteristic of the data itself.</span></span> <span data-ttu-id="20e4a-467">Например, если требуется обеспечить уникальность значений в столбце `NationalIDNumber` из таблицы `HumanResources.Employee` , когда первичным ключом является `EmployeeID`, создайте ограничение UNIQUE для столбца `NationalIDNumber` .</span><span class="sxs-lookup"><span data-stu-id="20e4a-467">For example, if you want to make sure that the values in the `NationalIDNumber` column in the `HumanResources.Employee` table are unique, when the primary key is `EmployeeID`, create a UNIQUE constraint on the `NationalIDNumber` column.</span></span> <span data-ttu-id="20e4a-468">Если пользователь попытается ввести в этот столбец одно и тоже значение для нескольких сотрудников, появится сообщение об ошибке, а дублирующие данные не будут сохранены.</span><span class="sxs-lookup"><span data-stu-id="20e4a-468">If the user tries to enter the same value in that column for more than one employee, an error message is displayed and the duplicate value is not entered.</span></span>  
  
 <span data-ttu-id="20e4a-469">В случае уникальных индексов по нескольким столбцам индекс гарантирует, что каждая комбинация значений в ключе индекса уникальна.</span><span class="sxs-lookup"><span data-stu-id="20e4a-469">With multicolumn unique indexes, the index guarantees that each combination of values in the index key is unique.</span></span> <span data-ttu-id="20e4a-470">Например, если уникальный индекс создан для комбинации столбцов `LastName`, `FirstName`и `MiddleName` , то никакие две строки в таблице не могут образовывать одну и ту же комбинацию этих значений.</span><span class="sxs-lookup"><span data-stu-id="20e4a-470">For example, if a unique index is created on a combination of `LastName`, `FirstName`, and `MiddleName` columns, no two rows in the table could have the same combination of values for these columns.</span></span>  
  
 <span data-ttu-id="20e4a-471">Как кластеризованные, так и некластеризованные индексы могут быть уникальными.</span><span class="sxs-lookup"><span data-stu-id="20e4a-471">Both clustered and nonclustered indexes can be unique.</span></span> <span data-ttu-id="20e4a-472">Учитывая, что данные в столбце уникальны, можно создать уникальный кластеризованный индекс и несколько уникальных некластеризованных индексов для одной и той же таблицы.</span><span class="sxs-lookup"><span data-stu-id="20e4a-472">Provided that the data in the column is unique, you can create both a unique clustered index and multiple unique nonclustered indexes on the same table.</span></span>  
  
 <span data-ttu-id="20e4a-473">Уникальные индексы имеют следующие преимущества:</span><span class="sxs-lookup"><span data-stu-id="20e4a-473">The benefits of unique indexes include the following:</span></span>  
  
-   <span data-ttu-id="20e4a-474">Гарантируется целостность данных в определенных столбцах.</span><span class="sxs-lookup"><span data-stu-id="20e4a-474">Data integrity of the defined columns is ensured.</span></span>  
  
-   <span data-ttu-id="20e4a-475">Предоставляются дополнительные сведения, полезные оптимизатору запросов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-475">Additional information helpful to the query optimizer is provided.</span></span>  
  
 <span data-ttu-id="20e4a-476">Создание ограничений PRIMARY KEY или UNIQUE автоматически создает уникальный индекс для заданных столбцов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-476">Creating a PRIMARY KEY or UNIQUE constraint automatically creates a unique index on the specified columns.</span></span> <span data-ttu-id="20e4a-477">Между созданием ограничения UNIQUE и созданием уникального индекса независимо от ограничения больших различий нет.</span><span class="sxs-lookup"><span data-stu-id="20e4a-477">There are no significant differences between creating a UNIQUE constraint and creating a unique index independent of a constraint.</span></span> <span data-ttu-id="20e4a-478">Проверка данных происходит подобным же образом, и оптимизатор запросов не делает различия между уникальным индексом, который создан ограничением, и индексом, созданным вручную.</span><span class="sxs-lookup"><span data-stu-id="20e4a-478">Data validation occurs in the same manner and the query optimizer does not differentiate between a unique index created by a constraint or manually created.</span></span> <span data-ttu-id="20e4a-479">Однако на столбцы, для которых важна целостность данных, следует накладывать ограничение UNIQUE или PRIMARY KEY.</span><span class="sxs-lookup"><span data-stu-id="20e4a-479">However, you should create a UNIQUE or PRIMARY KEY constraint on the column when data integrity is the objective.</span></span> <span data-ttu-id="20e4a-480">Тогда цель создания индекса будет ясна.</span><span class="sxs-lookup"><span data-stu-id="20e4a-480">By doing this the objective of the index will be clear.</span></span>  
  
### <a name="considerations"></a><span data-ttu-id="20e4a-481">Рекомендации</span><span class="sxs-lookup"><span data-stu-id="20e4a-481">Considerations</span></span>  
  
-   <span data-ttu-id="20e4a-482">Уникальный индекс и ограничения UNIQUE и PRIMARY KEY не могут быть созданы, если дублирующиеся значения уже существуют.</span><span class="sxs-lookup"><span data-stu-id="20e4a-482">A unique index, UNIQUE constraint, or PRIMARY KEY constraint cannot be created if duplicate key values exist in the data.</span></span>  
  
-   <span data-ttu-id="20e4a-483">Если данные уникальны и если нужно и далее требовать этой уникальности, создание уникального индекса вместо неуникального для тех же сочетаний столбцов предоставит дополнительные сведения оптимизатору запросов, который может создать более эффективные планы выполнения.</span><span class="sxs-lookup"><span data-stu-id="20e4a-483">If the data is unique and you want uniqueness enforced, creating a unique index instead of a nonunique index on the same combination of columns provides additional information for the query optimizer that can produce more efficient execution plans.</span></span> <span data-ttu-id="20e4a-484">В этом случае рекомендуется создание уникального индекса (предпочтительнее через ограничение UNIQUE).</span><span class="sxs-lookup"><span data-stu-id="20e4a-484">Creating a unique index (preferably by creating a UNIQUE constraint) is recommended in this case.</span></span>  
  
-   <span data-ttu-id="20e4a-485">Уникальный некластеризованный индекс может содержать любые неключевые столбцы.</span><span class="sxs-lookup"><span data-stu-id="20e4a-485">A unique nonclustered index can contain included nonkey columns.</span></span> <span data-ttu-id="20e4a-486">Дополнительные сведения о включенных столбцах см. в разделе [Индекс с включенными столбцами](#Included_Columns).</span><span class="sxs-lookup"><span data-stu-id="20e4a-486">For more information, see [Index with Included Columns](#Included_Columns).</span></span>  
  
 <span data-ttu-id="20e4a-487">![Значок стрелки, используемый в ссылке "назад на начало](media/uparrow16x16.gif "Значок стрелки, используемый со ссылкой В начало") " [в этом пошаговом окне](#Top)</span><span class="sxs-lookup"><span data-stu-id="20e4a-487">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="filtered-index-design-guidelines"></a><a name="Filtered"></a> <span data-ttu-id="20e4a-488">Рекомендации по проектированию отфильтрованных индексов</span><span class="sxs-lookup"><span data-stu-id="20e4a-488">Filtered Index Design Guidelines</span></span>  

 <span data-ttu-id="20e4a-489">Отфильтрованный индекс — это оптимизированный некластеризованный индекс, особенно подходящий для запросов, осуществляющих выборку из хорошо определенного подмножества данных.</span><span class="sxs-lookup"><span data-stu-id="20e4a-489">A filtered index is an optimized nonclustered index, especially suited to cover queries that select from a well-defined subset of data.</span></span> <span data-ttu-id="20e4a-490">Он использует предикат фильтра для индексирования части строк в таблице.</span><span class="sxs-lookup"><span data-stu-id="20e4a-490">It uses a filter predicate to index a portion of rows in the table.</span></span> <span data-ttu-id="20e4a-491">Хорошо спроектированный отфильтрованный индекс позволяет повысить производительность запросов, снизить затраты на обслуживание и хранение индексов по сравнению с полнотабличными индексами.</span><span class="sxs-lookup"><span data-stu-id="20e4a-491">A well-designed filtered index can improve query performance, reduce index maintenance costs, and reduce index storage costs compared with full-table indexes.</span></span>  
  
||  
|-|  
|<span data-ttu-id="20e4a-492">**Применимо к**: с [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] до [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span><span class="sxs-lookup"><span data-stu-id="20e4a-492">**Applies to**: [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] through [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span>|  
  
 <span data-ttu-id="20e4a-493">Отфильтрованные индексы могут предоставить следующие преимущества по сравнению с индексами, построенными на всей таблице.</span><span class="sxs-lookup"><span data-stu-id="20e4a-493">Filtered indexes can provide the following advantages over full-table indexes:</span></span>  
  
-   <span data-ttu-id="20e4a-494">**Улучшение производительности запроса и качества плана**</span><span class="sxs-lookup"><span data-stu-id="20e4a-494">**Improved query performance and plan quality**</span></span>  
  
     <span data-ttu-id="20e4a-495">Хорошо спроектированный отфильтрованный индекс повышает производительность запроса и качество плана выполнения, поскольку он меньше, чем полнотабличный некластеризованный индекс, и содержит отфильтрованную статистику.</span><span class="sxs-lookup"><span data-stu-id="20e4a-495">A well-designed filtered index improves query performance and execution plan quality because it is smaller than a full-table nonclustered index and has filtered statistics.</span></span> <span data-ttu-id="20e4a-496">Отфильтрованная статистика точнее полнотабличной статистики, так как содержит только строки отфильтрованного индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-496">The filtered statistics are more accurate than full-table statistics because they cover only the rows in the filtered index.</span></span>  
  
-   <span data-ttu-id="20e4a-497">**Снижение расходов на обслуживание индекса**</span><span class="sxs-lookup"><span data-stu-id="20e4a-497">**Reduced index maintenance costs**</span></span>  
  
     <span data-ttu-id="20e4a-498">Индекс обслуживается только в случае, если инструкции языка обработки данных (DML) затрагивают данные в индексе.</span><span class="sxs-lookup"><span data-stu-id="20e4a-498">An index is maintained only when data manipulation language (DML) statements affect the data in the index.</span></span> <span data-ttu-id="20e4a-499">Отфильтрованный индекс уменьшает расходы на обслуживание индекса по сравнению с полнотабличным некластеризованным индексом, поскольку он меньше и обслуживается только при изменении данных в индексе.</span><span class="sxs-lookup"><span data-stu-id="20e4a-499">A filtered index reduces index maintenance costs compared with a full-table nonclustered index because it is smaller and is only maintained when the data in the index is affected.</span></span> <span data-ttu-id="20e4a-500">Возможно наличие большого числа отфильтрованных индексов, особенно если они содержат редко изменяющиеся данные.</span><span class="sxs-lookup"><span data-stu-id="20e4a-500">It is possible to have a large number of filtered indexes, especially when they contain data that is affected infrequently.</span></span> <span data-ttu-id="20e4a-501">Аналогично, если отфильтрованный индекс содержит только часто изменяемые данные, меньший размер индекса уменьшает затраты на обновление статистики.</span><span class="sxs-lookup"><span data-stu-id="20e4a-501">Similarly, if a filtered index contains only the frequently affected data, the smaller size of the index reduces the cost of updating the statistics.</span></span>  
  
-   <span data-ttu-id="20e4a-502">**Снижение затрат на хранение индекса**</span><span class="sxs-lookup"><span data-stu-id="20e4a-502">**Reduced index storage costs**</span></span>  
  
     <span data-ttu-id="20e4a-503">Создание отфильтрованного индекса может уменьшить место на диске для некластеризованных индексов, если нет необходимости в полнотабличном индексе.</span><span class="sxs-lookup"><span data-stu-id="20e4a-503">Creating a filtered index can reduce disk storage for nonclustered indexes when a full-table index is not necessary.</span></span> <span data-ttu-id="20e4a-504">Полнотабличный некластеризованный индекс можно заменить несколькими отфильтрованными индексами без значительного увеличения требований к хранилищу.</span><span class="sxs-lookup"><span data-stu-id="20e4a-504">You can replace a full-table nonclustered index with multiple filtered indexes without significantly increasing the storage requirements.</span></span>  
  
 <span data-ttu-id="20e4a-505">Отфильтрованные индексы полезны, когда столбцы содержат хорошо определенные подмножества данных, указанных в инструкциях SELECT.</span><span class="sxs-lookup"><span data-stu-id="20e4a-505">Filtered indexes are useful when columns contain well-defined subsets of data that queries reference in SELECT statements.</span></span> <span data-ttu-id="20e4a-506">Примеры:</span><span class="sxs-lookup"><span data-stu-id="20e4a-506">Examples are:</span></span>  
  
-   <span data-ttu-id="20e4a-507">Разреженные столбцы, содержащие небольшое количество значений, отличных от NULL.</span><span class="sxs-lookup"><span data-stu-id="20e4a-507">Sparse columns that contain only a few non-NULL values.</span></span>  
  
-   <span data-ttu-id="20e4a-508">Разнородные столбцы, содержащие категории данных.</span><span class="sxs-lookup"><span data-stu-id="20e4a-508">Heterogeneous columns that contain categories of data.</span></span>  
  
-   <span data-ttu-id="20e4a-509">Столбцы, содержащие диапазоны значений, таких как количество долларов, время и даты.</span><span class="sxs-lookup"><span data-stu-id="20e4a-509">Columns that contain ranges of values such as dollar amounts, time, and dates.</span></span>  
  
-   <span data-ttu-id="20e4a-510">Секции таблицы, определенные логикой простого сравнения для значений столбцов.</span><span class="sxs-lookup"><span data-stu-id="20e4a-510">Table partitions that are defined by simple comparison logic for column values.</span></span>  
  
 <span data-ttu-id="20e4a-511">Снижение затрат на обслуживание отфильтрованного индекса более заметно, когда количество строк в индексе является небольшим по сравнению с полнотабличным индексом.</span><span class="sxs-lookup"><span data-stu-id="20e4a-511">Reduced maintenance costs for filtered indexes are most noticeable when the number of rows in the index is small compared with a full-table index.</span></span> <span data-ttu-id="20e4a-512">Если отфильтрованный индекс включает большую часть строк в таблице, его обслуживание может быть более затратным по сравнению с полнотабличным индексом.</span><span class="sxs-lookup"><span data-stu-id="20e4a-512">If the filtered index includes most of the rows in the table, it could cost more to maintain than a full-table index.</span></span> <span data-ttu-id="20e4a-513">В этом случае нужно использовать полнотабличный индекс вместо отфильтрованного.</span><span class="sxs-lookup"><span data-stu-id="20e4a-513">In this case, you should use a full-table index instead of a filtered index.</span></span>  
  
 <span data-ttu-id="20e4a-514">Отфильтрованные индексы определены в одной таблице и поддерживают только простые операторы сравнения.</span><span class="sxs-lookup"><span data-stu-id="20e4a-514">Filtered indexes are defined on one table and only support simple comparison operators.</span></span> <span data-ttu-id="20e4a-515">Если необходим критерий фильтра, который ссылается на множество таблиц или имеет сложную логику, нужно создать представление.</span><span class="sxs-lookup"><span data-stu-id="20e4a-515">If you need a filter expression that references multiple tables or has complex logic, you should create a view.</span></span>  
  
### <a name="design-considerations"></a><span data-ttu-id="20e4a-516">Вопросы проектирования</span><span class="sxs-lookup"><span data-stu-id="20e4a-516">Design Considerations</span></span>  

 <span data-ttu-id="20e4a-517">Для разработки эффективных отфильтрованных индексов важно понимать, какие запросы приложения используются и как они связаны с подмножествами данных.</span><span class="sxs-lookup"><span data-stu-id="20e4a-517">In order to design effective filtered indexes, it is important to understand what queries your application uses and how they relate to subsets of your data.</span></span> <span data-ttu-id="20e4a-518">Некоторые примеры данных, имеющих точно определенные подмножества, являются столбцами, содержащими в основном значения NULL, столбцами с разнородными категориями и столбцами с различными диапазонами значений.</span><span class="sxs-lookup"><span data-stu-id="20e4a-518">Some examples of data that have well-defined subsets are columns with mostly NULL values, columns with heterogeneous categories of values and columns with distinct ranges of values.</span></span> <span data-ttu-id="20e4a-519">Далее приведены различные сценарии, в которых отфильтрованный индекс дает преимущества над полнотабличными индексами.</span><span class="sxs-lookup"><span data-stu-id="20e4a-519">The following design considerations give a variety of scenarios for when a filtered index can provide advantages over full-table indexes.</span></span>  
  
#### <a name="filtered-indexes-for-subsets-of-data"></a><span data-ttu-id="20e4a-520">Отфильтрованные индексы для подмножеств данных</span><span class="sxs-lookup"><span data-stu-id="20e4a-520">Filtered Indexes for Subsets of Data</span></span>  

 <span data-ttu-id="20e4a-521">Если столбец содержит только небольшое число удовлетворяющих запросу значений, можно создать отфильтрованный индекс на этом подмножестве значений.</span><span class="sxs-lookup"><span data-stu-id="20e4a-521">When a column only has a small number of relevant values for queries, you can create a filtered index on the subset of values.</span></span> <span data-ttu-id="20e4a-522">Например, если столбец содержит в основном значения NULL, а запрос выбирает только из значений, отличных от NULL, можно создать отфильтрованный индекс для строк данных, отличных от NULL.</span><span class="sxs-lookup"><span data-stu-id="20e4a-522">For example, when the values in a column are mostly NULL and the query selects only from the non-NULL values, you can create a filtered index for the non-NULL data rows.</span></span> <span data-ttu-id="20e4a-523">В результате индекс уменьшится и затраты на его обслуживание будут значительно меньше, чем для полнотабличного некластеризованного индекса на тех же ключевых столбцах.</span><span class="sxs-lookup"><span data-stu-id="20e4a-523">The resulting index will be smaller and cost less to maintain than a full-table nonclustered index defined on the same key columns.</span></span>  
  
 <span data-ttu-id="20e4a-524">Например, база данных `AdventureWorks2012` содержит таблицу `Production.BillOfMaterials` с 2679 строками.</span><span class="sxs-lookup"><span data-stu-id="20e4a-524">For example, the `AdventureWorks2012` database has a `Production.BillOfMaterials` table with 2679 rows.</span></span> <span data-ttu-id="20e4a-525">Столбец `EndDate` содержит только 199 строк, содержащих значения, отличные от NULL, и 2 480 строк, содержащих значение NULL.</span><span class="sxs-lookup"><span data-stu-id="20e4a-525">The `EndDate` column has only 199 rows that contain a non-NULL value and the other 2480 rows contain NULL.</span></span> <span data-ttu-id="20e4a-526">Следующий отфильтрованный индекс может перекрывать запросы, которые возвращают столбцы, указанные в индексе, и выбирают только строки, содержащие значения `EndDate`, отличные от NULL.</span><span class="sxs-lookup"><span data-stu-id="20e4a-526">The following filtered index would cover queries that return the columns defined in the index and that select only rows with a non-NULL value for `EndDate`.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX FIBillOfMaterialsWithEndDate  
    ON Production.BillOfMaterials (ComponentID, StartDate)  
    WHERE EndDate IS NOT NULL ;  
GO  
```  
  
 <span data-ttu-id="20e4a-527">Отфильтрованный индекс `FIBillOfMaterialsWithEndDate` допустим для следующего запроса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-527">The filtered index `FIBillOfMaterialsWithEndDate` is valid for the following query.</span></span> <span data-ttu-id="20e4a-528">Можно отобразить план выполнения запроса для проверки того, использует ли оптимизатор запросов отфильтрованный индекс.</span><span class="sxs-lookup"><span data-stu-id="20e4a-528">You can display the query execution plan to determine if the query optimizer used the filtered index.</span></span>  
  
```sql
SELECT ProductAssemblyID, ComponentID, StartDate   
FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL   
    AND ComponentID = 5   
    AND StartDate > '20080101' ;  
```  
  
 <span data-ttu-id="20e4a-529">Дополнительные сведения о создании отфильтрованного индекса и об определении выражения предиката отфильтрованного индекса см. в разделе [Create Filtered Indexes](../relational-databases/indexes/create-filtered-indexes.md).</span><span class="sxs-lookup"><span data-stu-id="20e4a-529">For more information about how to create filtered indexes and how to define the filtered index predicate expression, see [Create Filtered Indexes](../relational-databases/indexes/create-filtered-indexes.md).</span></span>  
  
#### <a name="filtered-indexes-for-heterogeneous-data"></a><span data-ttu-id="20e4a-530">Отфильтрованные индексы для разнородных данных</span><span class="sxs-lookup"><span data-stu-id="20e4a-530">Filtered Indexes for Heterogeneous Data</span></span>  

 <span data-ttu-id="20e4a-531">Если таблица содержит строки с разнородными данными, можно создать отфильтрованный индекс для одной или более категорий данных.</span><span class="sxs-lookup"><span data-stu-id="20e4a-531">When a table has heterogeneous data rows, you can create a filtered index for one or more categories of data.</span></span>  
  
 <span data-ttu-id="20e4a-532">Например, продукты, содержащиеся в таблице `Production.Product` , связаны с идентификатором `ProductSubcategoryID`, который в свою очередь связан с категориями продуктов, такими как велосипеды, запчасти, одежда или аксессуары.</span><span class="sxs-lookup"><span data-stu-id="20e4a-532">For example, the products listed in the `Production.Product` table are each assigned to a `ProductSubcategoryID`, which are in turn associated with the product categories Bikes, Components, Clothing, or Accessories.</span></span> <span data-ttu-id="20e4a-533">Эти категории являются разнородными, так как значения их столбцов в таблице `Production.Product` не являются близко коррелирующими.</span><span class="sxs-lookup"><span data-stu-id="20e4a-533">These categories are heterogeneous because their column values in the `Production.Product` table are not closely correlated.</span></span> <span data-ttu-id="20e4a-534">Например, столбцы `Color`, `ReorderPoint`, `ListPrice`, `Weight`, `Class`и `Style` имеют уникальные характеристики для каждой категории продукта.</span><span class="sxs-lookup"><span data-stu-id="20e4a-534">For example, the columns `Color`, `ReorderPoint`, `ListPrice`, `Weight`, `Class`, and `Style` have unique characteristics for each product category.</span></span> <span data-ttu-id="20e4a-535">Предположим, что существуют частые запросы на аксессуары, имеющие подкатегории с 27 по 36 включительно.</span><span class="sxs-lookup"><span data-stu-id="20e4a-535">Suppose that there are frequent queries for accessories which have subcategories between 27 and 36 inclusive.</span></span> <span data-ttu-id="20e4a-536">Можно повысить результативность запросов на аксессуары, создав отфильтрованный индекс по подкатегориям аксессуаров, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="20e4a-536">You can improve the performance of queries for accessories by creating a filtered index on the accessories subcategories as shown in the following example.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX FIProductAccessories  
    ON Production.Product (ProductSubcategoryID, ListPrice)   
        Include (Name)  
WHERE ProductSubcategoryID >= 27 AND ProductSubcategoryID <= 36;
```  
  
 <span data-ttu-id="20e4a-537">Отфильтрованный индекс `FIProductAccessories` включает следующий запрос, поскольку результаты</span><span class="sxs-lookup"><span data-stu-id="20e4a-537">The filtered index `FIProductAccessories` covers the following query because the query</span></span>  
  
 <span data-ttu-id="20e4a-538">запроса содержатся в индексе, а план запроса не включает в себя поиск в базовых таблицах.</span><span class="sxs-lookup"><span data-stu-id="20e4a-538">results are contained in the index and the query plan does not include a base table lookup.</span></span> <span data-ttu-id="20e4a-539">Например, выражение предиката запроса `ProductSubcategoryID = 33` — это подмножество предиката отфильтрованного индекса `ProductSubcategoryID >= 27` и `ProductSubcategoryID <= 36`, а столбцы `ProductSubcategoryID` и `ListPrice` в предикате запроса являются ключевыми столбцами в индексе. Имя сохраняется на конечном уровне индекса в качестве включенного столбца.</span><span class="sxs-lookup"><span data-stu-id="20e4a-539">For example, the query predicate expression `ProductSubcategoryID = 33` is a subset of the filtered index predicate `ProductSubcategoryID >= 27` and `ProductSubcategoryID <= 36`, the `ProductSubcategoryID` and `ListPrice` columns in the query predicate are both key columns in the index, and name is stored in the leaf level of the index as an included column.</span></span>  
  
```sql
SELECT Name, ProductSubcategoryID, ListPrice  
FROM Production.Product  
WHERE ProductSubcategoryID = 33 AND ListPrice > 25.00 ;  
```  
  
#### <a name="key-columns"></a><span data-ttu-id="20e4a-540">Ключевые столбцы</span><span class="sxs-lookup"><span data-stu-id="20e4a-540">Key Columns</span></span>  

 <span data-ttu-id="20e4a-541">Это лучший способ включения небольшого количества ключевых или включенных столбцов в определение отфильтрованного индекса и включения только столбцов, необходимых для оптимизатора запросов при выборе отфильтрованного индекса для плана выполнения запроса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-541">It is a best practice to include a small number of key or included columns in a filtered index definition, and to incorporate only the columns that are necessary for the query optimizer to choose the filtered index for the query execution plan.</span></span> <span data-ttu-id="20e4a-542">Оптимизатор запросов может выбрать отфильтрованный индекс независимо от того, перекрывает он запрос или нет.</span><span class="sxs-lookup"><span data-stu-id="20e4a-542">The query optimizer can choose a filtered index for the query regardless of whether it does or does not cover the query.</span></span> <span data-ttu-id="20e4a-543">Однако оптимизатор запросов с большей вероятностью выберет отфильтрованный индекс, если он перекрывает запрос.</span><span class="sxs-lookup"><span data-stu-id="20e4a-543">However, the query optimizer is more likely to choose a filtered index if it covers the query.</span></span>  
  
 <span data-ttu-id="20e4a-544">В некоторых случаях отфильтрованный индекс перекрывает запрос, не включая в определение отфильтрованного индекса в качестве ключевых или включенных столбцов столбцы из выражения отфильтрованного индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-544">In some cases, a filtered index covers the query without including the columns in the filtered index expression as key or included columns in the filtered index definition.</span></span> <span data-ttu-id="20e4a-545">Следующие правила содержат описание того, должен ли быть столбец в выражении отфильтрованного индекса ключевым или включенным столбцом в определении отфильтрованного индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-545">The following guidelines explain when a column in the filtered index expression should be a key or included column in the filtered index definition.</span></span> <span data-ttu-id="20e4a-546">В примерах используется ранее созданный отфильтрованный индекс `FIBillOfMaterialsWithEndDate` .</span><span class="sxs-lookup"><span data-stu-id="20e4a-546">The examples refer to the filtered index, `FIBillOfMaterialsWithEndDate` that was created previously.</span></span>  
  
 <span data-ttu-id="20e4a-547">Столбец в выражении отфильтрованного индекса не обязательно должен быть ключевым или включенным столбцом в определении отфильтрованного индекса, если выражение отфильтрованного индекса эквивалентно предикату запроса, а запрос не возвращает столбец с результатами запроса в выражение отфильтрованного индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-547">A column in the filtered index expression does not need to be a key or included column in the filtered index definition if the filtered index expression is equivalent to the query predicate and the query does not return the column in the filtered index expression with the query results.</span></span> <span data-ttu-id="20e4a-548">Например, значение `FIBillOfMaterialsWithEndDate` охватывает следующий запрос, поскольку предикат запроса эквивалентен критерию фильтра, а возврат `EndDate` с результатами запроса не происходит.</span><span class="sxs-lookup"><span data-stu-id="20e4a-548">For example, `FIBillOfMaterialsWithEndDate` covers the following query because the query predicate is equivalent to the filter expression, and `EndDate` is not returned with the query results.</span></span> <span data-ttu-id="20e4a-549">`FIBillOfMaterialsWithEndDate` не требуется `EndDate` в качестве ключа или включенного столбца в определении отфильтрованного индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-549">`FIBillOfMaterialsWithEndDate` does not need `EndDate` as a key or included column in the filtered index definition.</span></span>  
  
```sql
SELECT ComponentID, StartDate FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL;   
```  
  
 <span data-ttu-id="20e4a-550">Столбец в выражении отфильтрованного индекса должен быть ключевым или включенным столбцом в определении отфильтрованного индекса, если предикат запроса использует в сравнении столбец, который не эквивалентен выражению отфильтрованного индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-550">A column in the filtered index expression should be a key or included column in the filtered index definition if the query predicate uses the column in a comparison that is not equivalent to the filtered index expression.</span></span> <span data-ttu-id="20e4a-551">Например, отфильтрованный индекс `FIBillOfMaterialsWithEndDate` допустим для следующего запроса, поскольку этот запрос выбирает подмножество строк из отфильтрованного индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-551">For example, `FIBillOfMaterialsWithEndDate` is valid for the following query because it selects a subset of rows from the filtered index.</span></span> <span data-ttu-id="20e4a-552">Однако он не перекрывает следующий запрос, поскольку столбец `EndDate` используется в сравнении `EndDate > '20040101'`, не эквивалентном выражению отфильтрованного индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-552">However, it does not cover the following query because `EndDate` is used in the comparison `EndDate > '20040101'`, which is not equivalent to the filtered index expression.</span></span> <span data-ttu-id="20e4a-553">Обработчик запросов не может выполнить запрос без поиска значений `EndDate`.</span><span class="sxs-lookup"><span data-stu-id="20e4a-553">The query processor cannot execute this query without looking up the values of `EndDate`.</span></span> <span data-ttu-id="20e4a-554">Поэтому в определении отфильтрованного индекса `EndDate` должен быть ключевым или включенным столбцом.</span><span class="sxs-lookup"><span data-stu-id="20e4a-554">Therefore, `EndDate` should be a key or included column in the filtered index definition.</span></span>  
  
```sql
SELECT ComponentID, StartDate FROM Production.BillOfMaterials  
WHERE EndDate > '20040101';   
```  
  
 <span data-ttu-id="20e4a-555">Столбец в выражении отфильтрованного индекса должен быть ключевым или включенным столбцом в определении отфильтрованного индекса, если этот столбец содержится в результирующем наборе запроса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-555">A column in the filtered index expression should be a key or included column in the filtered index definition if the column is in the query result set.</span></span> <span data-ttu-id="20e4a-556">Например, отфильтрованный индекс `FIBillOfMaterialsWithEndDate` не перекрывает следующий запрос, поскольку тот возвращает столбец `EndDate` в результате запроса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-556">For example, `FIBillOfMaterialsWithEndDate` does not cover the following query because it returns the `EndDate` column in the query results.</span></span> <span data-ttu-id="20e4a-557">Поэтому в определении отфильтрованного индекса `EndDate` должен быть ключевым или включенным столбцом.</span><span class="sxs-lookup"><span data-stu-id="20e4a-557">Therefore, `EndDate` should be a key or included column in the filtered index definition.</span></span>  
  
```sql
SELECT ComponentID, StartDate, EndDate FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL;  
```  
  
 <span data-ttu-id="20e4a-558">Ключ кластеризованного индекса таблицы необязательно должен быть ключевым или включенным столбцом в определении отфильтрованного индекса.</span><span class="sxs-lookup"><span data-stu-id="20e4a-558">The clustered index key of the table does not need to be a key or included column in the filtered index definition.</span></span> <span data-ttu-id="20e4a-559">Ключ кластеризованного индекса автоматически включается во все некластеризованные индексы, в том числе отфильтрованные индексы.</span><span class="sxs-lookup"><span data-stu-id="20e4a-559">The clustered index key is automatically included in all nonclustered indexes, including filtered indexes.</span></span>  
  
#### <a name="data-conversion-operators-in-the-filter-predicate"></a><span data-ttu-id="20e4a-560">Операторы преобразования данных в предикате фильтра</span><span class="sxs-lookup"><span data-stu-id="20e4a-560">Data Conversion Operators in the Filter Predicate</span></span>  

 <span data-ttu-id="20e4a-561">Если оператор сравнения определен в выражении отфильтрованного индекса результатов отфильтрованного индекса в неявном или явном преобразовании данных, произойдет ошибка, если преобразование выполняется в левой части оператора сравнения.</span><span class="sxs-lookup"><span data-stu-id="20e4a-561">If the comparison operator specified in the filtered index expression of the filtered index results in an implicit or explicit data conversion, an error will occur if the conversion occurs on the left side of a comparison operator.</span></span> <span data-ttu-id="20e4a-562">Решением является применение выражения отфильтрованного индекса с оператором преобразования данных (CAST или CONVERT) в правой части оператора сравнения.</span><span class="sxs-lookup"><span data-stu-id="20e4a-562">A solution is to write the filtered index expression with the data conversion operator (CAST or CONVERT) on the right side of the comparison operator.</span></span>  
  
 <span data-ttu-id="20e4a-563">В следующем примере создается таблица с различными типами данных.</span><span class="sxs-lookup"><span data-stu-id="20e4a-563">The following example creates a table with a variety of data types.</span></span>  
  
```sql
USE AdventureWorks2012;  
GO  
CREATE TABLE dbo.TestTable (a int, b varbinary(4));  
```  
  
 <span data-ttu-id="20e4a-564">В следующем определении отфильтрованного индекса столбец `b` неявно преобразуется в тип данных integer для сравнения с константой 1.</span><span class="sxs-lookup"><span data-stu-id="20e4a-564">In the following filtered index definition, column `b` is implicitly converted to an integer data type for the purpose of comparing it to the constant 1.</span></span> <span data-ttu-id="20e4a-565">Это вызывает сообщение об ошибке 10611, поскольку преобразование выполняется в левой части оператора в отфильтрованном предикате.</span><span class="sxs-lookup"><span data-stu-id="20e4a-565">This generates error message 10611 because the conversion occurs on the left hand side of the operator in the filtered predicate.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX TestTabIndex ON dbo.TestTable(a,b)  
WHERE b = 1;  
```  
  
 <span data-ttu-id="20e4a-566">Решением является преобразование константы в правой части к типу столбца `b`, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="20e4a-566">The solution is to convert the constant on the right hand side to be of the same type as column `b`, as seen in the following example:</span></span>  
  
```sql
CREATE INDEX TestTabIndex ON dbo.TestTable(a,b)  
WHERE b = CONVERT(Varbinary(4), 1);  
```  
  
 <span data-ttu-id="20e4a-567">Перемещение преобразования данных из левой части оператора сравнения в правую может изменить значение преобразования.</span><span class="sxs-lookup"><span data-stu-id="20e4a-567">Moving the data conversion from the left side to the right side of a comparison operator might change the meaning of the conversion.</span></span> <span data-ttu-id="20e4a-568">В приведенном выше примере при добавлении оператора CONVERT в правую часть сравнение изменяется со сравнения целочисленного типа на сравнение типа `varbinary`.</span><span class="sxs-lookup"><span data-stu-id="20e4a-568">In the above example, when the CONVERT operator was added to the right side, the comparison changed from an integer comparison to a `varbinary` comparison.</span></span>  
  
 <span data-ttu-id="20e4a-569">![Значок стрелки, используемый в ссылке "назад на начало](media/uparrow16x16.gif "Значок стрелки, используемый со ссылкой В начало") " [в этом пошаговом окне](#Top)</span><span class="sxs-lookup"><span data-stu-id="20e4a-569">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="additional-reading"></a><a name="Additional_Reading"></a> <span data-ttu-id="20e4a-570">Дополнительные материалы</span><span class="sxs-lookup"><span data-stu-id="20e4a-570">Additional Reading</span></span>  

 <span data-ttu-id="20e4a-571">[Повышение производительности с помощью индексированных представлений SQL Server 2008](https://msdn.microsoft.com/library/dd171921(v=sql.100).aspx)</span><span class="sxs-lookup"><span data-stu-id="20e4a-571">[Improving Performance with SQL Server 2008 Indexed Views](https://msdn.microsoft.com/library/dd171921(v=sql.100).aspx)</span></span>  
  
 [<span data-ttu-id="20e4a-572">Partitioned Tables and Indexes</span><span class="sxs-lookup"><span data-stu-id="20e4a-572">Partitioned Tables and Indexes</span></span>](../relational-databases/partitions/partitioned-tables-and-indexes.md)  
  
  

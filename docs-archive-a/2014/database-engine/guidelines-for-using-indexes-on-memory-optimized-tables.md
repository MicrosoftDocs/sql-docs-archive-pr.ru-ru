---
title: Рекомендации по использованию индексов в таблицах, оптимизированных для памяти | Документация Майкрософт
ms.custom: ''
ms.date: 03/08/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
helpviewer_keywords:
- hash indexes
ms.assetid: 16ef63a4-367a-46ac-917d-9eebc81ab29b
author: stevestein
ms.author: sstein
ms.openlocfilehash: f00d643088634c918eb626917eae64a001ce3678
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87732917"
---
# <a name="guidelines-for-using-indexes-on-memory-optimized-tables"></a>Рекомендации по использованию индексов в таблицах, оптимизированных для памяти
  Индексы используются для повышения эффективности доступа к данным в таблицах [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Правильное указание индексов может серьезно улучшить производительность запросов. Рассмотрим в качестве примера следующий запрос.  
  
```sql  
SELECT c1, c2 FROM t WHERE c1 = 1;  
```  
  
 При отсутствии индекса для столбца c1 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] будет сканировать всю таблицу t, а затем фильтровать строки, которые удовлетворяют условию c1=1. Однако, если t имеет индекс для столбца c1, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] может напрямую выполнить поиск по значению 1 и получить нужные строки.  
  
 Для поиска записей, имеющих определенное значение или диапазон значений, одного или нескольких столбцов в таблице [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] может использовать индекс для этих столбцов, который ускоряет поиск соответствующих записей. Использование индексов повышает производительность таблиц, хранимых на диске, и таблиц, оптимизированных для памяти. Однако существуют некоторые отличия в структуре индекса, которые следует учитывать при работе с таблицами, оптимизированными для памяти. (Индексы в таблицах, оптимизированных для памяти, называются индексами, оптимизированными для памяти.) Ниже приведены некоторые ключевые отличия.  
  
-   Оптимизированные для памяти индексы должны создаваться с помощью [CREATE TABLE &#40;&#41;Transact-SQL ](/sql/t-sql/statements/create-table-transact-sql). Дисковое индексы могут создаваться с помощью `CREATE TABLE` и `CREATE INDEX`.  
  
-   Индексы, оптимизированные для памяти, существуют только в памяти. Структуры индексов не сохраняются на диск, а операции с индексами в сети не записываются в журнал транзакций. Структура индекса создается в тот момент, когда в памяти создается таблица, оптимизированная для памяти, как при исполнении инструкции CREATE TABLE, так и при запуске базы данных.  
  
-   Индексы, оптимизированные для памяти, являются универсальными по природе. Это означает, что все столбцы включаются в индекс и для таблиц, оптимизированных для памяти, не требуется поиск по закладкам. Вместо ссылки на первичный ключ индексы, оптимизированные для памяти, просто включают указатель памяти на фактическую строку в структуре данных таблицы.  
  
-   Понятия фрагментации и коэффициента заполнения неприменимы к индексам, оптимизированным для памяти. Для индекса, сохраняемого на диске, фрагментация означает, что страницы сбалансированного дерева записываются на диск без какого-либо порядка. Индексы, оптимизированные для памяти, не записываются на диск и не считываются с диска. Фактор заполнения в индексах со структурой в виде сбалансированного дерева, сохраняемых на диск, — это степень, до которой структура физической страницы заполняется данными. Структура индекса, оптимизированного для памяти, не имеет страниц фиксированного размера.  
  
 Существует два типа индексов, оптимизированных для памяти:  
  
-   Некластеризованные хэш-индексы, которые созданы для уточняющих запросов. Дополнительные сведения о хэш-индексах см. в разделе [хэш-индексы](hash-indexes.md).  
  
-   Некластеризованные индексы, которые создаются для сканирования диапазона и упорядоченного сканирования.  
  
 При использовании хэш-индекса доступ к данным осуществляется через хэш-таблицу в памяти. Хэш-индексы не имеют страниц и всегда имеют фиксированный размер. Однако хэш-индекс может содержать пустые хэш-контейнеры, что приводит к незначительной потере свободного места. Значения, возвращаемые запросом, использующим хэш-индекс, не сортируются. Хэш-индексы оптимизированы для поиска по индексу в предикатах равенства, а также поддерживают полное сканирование индекса.  
  
 Некластеризованные индексы (не хэш-индексы) поддерживают все, что поддерживают хэш-индексы, а также операции поиска в предикатах неравенства (больше или меньше) и порядок сортировки. Строки можно получать по порядку, указанному при создании индекса. Если порядок сортировки индекса совпадает с порядком сортировки, необходимым для конкретного запроса, например если ключ индекса совпадает с предложением ORDER BY, нет необходимости сортировать строки в составе выполнения запроса. Оптимизированные для памяти некластеризованные индексы однонаправлены. Они не поддерживают извлечение строк в порядке сортировки, обратном порядку сортировки индекса. Например, для индекса, определенного как (c1 ASC), невозможно сканировать индекс в обратном порядке, как (c1 DESC).  
  
 Каждый индекс использует память. Хэш-индексы используют фиксированный размер памяти, который зависит от числа контейнеров. У некластеризованных индексов потребление памяти является функцией от числа строк и размера ключевых столбцов индекса с некоторыми дополнительными издержками в зависимости от рабочей нагрузки. Память для индексов, оптимизированных для памяти, — это дополнительная память, которая отделена от памяти, используемой для хранения строк в таблицах, оптимизированных для памяти.  
  
 Повторяющиеся ключевые значения всегда делят один и тот же хэш-контейнер.  Если хэш-индекс содержит много повторяющихся ключевых значений, итоговые длинные цепочки хэширования ухудшат производительность.   Конфликты хэша, которые происходят в любом хэш-индексе, в последующем снизит производительность в этом сценарии. По этой причине если число ключей уникального индекса не превышает числа 100 строк, то можно уменьшить риск конфликтов хэша, так как число контейнеров значительно превышает (по крайней мере в восьми раза больше количества уникальных ключей индекса; см. раздел [Определение правильного числа контейнеров для хэш-индексов](../../2014/database-engine/determining-the-correct-bucket-count-for-hash-indexes.md) ) или можно полностью исключить конфликты хэша с помощью некластеризованного индекса.  
  
## <a name="determining-which-indexes-to-use-for-a-memory-optimized-table"></a>Какие индексы следует использовать для таблицы, оптимизированной для памяти  
 Каждая оптимизированная для памяти таблица должна содержать как минимум один индекс. Обратите внимание, что каждое ограничение PRIMARY KEY неявно создает индекс. Поэтому, если таблица имеет первичный ключ, она имеет индекс. Первичный ключ является обязательным для надежной таблицы, оптимизированной для памяти.  
  
 При запросе оптимизированной для памяти таблицы производительность хэш-индексов выше, если предложение предиката содержит только предикаты равенства. Предикат должен содержать все столбцы в ключе хэш-индекса. Хэш-индекс вернется к сканированию данного предиката неравенства.  
  
 Столбец в таблице, оптимизированной для памяти, может быть частью хэш-индекса и некластеризованного индекса.  
  
 При запросе оптимизированной для памяти таблицы с предикатами неравенства некластеризованные индексы работают лучше, чем некластеризованные хэш-индексы.  
  
 Для хэш-индекса требуется ключ (для хэша) для поиска в индексе. Если ключ индекса состоит из двух столбцов, а вы предоставляете только первый столбец, у [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] не будет полного ключа для хэширования. Это приведет к получению плана запроса сканирования индекса. Столбцы, которые необходимо проиндексировать, определяются на практике.  
  
 Если в нескольких строках столбца в некластеризованном индексе содержится одинаковое значение (ключевые столбцы индекса содержат много повторяющихся значений), производительность при обновлении, вставке и удалении может снизиться.  Один из способов повышения производительности в этой ситуации — добавление еще одного столбца в некластеризованный индекс.  
  
### <a name="operations-on-memory-optimized-and-disk-based-indexes"></a>Операции с индексами с оптимизацией для памяти, хранимыми на диске.  
  
|Операция|Некластеризованный хэш-индекс, оптимизированный для памяти|Некластеризованный индекс, оптимизированный для памяти|Сохраняемый на диске индекс|  
|---------------|-------------------------------------------------|------------------------------------------|-----------------------|  
|Сканирование индекса, получение всех строк таблицы.|Да|Да|Да|  
|Поиск по индексу с использованием предиката равенства (=).|Да<br /><br /> (Требуется полный ключ.)|Да <sup>1</sup>|Да|  
|Поиск по индексу в предикатах неравенства (>, <, \<=, > =, Between).|Нет (получается при сканировании индекса)|Да <sup>1</sup>|Да|  
|Получение строк, соответствующих определению индекса, с сортировкой.|Нет|Да|Да|  
|Получение строк, соответствующих обратному определению индекса, с сортировкой.|Нет|Нет|Да|  
  
 В таблице Да означает, что индекс может адекватно обслуживать запрос, а Нет означает, что индекс не может быть успешно использован для удовлетворения запроса.   
  
 <sup>1</sup> для некластеризованного индекса, оптимизированного для памяти, полный ключ не требуется для выполнения поиска по индексу. В зависимости от порядка столбцов ключа индекса сканирование будет выполнено, если значение столбца следует после отсутствующего столбца.  
  
## <a name="index-count"></a>Счетчик индекса  
 Оптимизированные для памяти таблицы могут иметь до 8 индексов, включая индекс, создаваемый первичным ключом.   
  
 При создании определенного числа индексов для таблицы, оптимизированной для памяти, следует иметь в виду следующее.  
  
-   Следует указать необходимые индексы во время создания таблицы. Нельзя создать индекс для таблицы, оптимизированной для памяти, после создания таблицы. Если необходимо добавить индекс к таблице, оптимизированной для памяти, удалите и снова создайте таблицу.  
  
-   Не создавайте индекс, который будет использоваться редко.  
  
     Сборка мусора работает лучше, если все индексы таблицы используются часто. Редко используемые индексы могут помешать системе сборки мусора работать оптимально для старых версий строк.  
  
## <a name="creating-a-memory-optimized-index-code-samples"></a>Создание оптимизированного для памяти индекса: примеры кода  
 Хэш-индекс уровня столбца:  
  
```sql  
CREATE TABLE t1   
   (c1 INT NOT NULL INDEX idx HASH WITH (BUCKET_COUNT = 100))   
   WITH (MEMORY_OPTIMIZED = ON, DURABILITY = SCHEMA_ONLY)  
```  
  
 Хэш-индекс уровня таблицы:  
  
```sql  
CREATE TABLE t1_1   
   (c1 INT NOT NULL,   
   INDEX IDX HASH (c1) WITH (BUCKET_COUNT = 100))   
   WITH (MEMORY_OPTIMIZED = ON, DURABILITY = SCHEMA_ONLY)  
```  
  
 Хэш-индекс первичного ключа уровня столбца:  
  
```sql  
CREATE TABLE t2   
   (c1 INT NOT NULL PRIMARY KEY NONCLUSTERED HASH WITH (BUCKET_COUNT = 100))   
   WITH (MEMORY_OPTIMIZED = ON, DURABILITY = SCHEMA_AND_DATA)  
```  
  
 Хэш-индекс первичного ключа уровня таблицы:  
  
```sql  
CREATE TABLE t2_2   
   (c1 INT NOT NULL,   
   PRIMARY KEY NONCLUSTERED HASH (c1) WITH (BUCKET_COUNT = 100))   
   WITH (MEMORY_OPTIMIZED = ON, DURABILITY = SCHEMA_AND_DATA)  
```  
  
 Некластеризованный индекс на уровне столбцов:  
  
```sql  
CREATE TABLE t3   
   (c1 INT NOT NULL INDEX ID)   
   WITH (MEMORY_OPTIMIZED = ON, DURABILITY = SCHEMA_ONLY)  
```  
  
 Некластеризованный индекс на уровне таблиц:  
  
```sql  
CREATE TABLE t3_3   
   (c1 INT NOT NULL,   
   INDEX IDX NONCLUSTERED (c1))   
   WITH (MEMORY_OPTIMIZED = ON, DURABILITY = SCHEMA_ONLY)  
```  
  
 Некластеризованный индекс диапазона первичного ключа на уровне столбцов:  
  
```sql  
CREATE TABLE t4   
   (c1 INT NOT NULL PRIMARY KEY NONCLUSTERED)   
   WITH (MEMORY_OPTIMIZED = ON, DURABILITY = SCHEMA_AND_DATA)  
```  
  
 Некластеризованный индекс первичного ключа на уровне таблиц:  
  
```sql  
CREATE TABLE t4_4   
   (c1 INT NOT NULL,   
   PRIMARY KEY NONCLUSTERED (c1))   
   WITH (MEMORY_OPTIMIZED = ON, DURABILITY = SCHEMA_AND_DATA)  
```  
  
 Индекс с несколькими столбцами определен после определения столбцов:  
  
```sql  
create table t (  
       a int not null constraint ta primary key nonclustered,  
       b int not null,  
       c int not null,  
       d int not null,  
       index idx_t_b_c_d nonclustered (b, c asc, d desc)  
) with (memory_optimized = on, durability = SCHEMA_AND_DATA)  
go  
```  
  
## <a name="see-also"></a>См. также:  
 [Индексы в таблицах, оптимизированных для памяти](../relational-databases/in-memory-oltp/memory-optimized-tables.md)   
 [Определение правильного числа контейнеров для хэш-индексов](../../2014/database-engine/determining-the-correct-bucket-count-for-hash-indexes.md)   
 [Хэш-индексы](hash-indexes.md)  
  
  

---
title: Определение правильного числа контейнеров для хэш-индексов | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 6d1ac280-87db-4bd8-ad43-54353647d8b5
author: stevestein
ms.author: sstein
ms.openlocfilehash: e0579a98e3302b6944f68ca449d3e7cda0ecc01d
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87657267"
---
# <a name="determining-the-correct-bucket-count-for-hash-indexes"></a><span data-ttu-id="491ad-102">Определение правильного числа контейнеров для хэш-индексов</span><span class="sxs-lookup"><span data-stu-id="491ad-102">Determining the Correct Bucket Count for Hash Indexes</span></span>
  <span data-ttu-id="491ad-103">Необходимо указать значение для параметра `BUCKET_COUNT` при создании оптимизированной для памяти таблицы.</span><span class="sxs-lookup"><span data-stu-id="491ad-103">You must specify a value for the `BUCKET_COUNT` parameter when you create the memory-optimized table.</span></span> <span data-ttu-id="491ad-104">Этот раздел содержит рекомендации по определению соответствующего значения для параметра `BUCKET_COUNT`.</span><span class="sxs-lookup"><span data-stu-id="491ad-104">This topic makes recommendations for determining the appropriate value for the `BUCKET_COUNT` parameter.</span></span> <span data-ttu-id="491ad-105">Если не удается определить нужное число контейнеров, пользуйтесь вместо этого некластеризованным индексом.</span><span class="sxs-lookup"><span data-stu-id="491ad-105">If you cannot determine the correct bucket count, use a nonclustered index instead.</span></span>  <span data-ttu-id="491ad-106">Неверное значение `BUCKET_COUNT`, особенно слишком низкое, может значительно повлиять на производительность рабочей нагрузки, а также на время восстановления базы данных.</span><span class="sxs-lookup"><span data-stu-id="491ad-106">An incorrect `BUCKET_COUNT` value, especially one that is too low, can significantly impact workload performance, as well as recovery time of the database.</span></span> <span data-ttu-id="491ad-107">Рекомендуется пересмотреть число контейнеров.</span><span class="sxs-lookup"><span data-stu-id="491ad-107">It is better to overestimate the bucket count.</span></span>  
  
 <span data-ttu-id="491ad-108">Повторяющиеся ключи индекса могут ухудшить производительность с хэш-индексом, поскольку ключи хэшируются в один контейнер, в результате чего последовательность этого контейнера увеличивается.</span><span class="sxs-lookup"><span data-stu-id="491ad-108">Duplicate index keys can decrease performance with a hash index because the keys are hashed to the same bucket, causing that bucket's chain to increase.</span></span>  
  
 <span data-ttu-id="491ad-109">Дополнительные сведения о некластеризованных хэш-индексах см. в разделах [Hash Indexes](hash-indexes.md) и [Guidelines for Using Indexes on Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).</span><span class="sxs-lookup"><span data-stu-id="491ad-109">For more information about nonclustered hash indexes, see [Hash Indexes](hash-indexes.md) and [Guidelines for Using Indexes on Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).</span></span>  
  
 <span data-ttu-id="491ad-110">Одна хэш-таблица выделяется для каждого хэш-индекса таблицы, оптимизированной для памяти.</span><span class="sxs-lookup"><span data-stu-id="491ad-110">One hash table is allocated for each hash index on a memory-optimized table.</span></span> <span data-ttu-id="491ad-111">Размер хэш-таблицы, выделенной для индекса, задается `BUCKET_COUNT` параметром в [CREATE TABLE &#40;TRANSACT-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql) или [CREATE TYPE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-type-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="491ad-111">The size of the hash table allocated for an index is specified by the `BUCKET_COUNT` parameter in [CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql) or [CREATE TYPE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-type-transact-sql).</span></span> <span data-ttu-id="491ad-112">Число контейнеров округляется до ближайшей степени числа 2.</span><span class="sxs-lookup"><span data-stu-id="491ad-112">The bucket count will internally be rounded up to the next power of two.</span></span> <span data-ttu-id="491ad-113">Например, если указано 300 000 контейнеров, то фактически число контейнеров составит 524 288.</span><span class="sxs-lookup"><span data-stu-id="491ad-113">For example, specifying a bucket count of 300,000 will result in an actual bucket count of 524,288.</span></span>  
  
 <span data-ttu-id="491ad-114">Ссылки на статьи и видео на тему числа контейнеров см. в разделе [Как определить нужное число контейнеров для хэш-индексов (OLTP в памяти)](https://www.mssqltips.com/sqlservertip/3104/determine-bucketcount-for-hash-indexes-for-sql-server-memory-optimized-tables/).</span><span class="sxs-lookup"><span data-stu-id="491ad-114">For links to an article and video on bucket count, see [How to determine the right bucket count for hash indexes (In-Memory OLTP)](https://www.mssqltips.com/sqlservertip/3104/determine-bucketcount-for-hash-indexes-for-sql-server-memory-optimized-tables/).</span></span>  
  
## <a name="recommendations"></a><span data-ttu-id="491ad-115">Рекомендации</span><span class="sxs-lookup"><span data-stu-id="491ad-115">Recommendations</span></span>  
 <span data-ttu-id="491ad-116">В большинстве случаев число контейнеров должно находиться в диапазоне, в 1–2 раза превышающем число уникальных значений в ключе индекса.</span><span class="sxs-lookup"><span data-stu-id="491ad-116">In most cases the bucket count should be between 1 and 2 times the number of distinct values in the index key.</span></span> <span data-ttu-id="491ad-117">Если ключ индекса содержит много повторяющихся значений, в среднем более 10 строк на каждое из них, используйте некластеризованный индекс.</span><span class="sxs-lookup"><span data-stu-id="491ad-117">If the index key contains a lot of duplicate values, on average there are more than 10 rows for each index key value, use a nonclustered index instead</span></span>  
  
 <span data-ttu-id="491ad-118">Не всегда можно спрогнозировать количество значений, которые содержит конкретный ключ индекса.</span><span class="sxs-lookup"><span data-stu-id="491ad-118">You may not always be able to predict how many values a particular index key may have or will have.</span></span> <span data-ttu-id="491ad-119">Уровень производительности считается приемлемым, если значение `BUCKET_COUNT` входит в диапазон значений, в 5 раз превышающих фактическое число ключевых значений.</span><span class="sxs-lookup"><span data-stu-id="491ad-119">Performance should be acceptable if the `BUCKET_COUNT` value is within 5 times of the actual number of key values.</span></span>  
  
 <span data-ttu-id="491ad-120">Для определения числа ключей уникального индекса в существующих данных используйте запросы наподобие следующего:</span><span class="sxs-lookup"><span data-stu-id="491ad-120">To determine the number of unique index keys in existing data, use queries similar to the following examples:</span></span>  
  
### <a name="primary-key-and-unique-indexes"></a><span data-ttu-id="491ad-121">Первичный ключ и уникальные индексы</span><span class="sxs-lookup"><span data-stu-id="491ad-121">Primary Key and Unique Indexes</span></span>  
 <span data-ttu-id="491ad-122">Так как индекс первичного ключа является уникальным, число различающихся значений в ключе соответствует числу строк в таблице.</span><span class="sxs-lookup"><span data-stu-id="491ad-122">Because the primary key index is unique, the number of distinct values in the key corresponds to the number of rows in the table.</span></span> <span data-ttu-id="491ad-123">Для примера первичный ключ включен (SalesOrderID, SalesOrderDetailID) в таблицу Sales.SalesOrderDetail базы данных AdventureWorks; выполните следующий запрос, чтобы вычислить число различающихся значений первичного ключа, которое соответствует количеству строк в таблице.</span><span class="sxs-lookup"><span data-stu-id="491ad-123">For an example primary key on (SalesOrderID, SalesOrderDetailID) in the table Sales.SalesOrderDetail in the AdventureWorks database, issue the following query to calculate the number of distinct primary key values, which corresponds to the number of rows in the table:</span></span>  
  
```sql  
SELECT COUNT(*) AS [row count]   
FROM Sales.SalesOrderDetail  
```  
  
 <span data-ttu-id="491ad-124">Этот запрос указывает число строк, равное 121 317.</span><span class="sxs-lookup"><span data-stu-id="491ad-124">This query shows a row count of 121,317.</span></span> <span data-ttu-id="491ad-125">Если число строк значительно не изменится, используйте 240 000 контейнеров.</span><span class="sxs-lookup"><span data-stu-id="491ad-125">Use a bucket count of 240,000 if the row count will not change significantly.</span></span> <span data-ttu-id="491ad-126">Если ожидается, что количество заказов на продажу в таблице увеличится в четыре раза, укажите 480 000 контейнеров.</span><span class="sxs-lookup"><span data-stu-id="491ad-126">Use a bucket count of 480,000 if the number of sales orders in the table is expected to quadruple.</span></span>  
  
### <a name="non-unique-indexes"></a><span data-ttu-id="491ad-127">Неуникальные индексы</span><span class="sxs-lookup"><span data-stu-id="491ad-127">Non-Unique Indexes</span></span>  
 <span data-ttu-id="491ad-128">Для других индексов, например для индекса с несколькими столбцами (SpecialOfferID, ProductID), создайте следующий запрос для определения числа значений уникального индекса:</span><span class="sxs-lookup"><span data-stu-id="491ad-128">For other indexes, for example a multi-column index on (SpecialOfferID, ProductID), issue the following query to determine the number of unique index key values:</span></span>  
  
```sql  
SELECT COUNT(*) AS [SpecialOfferID_ProductID index key count]  
FROM   
   (SELECT DISTINCT SpecialOfferID, ProductID   
    FROM Sales.SalesOrderDetail) t  
```  
  
 <span data-ttu-id="491ad-129">Этот запрос возвращает число ключей индекса для SpecialOfferID, ProductID (484), которое указывает на то, что вместо некластеризованного хэш-индекса следует использовать некластеризованный индекс.</span><span class="sxs-lookup"><span data-stu-id="491ad-129">This query returns an index key count for (SpecialOfferID, ProductID) of 484, indicating a that a nonclustered index should be used instead of a nonclustered hash index.</span></span>  
  
### <a name="determining-the-number-of-duplicates"></a><span data-ttu-id="491ad-130">Определение числа повторов</span><span class="sxs-lookup"><span data-stu-id="491ad-130">Determining the Number of Duplicates</span></span>  
 <span data-ttu-id="491ad-131">Чтобы определить среднее количество повторяющихся значений для ключа индекса, разделите общее количество строк на число ключей уникального индекса.</span><span class="sxs-lookup"><span data-stu-id="491ad-131">To determine the average number of duplicate values for an index key value, divide the total number of rows by the number of unique index keys.</span></span>  
  
 <span data-ttu-id="491ad-132">Для примера индекса (SpecialOfferID, ProductID) это приводит к 121317/484=251.</span><span class="sxs-lookup"><span data-stu-id="491ad-132">For the example index on (SpecialOfferID, ProductID), this leads to 121317 / 484 = 251.</span></span> <span data-ttu-id="491ad-133">Таким образом, значения ключа индекса имеют среднее значение 251, поэтому это должен быть некластеризованный индекс.</span><span class="sxs-lookup"><span data-stu-id="491ad-133">This means index key values have an average of 251, and thus this should be a nonclustered index.</span></span>  
  
## <a name="troubleshooting-the-bucket-count"></a><span data-ttu-id="491ad-134">Диагностика и устранение неполадок с числом контейнеров</span><span class="sxs-lookup"><span data-stu-id="491ad-134">Troubleshooting the Bucket Count</span></span>  
 <span data-ttu-id="491ad-135">Чтобы устранить проблемы с количеством контейнеров в оптимизированных для памяти таблицах, используйте представление [sys. dm_db_xtp_hash_index_stats &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-hash-index-stats-transact-sql) , чтобы получить статистику по пустым контейнерам и длине цепочек строк.</span><span class="sxs-lookup"><span data-stu-id="491ad-135">To troubleshoot bucket count issues in memory-optimized tables, use [sys.dm_db_xtp_hash_index_stats &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-hash-index-stats-transact-sql) to obtain statistics about the empty buckets and the length of row chains.</span></span> <span data-ttu-id="491ad-136">Следующий запрос может быть использован для получения статистики обо всех хэш-индексах в текущей базе данных.</span><span class="sxs-lookup"><span data-stu-id="491ad-136">The following query can be used to obtain statistics about all the hash indexes in the current database.</span></span> <span data-ttu-id="491ad-137">При наличии больших таблиц в базе данных выполнение запроса может занять несколько минут.</span><span class="sxs-lookup"><span data-stu-id="491ad-137">The query can take several minutes to run if there are large tables in the database.</span></span>  
  
```sql  
SELECT   
   object_name(hs.object_id) AS 'object name',   
   i.name as 'index name',   
   hs.total_bucket_count,  
   hs.empty_bucket_count,  
   floor((cast(empty_bucket_count as float)/total_bucket_count) * 100) AS 'empty_bucket_percent',  
   hs.avg_chain_length,   
   hs.max_chain_length  
FROM sys.dm_db_xtp_hash_index_stats AS hs   
   JOIN sys.indexes AS i   
   ON hs.object_id=i.object_id AND hs.index_id=i.index_id  
```  
  
 <span data-ttu-id="491ad-138">Два ключевых индикатора работоспособности хэш-индекса:</span><span class="sxs-lookup"><span data-stu-id="491ad-138">The two key indicators of hash index health are:</span></span>  
  
 <span data-ttu-id="491ad-139">*empty_bucket_percent*</span><span class="sxs-lookup"><span data-stu-id="491ad-139">*empty_bucket_percent*</span></span>  
 <span data-ttu-id="491ad-140">*empty_bucket_percent* указывает число пустых контейнеров в хэш-индексе.</span><span class="sxs-lookup"><span data-stu-id="491ad-140">*empty_bucket_percent* indicates the number of empty buckets in the hash index.</span></span>  
  
 <span data-ttu-id="491ad-141">Если *empty_bucket_percent* имеет значение меньше 10, то число контейнеров, вероятнее всего, будет иметь слишком малое значение.</span><span class="sxs-lookup"><span data-stu-id="491ad-141">If *empty_bucket_percent* is less than 10 percent, the bucket count is likely to be too low.</span></span> <span data-ttu-id="491ad-142">В идеальном случае значение *empty_bucket_percent* должно быть равно 33 процентам или больше.</span><span class="sxs-lookup"><span data-stu-id="491ad-142">Ideally, the *empty_bucket_percent* should be 33 percent or greater.</span></span> <span data-ttu-id="491ad-143">Если число контейнеров соответствует числу значений ключей индекса, то примерно треть контейнеров будет пуста из-за распределения хэша.</span><span class="sxs-lookup"><span data-stu-id="491ad-143">If the bucket count matches the number of index key values, about 1/3 of the buckets is empty, due to hash distribution.</span></span>  
  
 <span data-ttu-id="491ad-144">*avg_chain_length*</span><span class="sxs-lookup"><span data-stu-id="491ad-144">*avg_chain_length*</span></span>  
 <span data-ttu-id="491ad-145">*avg_chain_length* указывает среднюю длину цепочек строк в хэш-контейнерах.</span><span class="sxs-lookup"><span data-stu-id="491ad-145">*avg_chain_length* indicates the average length of the row chains in the hash buckets.</span></span>  
  
 <span data-ttu-id="491ad-146">Если значение *avg_chain_length* больше 10 и *empty_bucket_percent* больше 10, то, вероятнее всего, имеется много одинаковых значений ключей индекса и использование некластеризованного индекса будет более целесообразным.</span><span class="sxs-lookup"><span data-stu-id="491ad-146">If *avg_chain_length* is greater than 10 and *empty_bucket_percent* is greater than 10 percent, there likely are many duplicate index key values and a nonclustered index would be more appropriate.</span></span> <span data-ttu-id="491ad-147">Средняя длина цепочки, равная 1, является оптимальной.</span><span class="sxs-lookup"><span data-stu-id="491ad-147">An average chain length of 1 is ideal.</span></span>  
  
 <span data-ttu-id="491ad-148">Существует два фактора, оказывающих влияние на длину цепочки.</span><span class="sxs-lookup"><span data-stu-id="491ad-148">There are two factors that impact the chain length:</span></span>  
  
1.  <span data-ttu-id="491ad-149">Повторы: все повторяющиеся строки являются частью одной цепочки хэш-индекса.</span><span class="sxs-lookup"><span data-stu-id="491ad-149">Duplicates; all duplicate rows are part of the same chain in the hash index.</span></span>  
  
2.  <span data-ttu-id="491ad-150">Несколько значений ключей сопоставляются с одним контейнером.</span><span class="sxs-lookup"><span data-stu-id="491ad-150">Multiple key values map to the same bucket.</span></span> <span data-ttu-id="491ad-151">Чем меньше число контейнеров, тем больше число контейнеров, которым будет сопоставлено несколько значений.</span><span class="sxs-lookup"><span data-stu-id="491ad-151">The lower the bucket count, the more buckets that will have multiple values mapped to them.</span></span>  
  
 <span data-ttu-id="491ad-152">В качестве примера рассмотрим следующую таблицу и скрипт для вставки образцов строк в таблицу.</span><span class="sxs-lookup"><span data-stu-id="491ad-152">As an example, consider the following table and script to insert sample rows in the table:</span></span>  
  
```sql  
CREATE TABLE [Sales].[SalesOrderHeader_test]  
(  
   [SalesOrderID] [uniqueidentifier] NOT NULL DEFAULT (newid()),  
   [OrderSequence] int NOT NULL,  
   [OrderDate] [datetime2](7) NOT NULL,  
   [Status] [tinyint] NOT NULL,  
  
PRIMARY KEY NONCLUSTERED HASH ([SalesOrderID]) WITH ( BUCKET_COUNT = 262144 ),  
INDEX IX_OrderSequence HASH (OrderSequence) WITH ( BUCKET_COUNT = 20000),  
INDEX IX_Status HASH ([Status]) WITH ( BUCKET_COUNT = 8),  
INDEX IX_OrderDate NONCLUSTERED ([OrderDate] ASC),  
)WITH ( MEMORY_OPTIMIZED = ON , DURABILITY = SCHEMA_AND_DATA )  
GO  
  
DECLARE @i int = 0  
BEGIN TRAN  
WHILE @i < 262144  
BEGIN  
   INSERT Sales.SalesOrderHeader_test (OrderSequence, OrderDate, [Status]) VALUES (@i, sysdatetime(), @i % 8)  
   SET @i += 1  
END  
COMMIT  
GO  
```  
  
 <span data-ttu-id="491ad-153">Скрипт вставляет в таблицу 262 144 строки.</span><span class="sxs-lookup"><span data-stu-id="491ad-153">The script inserts 262,144 rows in the table.</span></span> <span data-ttu-id="491ad-154">Он вставляет уникальные значения в индекс первичного ключа и в IX_OrderSequence.</span><span class="sxs-lookup"><span data-stu-id="491ad-154">It inserts unique values in the primary key index and in IX_OrderSequence.</span></span> <span data-ttu-id="491ad-155">Он вставляет много повторяющихся значений в IX_Status индекса: скрипт создает только 8 различных значений.</span><span class="sxs-lookup"><span data-stu-id="491ad-155">It inserts a lot of duplicate values in the index IX_Status: the script only generates 8 distinct values.</span></span>  
  
 <span data-ttu-id="491ad-156">Выходное значение диагностики и устранения ошибок в запросах BUCKET_COUNT выглядит следующим образом:</span><span class="sxs-lookup"><span data-stu-id="491ad-156">The output of the BUCKET_COUNT troubleshooting query is as follows:</span></span>  
  
|<span data-ttu-id="491ad-157">имя индекса</span><span class="sxs-lookup"><span data-stu-id="491ad-157">index name</span></span>|<span data-ttu-id="491ad-158">total_bucket_count</span><span class="sxs-lookup"><span data-stu-id="491ad-158">total_bucket_count</span></span>|<span data-ttu-id="491ad-159">empty_bucket_count</span><span class="sxs-lookup"><span data-stu-id="491ad-159">empty_bucket_count</span></span>|<span data-ttu-id="491ad-160">empty_bucket_percent</span><span class="sxs-lookup"><span data-stu-id="491ad-160">empty_bucket_percent</span></span>|<span data-ttu-id="491ad-161">avg_chain_length</span><span class="sxs-lookup"><span data-stu-id="491ad-161">avg_chain_length</span></span>|<span data-ttu-id="491ad-162">max_chain_length</span><span class="sxs-lookup"><span data-stu-id="491ad-162">max_chain_length</span></span>|  
|----------------|--------------------------|--------------------------|----------------------------|------------------------|------------------------|  
|<span data-ttu-id="491ad-163">IX_Status</span><span class="sxs-lookup"><span data-stu-id="491ad-163">IX_Status</span></span>|<span data-ttu-id="491ad-164">8</span><span class="sxs-lookup"><span data-stu-id="491ad-164">8</span></span>|<span data-ttu-id="491ad-165">4</span><span class="sxs-lookup"><span data-stu-id="491ad-165">4</span></span>|<span data-ttu-id="491ad-166">50</span><span class="sxs-lookup"><span data-stu-id="491ad-166">50</span></span>|<span data-ttu-id="491ad-167">65536</span><span class="sxs-lookup"><span data-stu-id="491ad-167">65536</span></span>|<span data-ttu-id="491ad-168">65536</span><span class="sxs-lookup"><span data-stu-id="491ad-168">65536</span></span>|  
|<span data-ttu-id="491ad-169">IX_OrderSequence</span><span class="sxs-lookup"><span data-stu-id="491ad-169">IX_OrderSequence</span></span>|<span data-ttu-id="491ad-170">32768</span><span class="sxs-lookup"><span data-stu-id="491ad-170">32768</span></span>|<span data-ttu-id="491ad-171">13</span><span class="sxs-lookup"><span data-stu-id="491ad-171">13</span></span>|<span data-ttu-id="491ad-172">0</span><span class="sxs-lookup"><span data-stu-id="491ad-172">0</span></span>|<span data-ttu-id="491ad-173">8</span><span class="sxs-lookup"><span data-stu-id="491ad-173">8</span></span>|<span data-ttu-id="491ad-174">26</span><span class="sxs-lookup"><span data-stu-id="491ad-174">26</span></span>|  
|<span data-ttu-id="491ad-175">PK_SalesOrd_B14003C3F8FB3364</span><span class="sxs-lookup"><span data-stu-id="491ad-175">PK_SalesOrd_B14003C3F8FB3364</span></span>|<span data-ttu-id="491ad-176">262144</span><span class="sxs-lookup"><span data-stu-id="491ad-176">262144</span></span>|<span data-ttu-id="491ad-177">96319</span><span class="sxs-lookup"><span data-stu-id="491ad-177">96319</span></span>|<span data-ttu-id="491ad-178">36</span><span class="sxs-lookup"><span data-stu-id="491ad-178">36</span></span>|<span data-ttu-id="491ad-179">1</span><span class="sxs-lookup"><span data-stu-id="491ad-179">1</span></span>|<span data-ttu-id="491ad-180">8</span><span class="sxs-lookup"><span data-stu-id="491ad-180">8</span></span>|  
  
 <span data-ttu-id="491ad-181">Рассмотрим 3 хэш-индекса в этой таблице.</span><span class="sxs-lookup"><span data-stu-id="491ad-181">Consider the three hash indexes on this table:</span></span>  
  
-   <span data-ttu-id="491ad-182">IX_Status: 50 % контейнеров пусты, что хорошо.</span><span class="sxs-lookup"><span data-stu-id="491ad-182">IX_Status: 50 percent of the buckets are empty, which is good.</span></span> <span data-ttu-id="491ad-183">Однако среднее значение длины цепочки очень высоко (65 536).</span><span class="sxs-lookup"><span data-stu-id="491ad-183">However, the average chain length is very high (65,536).</span></span> <span data-ttu-id="491ad-184">Это указывает на большое количество повторяющихся значений.</span><span class="sxs-lookup"><span data-stu-id="491ad-184">This indicates a large number of duplicate values.</span></span> <span data-ttu-id="491ad-185">Поэтому использование некластеризованного хэш-индекса в данном случае не подходит.</span><span class="sxs-lookup"><span data-stu-id="491ad-185">Therefore, using a nonclustered hash index is not appropriate in this case.</span></span> <span data-ttu-id="491ad-186">Вместо этого следует пользоваться некластеризованным индексом.</span><span class="sxs-lookup"><span data-stu-id="491ad-186">A nonclustered index should be used instead.</span></span>  
  
-   <span data-ttu-id="491ad-187">IX_OrderSequence: 0 % контейнеров пусты. Это слишком мало.</span><span class="sxs-lookup"><span data-stu-id="491ad-187">IX_OrderSequence: 0 percent of the buckets are empty, which is too low.</span></span> <span data-ttu-id="491ad-188">Кроме того, средняя длина цепочки составляет 8.</span><span class="sxs-lookup"><span data-stu-id="491ad-188">In addition, the average chain length is 8.</span></span> <span data-ttu-id="491ad-189">Поскольку значения в этом индексе являются уникальными, то это значит, что в среднем 8 значений сопоставлены с каждым контейнером.</span><span class="sxs-lookup"><span data-stu-id="491ad-189">As the values in this index are unique, this means on average 8 values are mapped to each bucket.</span></span> <span data-ttu-id="491ad-190">Число контейнеров должно быть увеличено.</span><span class="sxs-lookup"><span data-stu-id="491ad-190">The bucket count should be increased.</span></span> <span data-ttu-id="491ad-191">Поскольку ключ индекса имеет 262 144 уникальных значения, число контейнеров должно быть не менее 262 144.</span><span class="sxs-lookup"><span data-stu-id="491ad-191">As the index key has 262,144 unique values, the bucket count should be at least 262,144.</span></span> <span data-ttu-id="491ad-192">Если ожидается увеличение в будущем, значение должно быть больше.</span><span class="sxs-lookup"><span data-stu-id="491ad-192">If future growth is expected, the number should be higher.</span></span>  
  
-   <span data-ttu-id="491ad-193">Индекс первичного ключа (PK__SalesOrder...): 36 процентов контейнеров пусты, что является хорошим.</span><span class="sxs-lookup"><span data-stu-id="491ad-193">Primary key index (PK__SalesOrder...): 36 percent of the buckets are empty, which is good.</span></span> <span data-ttu-id="491ad-194">Кроме того, средняя длина цепочки имеет значение 1, что тоже является хорошим показателем.</span><span class="sxs-lookup"><span data-stu-id="491ad-194">In addition the average chain length is 1, which is also good.</span></span> <span data-ttu-id="491ad-195">Нет необходимости в изменениях.</span><span class="sxs-lookup"><span data-stu-id="491ad-195">No change needed.</span></span>  
  
 <span data-ttu-id="491ad-196">Дополнительные сведения о диагностике и устранении неполадок с оптимизированными для памяти хэш-индексами см. в разделе [Troubleshooting Common Performance Problems with Memory-Optimized Hash Indexes](../../2014/database-engine/troubleshooting-common-performance-problems-with-memory-optimized-hash-indexes.md).</span><span class="sxs-lookup"><span data-stu-id="491ad-196">For more information on troubleshooting issues with your memory-optimized hash indexes, see [Troubleshooting Common Performance Problems with Memory-Optimized Hash Indexes](../../2014/database-engine/troubleshooting-common-performance-problems-with-memory-optimized-hash-indexes.md).</span></span>  
  
## <a name="detailed-considerations-for-further-optimization"></a><span data-ttu-id="491ad-197">Подробные рекомендации для дальнейшей оптимизации</span><span class="sxs-lookup"><span data-stu-id="491ad-197">Detailed Considerations for Further Optimization</span></span>  
 <span data-ttu-id="491ad-198">В этом разделе описывается более подробные рекомендации по оптимизации числа контейнеров.</span><span class="sxs-lookup"><span data-stu-id="491ad-198">This section outlines further considerations for optimizing the bucket count.</span></span>  
  
 <span data-ttu-id="491ad-199">Чтобы добиться наилучшей производительности, для хэш-индексов необходимо учитывать объем памяти, выделяемый для хэш-таблицы, и число разных значений в ключе индекса.</span><span class="sxs-lookup"><span data-stu-id="491ad-199">To achieve the best performance for hash indexes, balance the amount of memory allocated to the hash table and the number of distinct values in the index key.</span></span> <span data-ttu-id="491ad-200">Также существует зависимость между производительностью уточняющих запросов и сканирования таблиц.</span><span class="sxs-lookup"><span data-stu-id="491ad-200">There is also a balance between the performance of point lookups and table scans:</span></span>  
  
-   <span data-ttu-id="491ad-201">Чем выше значение числа контейнеров, тем больше пустых контейнеров будет в индексе.</span><span class="sxs-lookup"><span data-stu-id="491ad-201">The higher the bucket count value, the more empty buckets there will be in the index.</span></span> <span data-ttu-id="491ad-202">Это влияет на использование памяти (8 байт на сегмент) и производительность просмотров таблиц, так как в процессе просмотра таблицы сканируется каждый контейнер.</span><span class="sxs-lookup"><span data-stu-id="491ad-202">This has an impact on memory usage (8 bytes per bucket) and the performance of table scans, as each bucket is scanned as part of a table scan.</span></span>  
  
-   <span data-ttu-id="491ad-203">Чем меньше число контейнеров, тем больше значений присваиваются каждому контейнеру.</span><span class="sxs-lookup"><span data-stu-id="491ad-203">The lower the bucket count, the more values are assigned to a single bucket.</span></span> <span data-ttu-id="491ad-204">В этом случае снижается производительность уточняющих запросов и вставок, поскольку [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] может потребоваться перебор нескольких значений в одном контейнере для нахождения значения, указанного предикатом поиска.</span><span class="sxs-lookup"><span data-stu-id="491ad-204">This decreases performance for point lookups and inserts, because [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] may need to traverse several values in a single bucket to find the value specified by the search predicate.</span></span>  
  
 <span data-ttu-id="491ad-205">Если число контейнеров значительно меньше числа ключей уникального индекса, то с каждым контейнером будет сопоставлено множество значений.</span><span class="sxs-lookup"><span data-stu-id="491ad-205">If the bucket count is significantly lower than the number of unique index keys, many values will map to each bucket.</span></span> <span data-ttu-id="491ad-206">Это снижает производительность большинства операций DML, в частности уточняющих запросов (поиска отдельных ключей индекса) и операций вставки.</span><span class="sxs-lookup"><span data-stu-id="491ad-206">This degrades performance of most DML operations, particularly point lookups (lookups of individual index keys) and insert operations.</span></span> <span data-ttu-id="491ad-207">Например, может снизиться производительность запросов SELECT и операций UPDATE и DELETE с предикатами равенства, сопоставляющих ключевые столбцы индекса в предложении WHERE.</span><span class="sxs-lookup"><span data-stu-id="491ad-207">For example, you may see poor performance of SELECT queries and, UPDATE and DELETE operations with equality predicates matching the index key columns in the WHERE clause.</span></span> <span data-ttu-id="491ad-208">Малое число контейнеров также влияет на время восстановления базы данных, поскольку индексы создаются заново при запуске базы данных.</span><span class="sxs-lookup"><span data-stu-id="491ad-208">A low bucket count will also affect the recovery time of the database, as the indexes are recreated on database startup.</span></span>  
  
### <a name="duplicate-index-key-values"></a><span data-ttu-id="491ad-209">Повторяющиеся значения ключа индекса</span><span class="sxs-lookup"><span data-stu-id="491ad-209">Duplicate Index Key Values</span></span>  
 <span data-ttu-id="491ad-210">Повторяющиеся значения могут увеличить влияние на производительность конфликтов хэш-значений.</span><span class="sxs-lookup"><span data-stu-id="491ad-210">Duplicate values can increase the performance impact of hash collisions.</span></span> <span data-ttu-id="491ad-211">Как правило, не является серьезной проблемой, если в каждом ключе индекса имеется небольшое количество повторов.</span><span class="sxs-lookup"><span data-stu-id="491ad-211">This is usually not a problem if each index key has a low number of duplicates.</span></span> <span data-ttu-id="491ad-212">Однако это может вызвать проблемы при значительном несоответствии числа уникальных ключей индекса и числа строк в таблице.</span><span class="sxs-lookup"><span data-stu-id="491ad-212">But this can be a problem if the discrepancy between the number of unique index keys and the number of rows in the tables becomes very large.</span></span>  
  
 <span data-ttu-id="491ad-213">Все строки с одинаковым значением ключа индекса помещаются в одну и ту же цепочку повторов.</span><span class="sxs-lookup"><span data-stu-id="491ad-213">All rows with the same index key will go into the same duplicate chain.</span></span> <span data-ttu-id="491ad-214">Если для нескольких ключей индекса в том же контейнере ожидается конфликт хэш-индексов, сканерам индексов всегда необходимо выполнять сканирование полной цепочки повторов на наличие первого значения, только после этого они смогут найти первую строку, соответствующую второму значению.</span><span class="sxs-lookup"><span data-stu-id="491ad-214">If multiple index keys are in the same bucket due to a hash collision, index scanners always need to scan the full duplicate chain for the first value before they can locate the first row corresponding to the second value.</span></span> <span data-ttu-id="491ad-215">Повторяющиеся ключи также затрудняют процессу сборки мусора обнаружение строки.</span><span class="sxs-lookup"><span data-stu-id="491ad-215">Duplicate keys also make it more difficult for garbage collection to locate the row.</span></span> <span data-ttu-id="491ad-216">Например, если есть 1000 повторяющихся ключей, то при удалении одной из строк сборщик мусора должен просканировать цепь из 1000 повторяющихся элементов, чтобы убрать строку из индекса.</span><span class="sxs-lookup"><span data-stu-id="491ad-216">For example, if there are 1,000 duplicates for any key and one of the rows is deleted, the garbage collector needs to scan the chain of 1,000 duplicates to unlink the row from the index.</span></span> <span data-ttu-id="491ad-217">Это верно, даже если запрос, по которому было найдено удаление, использовал более эффективный индекс (индекс первичного ключа), чтобы найти строку, поскольку сборщику мусора нужно удалить связи из каждого индекса</span><span class="sxs-lookup"><span data-stu-id="491ad-217">This is true even if the query that found the delete used a more efficient index (a primary key index) to locate the row, because the garbage collector needs to unlink from every index</span></span>  
  
 <span data-ttu-id="491ad-218">Для хэш-индексов есть два способа уменьшить нагрузку, вызванную повторяющимися значениями ключей.</span><span class="sxs-lookup"><span data-stu-id="491ad-218">For hash indexes, there are two ways to reduce the work caused by duplicate index key values:</span></span>  
  
-   <span data-ttu-id="491ad-219">Вместо это используйте некластеризованный индекс.</span><span class="sxs-lookup"><span data-stu-id="491ad-219">Use a nonclustered index instead.</span></span> <span data-ttu-id="491ad-220">Можно уменьшить повторяющиеся значения, добавив столбцы к ключу индекса, без необходимости внесения каких-либо изменений в приложение.</span><span class="sxs-lookup"><span data-stu-id="491ad-220">You can decrease the duplicates by adding columns to the index key without requiring any changes to the application.</span></span>  
  
-   <span data-ttu-id="491ad-221">Укажите очень большое число контейнеров для индекса.</span><span class="sxs-lookup"><span data-stu-id="491ad-221">Specify a very high bucket count for the index.</span></span> <span data-ttu-id="491ad-222">Например, в 20–100 раз больше число ключей уникального индекса.</span><span class="sxs-lookup"><span data-stu-id="491ad-222">For example, 20-to-100 times the number of unique index keys.</span></span> <span data-ttu-id="491ad-223">Это позволит уменьшить количество конфликтов хэш-значений.</span><span class="sxs-lookup"><span data-stu-id="491ad-223">This will reduce hash collisions.</span></span>  
  
### <a name="small-tables"></a><span data-ttu-id="491ad-224">Небольшие таблицы</span><span class="sxs-lookup"><span data-stu-id="491ad-224">Small Tables</span></span>  
 <span data-ttu-id="491ad-225">Для небольших таблиц использование памяти обычно не столь важно, так как размер индекса будет небольшим по сравнению с общим размером базы данных.</span><span class="sxs-lookup"><span data-stu-id="491ad-225">For smaller tables, memory utilization is usually not a concern, as the size of the index will be small compared to the overall size of the database.</span></span>  
  
 <span data-ttu-id="491ad-226">Теперь необходимо сделать выбор на основе необходимого уровня производительности.</span><span class="sxs-lookup"><span data-stu-id="491ad-226">You must now make a choice based on the kind of performance you want:</span></span>  
  
-   <span data-ttu-id="491ad-227">Если операции, чья производительность является критичной в индексе в большинстве случаев являются уточняющими запросами и операциями вставки, то рекомендуется увеличить число контейнеров для уменьшения вероятности возникновения конфликта хэш-индексов.</span><span class="sxs-lookup"><span data-stu-id="491ad-227">If the performance-critical operations on the index are predominantly point lookups and/or insert operations, a higher bucket count would be appropriate to reduce the likelihood of hash collisions.</span></span> <span data-ttu-id="491ad-228">Оптимальная рекомендация — увеличить число строк в три раза и даже более.</span><span class="sxs-lookup"><span data-stu-id="491ad-228">Three times the number of rows or even more would be the best option.</span></span>  
  
-   <span data-ttu-id="491ad-229">Если полное сканирование индекса является по большей части операций, чья производительность критична, используйте число контейнеров, близкое к фактическому числу значений ключа индекса.</span><span class="sxs-lookup"><span data-stu-id="491ad-229">If full index scans are the predominant performance-critical operations, use a bucket count that is close to the actual number of index key values.</span></span>  
  
### <a name="big-tables"></a><span data-ttu-id="491ad-230">Большие таблицы</span><span class="sxs-lookup"><span data-stu-id="491ad-230">Big Tables</span></span>  
 <span data-ttu-id="491ad-231">Для больших таблиц использование памяти может стать проблемой.</span><span class="sxs-lookup"><span data-stu-id="491ad-231">For large tables, memory utilization could become a concern.</span></span> <span data-ttu-id="491ad-232">Например, если таблица строк 250 000 000 содержит 4 хэш-индекса, каждый из которых имеет число контейнеров, равное 1 000 000 000, то затраты для хэш-таблиц составляет 4 индекса \* 1 000 000 000 контейнеров \* 8 байт = 32 гигабайта использования памяти.</span><span class="sxs-lookup"><span data-stu-id="491ad-232">For example, with a 250 million row table that has 4 hash indexes, each with a bucket count of one billion, the overhead for the hash tables is 4 indexes \* 1 billion buckets \* 8 bytes = 32 gigabytes of memory utilization.</span></span> <span data-ttu-id="491ad-233">При выборе числа контейнеров, равного 250 миллионов, для всех индексов общий объем используемой памяти для хэш-таблиц составит 8 ГБ.</span><span class="sxs-lookup"><span data-stu-id="491ad-233">When choosing a bucket count of 250 million for each of the indexes, the total overhead for the hash tables will be 8 gigabytes.</span></span> <span data-ttu-id="491ad-234">Обратите внимание, что в дополнение к 8 байтам использования памяти каждый индекс добавляется в каждую отдельную строку, что составляет 8 гигабайт в этом сценарии (4 индекса — \* 8 байтов \* 250 000 000 строк).</span><span class="sxs-lookup"><span data-stu-id="491ad-234">Note that this is in addition to the 8 bytes of memory usage each index adds to each individual row, which is 8 gigabytes in this scenario (4 indexes \* 8 bytes \* 250 million rows).</span></span>  
  
 <span data-ttu-id="491ad-235">Полное сканирование таблиц обычно не является критическим для производительности для рабочих нагрузок OLTP.</span><span class="sxs-lookup"><span data-stu-id="491ad-235">Full table scans are not usually in the performance-critical path for OLTP workloads.</span></span> <span data-ttu-id="491ad-236">Таким образом, приходится выбирать между использованием памяти и производительности операций уточняющих запросов и операций вставки.</span><span class="sxs-lookup"><span data-stu-id="491ad-236">Therefore, the choice is between memory utilization versus performance of point lookup and insert operations:</span></span>  
  
-   <span data-ttu-id="491ad-237">Если использование памяти критично, выберите число контейнеров, близкое к числу значений ключа индекса.</span><span class="sxs-lookup"><span data-stu-id="491ad-237">If memory utilization is a concern, choose a bucket count close to the number of index key values.</span></span> <span data-ttu-id="491ad-238">Число контейнеров не должно быть значительно меньше числа значений ключа индекса, поскольку это влияет на большинство операций DML, а также на время, необходимое для восстановления базы данных после перезапуска сервера.</span><span class="sxs-lookup"><span data-stu-id="491ad-238">The bucket count should not be significantly lower than the number of index key values, as this impacts most DML operations as well the time it takes to recover the database after server restart.</span></span>  
  
-   <span data-ttu-id="491ad-239">При оптимизации производительности уточняющих запросов рекомендуется задать число контейнеров, превышающее в два или даже три раза число значений уникального индекса.</span><span class="sxs-lookup"><span data-stu-id="491ad-239">When optimizing the performance for point lookups, a higher bucket count of two or even three times the number of unique index values would be appropriate.</span></span> <span data-ttu-id="491ad-240">Увеличение числа контейнеров означает увеличение использования ресурсов памяти и увеличение времени, необходимого для полного сканирования индекса.</span><span class="sxs-lookup"><span data-stu-id="491ad-240">A higher bucket count would mean an increased memory utilization and an increase in the time required for a full index scan.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="491ad-241">См. также:</span><span class="sxs-lookup"><span data-stu-id="491ad-241">See Also</span></span>  
 [<span data-ttu-id="491ad-242">Индексы для оптимизированных для памяти таблиц</span><span class="sxs-lookup"><span data-stu-id="491ad-242">Indexes on Memory-Optimized Tables</span></span>](../../2014/database-engine/indexes-on-memory-optimized-tables.md)  
  
  

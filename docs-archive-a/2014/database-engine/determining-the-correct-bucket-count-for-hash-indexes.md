---
title: Определение правильного числа контейнеров для хэш-индексов | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 6d1ac280-87db-4bd8-ad43-54353647d8b5
author: stevestein
ms.author: sstein
ms.openlocfilehash: e0579a98e3302b6944f68ca449d3e7cda0ecc01d
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87657267"
---
# <a name="determining-the-correct-bucket-count-for-hash-indexes"></a>Определение правильного числа контейнеров для хэш-индексов
  Необходимо указать значение для параметра `BUCKET_COUNT` при создании оптимизированной для памяти таблицы. Этот раздел содержит рекомендации по определению соответствующего значения для параметра `BUCKET_COUNT`. Если не удается определить нужное число контейнеров, пользуйтесь вместо этого некластеризованным индексом.  Неверное значение `BUCKET_COUNT`, особенно слишком низкое, может значительно повлиять на производительность рабочей нагрузки, а также на время восстановления базы данных. Рекомендуется пересмотреть число контейнеров.  
  
 Повторяющиеся ключи индекса могут ухудшить производительность с хэш-индексом, поскольку ключи хэшируются в один контейнер, в результате чего последовательность этого контейнера увеличивается.  
  
 Дополнительные сведения о некластеризованных хэш-индексах см. в разделах [Hash Indexes](hash-indexes.md) и [Guidelines for Using Indexes on Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).  
  
 Одна хэш-таблица выделяется для каждого хэш-индекса таблицы, оптимизированной для памяти. Размер хэш-таблицы, выделенной для индекса, задается `BUCKET_COUNT` параметром в [CREATE TABLE &#40;TRANSACT-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql) или [CREATE TYPE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-type-transact-sql). Число контейнеров округляется до ближайшей степени числа 2. Например, если указано 300 000 контейнеров, то фактически число контейнеров составит 524 288.  
  
 Ссылки на статьи и видео на тему числа контейнеров см. в разделе [Как определить нужное число контейнеров для хэш-индексов (OLTP в памяти)](https://www.mssqltips.com/sqlservertip/3104/determine-bucketcount-for-hash-indexes-for-sql-server-memory-optimized-tables/).  
  
## <a name="recommendations"></a>Рекомендации  
 В большинстве случаев число контейнеров должно находиться в диапазоне, в 1–2 раза превышающем число уникальных значений в ключе индекса. Если ключ индекса содержит много повторяющихся значений, в среднем более 10 строк на каждое из них, используйте некластеризованный индекс.  
  
 Не всегда можно спрогнозировать количество значений, которые содержит конкретный ключ индекса. Уровень производительности считается приемлемым, если значение `BUCKET_COUNT` входит в диапазон значений, в 5 раз превышающих фактическое число ключевых значений.  
  
 Для определения числа ключей уникального индекса в существующих данных используйте запросы наподобие следующего:  
  
### <a name="primary-key-and-unique-indexes"></a>Первичный ключ и уникальные индексы  
 Так как индекс первичного ключа является уникальным, число различающихся значений в ключе соответствует числу строк в таблице. Для примера первичный ключ включен (SalesOrderID, SalesOrderDetailID) в таблицу Sales.SalesOrderDetail базы данных AdventureWorks; выполните следующий запрос, чтобы вычислить число различающихся значений первичного ключа, которое соответствует количеству строк в таблице.  
  
```sql  
SELECT COUNT(*) AS [row count]   
FROM Sales.SalesOrderDetail  
```  
  
 Этот запрос указывает число строк, равное 121 317. Если число строк значительно не изменится, используйте 240 000 контейнеров. Если ожидается, что количество заказов на продажу в таблице увеличится в четыре раза, укажите 480 000 контейнеров.  
  
### <a name="non-unique-indexes"></a>Неуникальные индексы  
 Для других индексов, например для индекса с несколькими столбцами (SpecialOfferID, ProductID), создайте следующий запрос для определения числа значений уникального индекса:  
  
```sql  
SELECT COUNT(*) AS [SpecialOfferID_ProductID index key count]  
FROM   
   (SELECT DISTINCT SpecialOfferID, ProductID   
    FROM Sales.SalesOrderDetail) t  
```  
  
 Этот запрос возвращает число ключей индекса для SpecialOfferID, ProductID (484), которое указывает на то, что вместо некластеризованного хэш-индекса следует использовать некластеризованный индекс.  
  
### <a name="determining-the-number-of-duplicates"></a>Определение числа повторов  
 Чтобы определить среднее количество повторяющихся значений для ключа индекса, разделите общее количество строк на число ключей уникального индекса.  
  
 Для примера индекса (SpecialOfferID, ProductID) это приводит к 121317/484=251. Таким образом, значения ключа индекса имеют среднее значение 251, поэтому это должен быть некластеризованный индекс.  
  
## <a name="troubleshooting-the-bucket-count"></a>Диагностика и устранение неполадок с числом контейнеров  
 Чтобы устранить проблемы с количеством контейнеров в оптимизированных для памяти таблицах, используйте представление [sys. dm_db_xtp_hash_index_stats &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-hash-index-stats-transact-sql) , чтобы получить статистику по пустым контейнерам и длине цепочек строк. Следующий запрос может быть использован для получения статистики обо всех хэш-индексах в текущей базе данных. При наличии больших таблиц в базе данных выполнение запроса может занять несколько минут.  
  
```sql  
SELECT   
   object_name(hs.object_id) AS 'object name',   
   i.name as 'index name',   
   hs.total_bucket_count,  
   hs.empty_bucket_count,  
   floor((cast(empty_bucket_count as float)/total_bucket_count) * 100) AS 'empty_bucket_percent',  
   hs.avg_chain_length,   
   hs.max_chain_length  
FROM sys.dm_db_xtp_hash_index_stats AS hs   
   JOIN sys.indexes AS i   
   ON hs.object_id=i.object_id AND hs.index_id=i.index_id  
```  
  
 Два ключевых индикатора работоспособности хэш-индекса:  
  
 *empty_bucket_percent*  
 *empty_bucket_percent* указывает число пустых контейнеров в хэш-индексе.  
  
 Если *empty_bucket_percent* имеет значение меньше 10, то число контейнеров, вероятнее всего, будет иметь слишком малое значение. В идеальном случае значение *empty_bucket_percent* должно быть равно 33 процентам или больше. Если число контейнеров соответствует числу значений ключей индекса, то примерно треть контейнеров будет пуста из-за распределения хэша.  
  
 *avg_chain_length*  
 *avg_chain_length* указывает среднюю длину цепочек строк в хэш-контейнерах.  
  
 Если значение *avg_chain_length* больше 10 и *empty_bucket_percent* больше 10, то, вероятнее всего, имеется много одинаковых значений ключей индекса и использование некластеризованного индекса будет более целесообразным. Средняя длина цепочки, равная 1, является оптимальной.  
  
 Существует два фактора, оказывающих влияние на длину цепочки.  
  
1.  Повторы: все повторяющиеся строки являются частью одной цепочки хэш-индекса.  
  
2.  Несколько значений ключей сопоставляются с одним контейнером. Чем меньше число контейнеров, тем больше число контейнеров, которым будет сопоставлено несколько значений.  
  
 В качестве примера рассмотрим следующую таблицу и скрипт для вставки образцов строк в таблицу.  
  
```sql  
CREATE TABLE [Sales].[SalesOrderHeader_test]  
(  
   [SalesOrderID] [uniqueidentifier] NOT NULL DEFAULT (newid()),  
   [OrderSequence] int NOT NULL,  
   [OrderDate] [datetime2](7) NOT NULL,  
   [Status] [tinyint] NOT NULL,  
  
PRIMARY KEY NONCLUSTERED HASH ([SalesOrderID]) WITH ( BUCKET_COUNT = 262144 ),  
INDEX IX_OrderSequence HASH (OrderSequence) WITH ( BUCKET_COUNT = 20000),  
INDEX IX_Status HASH ([Status]) WITH ( BUCKET_COUNT = 8),  
INDEX IX_OrderDate NONCLUSTERED ([OrderDate] ASC),  
)WITH ( MEMORY_OPTIMIZED = ON , DURABILITY = SCHEMA_AND_DATA )  
GO  
  
DECLARE @i int = 0  
BEGIN TRAN  
WHILE @i < 262144  
BEGIN  
   INSERT Sales.SalesOrderHeader_test (OrderSequence, OrderDate, [Status]) VALUES (@i, sysdatetime(), @i % 8)  
   SET @i += 1  
END  
COMMIT  
GO  
```  
  
 Скрипт вставляет в таблицу 262 144 строки. Он вставляет уникальные значения в индекс первичного ключа и в IX_OrderSequence. Он вставляет много повторяющихся значений в IX_Status индекса: скрипт создает только 8 различных значений.  
  
 Выходное значение диагностики и устранения ошибок в запросах BUCKET_COUNT выглядит следующим образом:  
  
|имя индекса|total_bucket_count|empty_bucket_count|empty_bucket_percent|avg_chain_length|max_chain_length|  
|----------------|--------------------------|--------------------------|----------------------------|------------------------|------------------------|  
|IX_Status|8|4|50|65536|65536|  
|IX_OrderSequence|32768|13|0|8|26|  
|PK_SalesOrd_B14003C3F8FB3364|262144|96319|36|1|8|  
  
 Рассмотрим 3 хэш-индекса в этой таблице.  
  
-   IX_Status: 50 % контейнеров пусты, что хорошо. Однако среднее значение длины цепочки очень высоко (65 536). Это указывает на большое количество повторяющихся значений. Поэтому использование некластеризованного хэш-индекса в данном случае не подходит. Вместо этого следует пользоваться некластеризованным индексом.  
  
-   IX_OrderSequence: 0 % контейнеров пусты. Это слишком мало. Кроме того, средняя длина цепочки составляет 8. Поскольку значения в этом индексе являются уникальными, то это значит, что в среднем 8 значений сопоставлены с каждым контейнером. Число контейнеров должно быть увеличено. Поскольку ключ индекса имеет 262 144 уникальных значения, число контейнеров должно быть не менее 262 144. Если ожидается увеличение в будущем, значение должно быть больше.  
  
-   Индекс первичного ключа (PK__SalesOrder...): 36 процентов контейнеров пусты, что является хорошим. Кроме того, средняя длина цепочки имеет значение 1, что тоже является хорошим показателем. Нет необходимости в изменениях.  
  
 Дополнительные сведения о диагностике и устранении неполадок с оптимизированными для памяти хэш-индексами см. в разделе [Troubleshooting Common Performance Problems with Memory-Optimized Hash Indexes](../../2014/database-engine/troubleshooting-common-performance-problems-with-memory-optimized-hash-indexes.md).  
  
## <a name="detailed-considerations-for-further-optimization"></a>Подробные рекомендации для дальнейшей оптимизации  
 В этом разделе описывается более подробные рекомендации по оптимизации числа контейнеров.  
  
 Чтобы добиться наилучшей производительности, для хэш-индексов необходимо учитывать объем памяти, выделяемый для хэш-таблицы, и число разных значений в ключе индекса. Также существует зависимость между производительностью уточняющих запросов и сканирования таблиц.  
  
-   Чем выше значение числа контейнеров, тем больше пустых контейнеров будет в индексе. Это влияет на использование памяти (8 байт на сегмент) и производительность просмотров таблиц, так как в процессе просмотра таблицы сканируется каждый контейнер.  
  
-   Чем меньше число контейнеров, тем больше значений присваиваются каждому контейнеру. В этом случае снижается производительность уточняющих запросов и вставок, поскольку [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] может потребоваться перебор нескольких значений в одном контейнере для нахождения значения, указанного предикатом поиска.  
  
 Если число контейнеров значительно меньше числа ключей уникального индекса, то с каждым контейнером будет сопоставлено множество значений. Это снижает производительность большинства операций DML, в частности уточняющих запросов (поиска отдельных ключей индекса) и операций вставки. Например, может снизиться производительность запросов SELECT и операций UPDATE и DELETE с предикатами равенства, сопоставляющих ключевые столбцы индекса в предложении WHERE. Малое число контейнеров также влияет на время восстановления базы данных, поскольку индексы создаются заново при запуске базы данных.  
  
### <a name="duplicate-index-key-values"></a>Повторяющиеся значения ключа индекса  
 Повторяющиеся значения могут увеличить влияние на производительность конфликтов хэш-значений. Как правило, не является серьезной проблемой, если в каждом ключе индекса имеется небольшое количество повторов. Однако это может вызвать проблемы при значительном несоответствии числа уникальных ключей индекса и числа строк в таблице.  
  
 Все строки с одинаковым значением ключа индекса помещаются в одну и ту же цепочку повторов. Если для нескольких ключей индекса в том же контейнере ожидается конфликт хэш-индексов, сканерам индексов всегда необходимо выполнять сканирование полной цепочки повторов на наличие первого значения, только после этого они смогут найти первую строку, соответствующую второму значению. Повторяющиеся ключи также затрудняют процессу сборки мусора обнаружение строки. Например, если есть 1000 повторяющихся ключей, то при удалении одной из строк сборщик мусора должен просканировать цепь из 1000 повторяющихся элементов, чтобы убрать строку из индекса. Это верно, даже если запрос, по которому было найдено удаление, использовал более эффективный индекс (индекс первичного ключа), чтобы найти строку, поскольку сборщику мусора нужно удалить связи из каждого индекса  
  
 Для хэш-индексов есть два способа уменьшить нагрузку, вызванную повторяющимися значениями ключей.  
  
-   Вместо это используйте некластеризованный индекс. Можно уменьшить повторяющиеся значения, добавив столбцы к ключу индекса, без необходимости внесения каких-либо изменений в приложение.  
  
-   Укажите очень большое число контейнеров для индекса. Например, в 20–100 раз больше число ключей уникального индекса. Это позволит уменьшить количество конфликтов хэш-значений.  
  
### <a name="small-tables"></a>Небольшие таблицы  
 Для небольших таблиц использование памяти обычно не столь важно, так как размер индекса будет небольшим по сравнению с общим размером базы данных.  
  
 Теперь необходимо сделать выбор на основе необходимого уровня производительности.  
  
-   Если операции, чья производительность является критичной в индексе в большинстве случаев являются уточняющими запросами и операциями вставки, то рекомендуется увеличить число контейнеров для уменьшения вероятности возникновения конфликта хэш-индексов. Оптимальная рекомендация — увеличить число строк в три раза и даже более.  
  
-   Если полное сканирование индекса является по большей части операций, чья производительность критична, используйте число контейнеров, близкое к фактическому числу значений ключа индекса.  
  
### <a name="big-tables"></a>Большие таблицы  
 Для больших таблиц использование памяти может стать проблемой. Например, если таблица строк 250 000 000 содержит 4 хэш-индекса, каждый из которых имеет число контейнеров, равное 1 000 000 000, то затраты для хэш-таблиц составляет 4 индекса * 1 000 000 000 контейнеров \* 8 байт = 32 гигабайта использования памяти. При выборе числа контейнеров, равного 250 миллионов, для всех индексов общий объем используемой памяти для хэш-таблиц составит 8 ГБ. Обратите внимание, что в дополнение к 8 байтам использования памяти каждый индекс добавляется в каждую отдельную строку, что составляет 8 гигабайт в этом сценарии (4 индекса — \* 8 байтов \* 250 000 000 строк).  
  
 Полное сканирование таблиц обычно не является критическим для производительности для рабочих нагрузок OLTP. Таким образом, приходится выбирать между использованием памяти и производительности операций уточняющих запросов и операций вставки.  
  
-   Если использование памяти критично, выберите число контейнеров, близкое к числу значений ключа индекса. Число контейнеров не должно быть значительно меньше числа значений ключа индекса, поскольку это влияет на большинство операций DML, а также на время, необходимое для восстановления базы данных после перезапуска сервера.  
  
-   При оптимизации производительности уточняющих запросов рекомендуется задать число контейнеров, превышающее в два или даже три раза число значений уникального индекса. Увеличение числа контейнеров означает увеличение использования ресурсов памяти и увеличение времени, необходимого для полного сканирования индекса.  
  
## <a name="see-also"></a>См. также:  
 [Индексы для оптимизированных для памяти таблиц](../../2014/database-engine/indexes-on-memory-optimized-tables.md)  
  
  

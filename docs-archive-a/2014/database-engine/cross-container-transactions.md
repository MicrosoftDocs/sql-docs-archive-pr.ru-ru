---
title: Транзакции между контейнерами | Документация Майкрософт
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 5d84b51a-ec17-4c5c-b80e-9e994fc8ae80
author: stevestein
ms.author: sstein
ms.openlocfilehash: 28437f0903459616a574e713c0f138e8bb459870
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87664469"
---
# <a name="cross-container-transactions"></a>Транзакции между контейнерами
  Транзакции между контейнерами представляют собой неявные или явные пользовательские транзакции, включающие вызовы хранимых процедур, скомпилированных в собственном коде, или операции над оптимизированными для памяти таблицами.  
  
 В [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] вызовы хранимых процедур не инициируют транзакцию. Выполнение хранимых процедур, скомпилированных в собственном коде, в режиме автоматической фиксации (не в контексте пользовательской транзакции) не считается транзакциями между контейнерами.  
  
 Любой интерпретируемый запрос, который ссылается на оптимизированные для памяти таблицы, считается частью транзакции между контейнерами, как при выполнении из явных или неявных транзакций, так и в режиме автоматической фиксации.  
  
##  <a name="isolation-of-individual-operations"></a><a name="isolation"></a>Изоляция отдельных операций  
 Каждая транзакция [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] имеет уровень изоляции. Уровень изоляции по умолчанию — READ COMMITTED. Чтобы использовать другой уровень изоляции, можно задать уровень изоляции с помощью [инструкции SET TRANSACTION изоляцией &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-transaction-isolation-level-transact-sql).  
  
 Часто приходится выполнять операции над оптимизированными для памяти таблицами с другим уровнем изоляции, чем операции над дисковыми таблицами. В транзакции можно задать другой уровень изоляции для коллекции инструкций или отдельной операции считывания.  
  
### <a name="specifying-the-isolation-level-of-individual-operations"></a>Задание уровня изоляции отдельных операций  
 Чтобы задать другой уровень изоляции для набора инструкций в транзакции, можно использовать `SET TRANSACTION ISOLATION LEVEL`. В следующем примере транзакции по умолчанию используется уровень изоляции SERIALIZABLE. Операции вставки и выбора над t3, t2 и t1 выполняются при использовании уровня изоляции REPEATABLE READ.  
  
```sql  
set transaction isolation level serializable  
go  
  
begin transaction  
 ......  
  set transaction isolation level repeatable read  
  
  insert t3 select * from t1 join t2 on t1.id=t2.id  
  
  set transaction isolation level serializable  
 ......  
commit  
```  
  
 Чтобы задать уровень изоляции для отдельных операций чтения, отличный от назначаемого транзакции по умолчанию, можно использовать табличное указание (например, SERIALIZABLE). Каждый выбор соответствует операции считывания, а каждое обновление и каждое удаление соответствуют чтению, поскольку строку всегда необходимо прочитать, прежде чем ее можно будет обновить или удалить. Операции вставки не имеют уровня изоляции, поскольку запись всегда изолирована в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. В следующем примере уровень изоляции по умолчанию для транзакций — READ COMMITTED, но доступ к таблице t1 происходит в режиме изоляции SERIALIZABLE, а к таблице t2 — в режиме изоляции SNAPSHOT.  
  
```sql  
set transaction isolation level read committed  
go  
  
begin transaction  
 ......  
  
  insert t3 select * from t1 (serializable) join t2 (snapshot) on t1.id=t2.id  
  
  ......  
commit  
```  
  
### <a name="isolation-semantics-for-individual-operations"></a>Семантика изоляции для отдельных операций  
 Cериализуемая транзакция T выполняется в полной изоляции. То есть как бы каждая другая транзакция зафиксирована перед запуском T или запущена после фиксации T. Ситуация становится более сложной, если различные операции в транзакции имеют разные уровни изоляции.  
  
 Общая семантика уровней изоляции транзакций в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] , а также влияние на блокировку, объясняется в описании [инструкции SET TRANSACTION изоляцией Level &#40;TRANSACT-SQL&#41;](/sql/t-sql/statements/set-transaction-isolation-level-transact-sql).  
  
 Для транзакций между контейнерами, где различные операции могут иметь различные уровни изоляции, необходимо понимать семантику изоляции отдельных операций чтения. Операции записи всегда изолированы. Записи в разных транзакциях не могут повлиять друг на друга.  
  
 Операция считывания данных возвращает несколько строк, удовлетворяющих условию фильтра.  
  
 Операции чтения выполняются как часть транзакции T. уровни изоляции для операций чтения могут быть понятны с точки зрения,  
  
 Состояние фиксации  
 Состояние фиксации указывает, гарантирована ли фиксация считывания данных.  
  
 Согласованность (транзакций)  
 Согласованность транзакций для набора операция чтения показывает, гарантировано ли, что чтение версий строк будет включать обновления из точно такого же набора транзакций.  
  
 Гарантии стабильности система дает транзакции T относительно считывания данных.  
 Стабильность определяет, являются ли операции чтения транзакций повторяемыми. То есть, если операции чтения повторяются, возвратят ли они одни и те же строки и версии строк?  
  
 Некоторые гарантии относятся ко времени логического завершения транзакции. В целом время логического завершения — это время фиксации транзакции в базе данных. Если транзакция выполняет доступ к оптимизируемым для памяти таблицам, то время логического завершения технически представляет собой начало этапа проверки. (Дополнительные сведения см. в статье обсуждение времени существования транзакций в [транзакциях в таблицах, оптимизированных для памяти](../relational-databases/in-memory-oltp/memory-optimized-tables.md).  
  
 Независимо от уровня изоляции транзакция (T) всегда видит свои собственные обновления.  
  
 READ UNCOMMITTED  
 Чтение данных не может быть зафиксировано, согласовано или стабильно. Однако оно содержит операции записи, выполненные ранее транзакцией T.  
  
 READ COMMITTED  
 Считывание данных будет зафиксировано.  
  
 SNAPSHOT  
 Все операции считывания, выполняемые транзакцией T в режиме изоляции SNAPSHOT, имеют то же время логического чтения, которое представляет собой начало транзакции. Считывание данных гарантированно фиксируется и согласовано для времени логического чтения. Повтор чтения во время первоначального чтения гарантированно возвращает тот же результат.  
  
 REPEATABLE READ  
 Считывание данных гарантированно фиксируется и стабильно до времени логического завершения транзакции.  
  
 SERIALIZABLE  
 Все гарантии возможности ПОВТОРЯЕМого чтения и фантомного исключения, а также согласованность транзакций в отношении всех сериализуемых операций чтения, выполняемых T. фантомное исключение означает, что операция просмотра может возвращать только дополнительные строки, записанные T, но не строки, записанные другими транзакциями.  
  
 Рассмотрим следующую транзакцию:  
  
```sql  
set transaction isolation level read committed  
go  
  
begin transaction  
  -- remove all rows from t3; the related read operation is performed under read committed   
  -- isolation, as this is the default for the transaction  
  delete from t3  
  
  -- copy the contents from t1 to t3; the read on t1 is performed under the serializable   
  -- isolation level  
  insert t3 select * from t1 (serializable)  
  
  -- compare t3 and t1; note: the result set may not be empty, as rows may have been added   
  -- by other transaction before this select, due to the read committed isolation level  
  select * from t3 except t1  
  
  -- compare t1 and t3; note: the result set is empty, as no rows have been added to t1   
  -- since its contents were copied to t1, due to the serializable isolation level  
  select * from t1 except t3  
commit  
```  
  
 Эта транзакция удаляет все строки из t3 в режиме изоляции READ COMMITTED, копирует все строки от t1 до t3 в режиме изоляции SERIALIZABLE, а затем сравнивает t1 и t3. Некоторые строки [не в t1] могут быть добавлены к t3, поскольку таблица стала пустой. Строки не были добавлены к t1, так как копия была сериализуемая.  
  
 Несмотря на то, что чтение из T1 в конце транзакции выполняется по синтаксическим операциям чтения, оно эффективно сериализуется, так как в транзакции в режиме сериализуемой изоляции было выполнено такое же считывание. возможности сериализации гарантирует, что если операция чтения выполняется в любой более поздней точке транзакции, возвращаются те же строки.  
  
## <a name="cross-container-transactions-and-isolation-levels"></a>Транзакции между контейнерами и уровни изоляции  
 Транзакции между контейнерами могут рассматриваться как две стороны: дисковая сторона (для операций с таблицами на диске) и оптимизированная для памяти сторона (для операций с оптимизированными для памяти таблицами). Уровни изоляции этих двух сторон могут быть различными. В действительности отдельные операции чтения с каждой стороны могут иметь различные уровни изоляции.  
  
 Дисковая сторона данной транзакции T достигает определенного уровня изоляции X, если выполняется одно из следующих условий.  
  
-   Он начинается с X. То есть сеанс по умолчанию имел значение X, так как вы выполнили `SET TRANSACTION ISOLATION LEVEL` или это значение [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] по умолчанию.  
  
-   Во время транзакции уровень изоляции по умолчанию изменяется на X с помощью `SET TRANSACTION ISOLATION LEVEL`.  
  
-   Операция считывания в дисковой таблице выполняется на уровне изоляции X с использованием синтаксиса `WITH (X)`.  
  
 Сторона оптимизированной для памяти T достигает уровня изоляции Y, если во время выполнения T любая операция считывания в таблице, оптимизированной для памяти, или любая хранимая процедура, скомпилированная в собственном коде, выполняется с уровнем изоляции Y.  
  
 В качестве примера рассмотрим следующую транзакцию. В данном случае t1 и t2 — дисковые таблицы, а t3 и t4 — оптимизированные для памяти таблицы.  
  
 Дисковая сторона транзакции достигает уровня изоляции READ COMMITTED, поскольку запускается на данном уровне. Дисковая сторона также достигает уровня изоляции REPEATABLE READ, так как первая операция чтения выполняется на этом уровне изоляции. Удаление в конце транзакции выполняется с уровнем изоляции READ COMMITTED, поэтому не вызывает перехода на новый уровень изоляции.  
  
 Часть транзакции, оптимизированной для памяти, может достигать одного из двух уровней: Если condition1 имеет значение true, то достигается сериализуемый, а если значение false, то оптимизированная для памяти часть достигает только изоляции моментального снимка.  
  
```sql  
set transaction isolation level read committed  
go  
  
begin transaction  
  select * from t1 (repeatableread)  
  
  if condition1 begin  
    insert t3 select * from t4 (serializable)  
  end  
  else begin  
    insert t3 select * from t4 (snapshot)  
  end  
  
  delete from t1  
commit  
```  
  
### <a name="supported-isolation-levels-for-cross-container-transactions"></a>Поддерживаемые уровни изоляции для транзакций между контейнерами  
 Существуют ограничения на уровни изоляции, используемые с операциями над оптимизированными для памяти таблицами в транзакциях между контейнерами.  
  
 Оптимизированные для памяти таблицы поддерживают уровни изоляции SNAPSHOT, REPEATABLE READ и SERIALIZABLE. Для транзакций с автоматической фиксацией оптимизированные для памяти таблицы поддерживают уровень изоляции READ COMMITTED.  
  
 Поддерживаются следующие сценарии:  
  
-   Транзакции между контейнерами READ UNCOMMITTED, READ COMMITTED и READ_COMMITTED_SNAPSHOT могут получить доступ к оптимизированным для памяти таблицам в режиме изоляции SNAPSHOT, REPEATABLE READ и SERIALIZABLE. Гарантия READ COMMITTED действует для транзакции; все строки, считанные транзакцией, были зафиксированы в базе данных.  
  
-   Транзакции REPEATABLE READ и SERIALIZABLE могут получить доступ к оптимизированным для памяти таблицам в режиме изоляции SNAPSHOT.  
  
## <a name="read-only-cross-container-transactions"></a>Транзакции между контейнерами только для чтения  
 Большинство транзакции только для чтения в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] откатываются в момент фиксации. Поскольку отсутствуют изменения, которые будут зафиксированы в базе данных, система просто освобождает ресурсы, используемые транзакцией. Для дисковых транзакций только для чтения все блокировки, сделанные транзакцией, снимаются в данный момент. Оптимизированные для памяти транзакции только для чтения, которые занимают одну скомпилированную в собственном коде хранимую процедуру, не проверяются.  
  
 Транзакции только для чтения между контейнерами в режиме автоматической фиксации просто откатываются в конце транзакции. Проверка не произведена.  
  
 Явные или неявные транзакции только для чтения между контейнерами выполняют проверку в момент фиксации, если транзакция обращается к таблицам с оптимизацией для памяти в уровне изоляции REPEATABLE READ или SERIALIZABLE. Дополнительные сведения о проверке см. в разделе об обнаружении конфликтов, проверке и проверке зависимостей фиксации в [транзакциях в таблицах, оптимизированных для памяти](../relational-databases/in-memory-oltp/memory-optimized-tables.md).  
  
## <a name="see-also"></a>См. также:  
 [Основные сведения о транзакциях в таблицах, оптимизированных для памяти](../../2014/database-engine/understanding-transactions-on-memory-optimized-tables.md)   
 [Рекомендации по уровню изоляции транзакций с таблицами, оптимизированными для памяти](../../2014/database-engine/guidelines-for-transaction-isolation-levels-with-memory-optimized-tables.md)   
 [Рекомендации для логики повторного выполнения транзакций для таблиц, оптимизированных для памяти](../../2014/database-engine/guidelines-for-retry-logic-for-transactions-on-memory-optimized-tables.md)  
  
  

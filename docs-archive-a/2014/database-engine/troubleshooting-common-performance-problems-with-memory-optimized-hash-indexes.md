---
title: Устранение распространенных проблем с производительностью с помощью хэш-индексов, оптимизированных для памяти | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 1954a997-7585-4713-81fd-76d429b8d095
author: stevestein
ms.author: sstein
ms.openlocfilehash: 3cef98571edd7736bc45ba8caf17451007a74cf1
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87728670"
---
# <a name="troubleshooting-common-performance-problems-with-memory-optimized-hash-indexes"></a>Диагностика общих проблем с производительностью хэш-индексов оптимизированными для памяти таблиц
  В этом разделе рассматривается устранение неполадок и обходные пути для распространенных проблем с хэш-индексами.  
  
## <a name="search-requires-a-subset-of-hash-index-key-columns"></a>Поиску требуется подмножество ключевых столбцов хэш-индекса  
 **Вопрос.** Хэш-индексы должны иметь значения для всех ключевых столбцов индекса, чтобы вычислить хэш-значение, а также указать соответствующие строки в хэш-таблице. Поэтому если запрос включает предикаты равенства только для подмножества ключей индекса в предложении WHERE, то [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] не может использовать поиск по индексу для нахождения строк, соответствующих предикатам в предложении WHERE.  
  
 Наоборот, упорядоченные индексы, так же как дисковые некластеризованные индексы и оптимизированные для памяти некластеризованные индексы, поддерживают поиск по индексу для подмножества ключевых столбцов индекса, если такие столбцы находятся в первых столбцах в индексе.  
  
 **Симптом:** Это приводит к снижению производительности, так как [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] для выполнения полного сканирования таблицы требуется выполнить полное сканирование таблиц, а не поиск по индексу, что обычно является более быстрой операцией.  
  
 **Устранение неполадок.** Помимо снижения производительности, проверка планов запросов покажет проверку, а не поиск по индексу. Если запрос простой, проверка текста запроса и определения индекса также покажет, требуется ли поиску подмножество ключевых столбцов индекса.  
  
 Рассмотрим следующую таблицу и запрос.  
  
```sql  
CREATE TABLE [dbo].[od]  
(  
     o_id INT NOT NULL,  
     od_id INT NOT NULL,  
     p_id INT NOT NULL,  
     CONSTRAINT PK_od PRIMARY KEY NONCLUSTERED HASH (o_id, od_id) WITH (BUCKET_COUNT = 10000)  
)  
WITH (MEMORY_OPTIMIZED = ON)  
  
 SELECT p_id  
 FROM dbo.od  
 WHERE o_id=1  
```  
  
 Таблица содержит хэш-индекс для двух столбцов (o_id, od_id), в то время как в запросе есть предикат равенства для (o_id). Так как запрос имеет предикаты равенства только для подмножества ключевых столбцов индекса, [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] не сможет выполнить поиск по индексу с помощью PK_od, вместо этого [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] вынужденно вернется к полному просмотру индекса.  
  
 **Обходные пути:** Существует несколько возможных обходных путей. Пример:  
  
-   Создайте заново индекс некластеризованного типа вместо некластеризованного хэша. Оптимизированный для памяти некластеризованный индекс упорядочен, поэтому [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] сможет выполнить поиск по индексу в тех ключевых столбцах индекса, которые находятся в начале. Результирующее определение первичного ключа в этом примере будет следующим: `constraint PK_od primary key nonclustered`.  
  
-   Измените текущий ключ индекса так, чтобы он соответствовал столбцам в предложении WHERE.  
  
-   Добавьте новый хэш-индекс, который совпадает со столбцами в предложении WHERE запроса. В данном случае определение результирующей таблицы будет выглядеть следующим образом.  
  
    ```sql  
    CREATE TABLE dbo.od  
     ( o_id INT NOT NULL,  
     od_id INT NOT NULL,  
     p_id INT NOT NULL,  
  
     CONSTRAINT PK_od PRIMARY KEY   
     NONCLUSTERED HASH (o_id,od_id) WITH (BUCKET_COUNT=10000),  
  
     INDEX ix_o_id NONCLUSTERED HASH (o_id) WITH (BUCKET_COUNT=10000)  
  
     ) WITH (MEMORY_OPTIMIZED=ON)  
    ```  
  
 Обратите внимание, что оптимизированный для памяти хэш-индекс не работает оптимально при наличии большого количества повторяющихся строк для заданного значения ключа индекса. в этом примере, если число уникальных значений для столбца o_id намного меньше, чем количество строк в таблице, не было бы оптимальным добавлять индекс в (o_id). Вместо этого лучшим решением будет изменение типа индекса PK_od от hash к некластеризованному. Дополнительные сведения см. в разделе [Determining the Correct Bucket Count for Hash Indexes](../relational-databases/indexes/indexes.md).  
  
## <a name="see-also"></a>См. также:  
 [Индексы для оптимизированных для памяти таблиц](../relational-databases/in-memory-oltp/memory-optimized-tables.md)  
  
  

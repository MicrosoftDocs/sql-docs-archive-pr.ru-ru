---
title: Рекомендации по уровню изоляции транзакций с таблицами, оптимизированными для памяти | Документация Майкрософт
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: e365e9ca-c34b-44ae-840c-10e599fa614f
author: stevestein
ms.author: sstein
ms.openlocfilehash: 834c5950a8f8b0ddf8854d06c6fb1073a264fc22
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87732918"
---
# <a name="guidelines-for-transaction-isolation-levels-with-memory-optimized-tables"></a><span data-ttu-id="d8c9e-102">Рекомендации для уровней изоляции транзакций с таблицами, оптимизированными для памяти</span><span class="sxs-lookup"><span data-stu-id="d8c9e-102">Guidelines for Transaction Isolation Levels with Memory-Optimized Tables</span></span>
  <span data-ttu-id="d8c9e-103">Во многих сценариях необходимо указать уровень изоляции транзакции.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-103">In many scenarios, you must specify the transaction isolation level.</span></span> <span data-ttu-id="d8c9e-104">Уровень изоляции транзакции для таблиц, оптимизированных для памяти, отличается от уровня для таблиц, сохраняемых на диске.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-104">Transaction isolation for memory-optimized tables differs from disk-based tables.</span></span>  
  
 <span data-ttu-id="d8c9e-105">Требования для указания уровня изоляции транзакции:</span><span class="sxs-lookup"><span data-stu-id="d8c9e-105">Requirements for specifying transaction isolation level:</span></span>  
  
-   <span data-ttu-id="d8c9e-106">TRANSACTION ISOLATION LEVEL — это обязательный параметр для блока ATOMIC, который включает содержимое хранимой процедуры, скомпилированной в собственном коде.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-106">TRANSACTION ISOLATION LEVEL is a required option for the ATOMIC block comprising the content of a natively compiled stored procedure.</span></span>  
  
-   <span data-ttu-id="d8c9e-107">Из-за ограничений, применяемых к уровням изоляции в кросс-контейнерных транзакциях, использование таблиц с оптимизацией для памяти в интерпретируемых инструкциях [!INCLUDE[tsql](../includes/tsql-md.md)] часто следует сопровождать табличным указанием уровня изоляции, используемого для доступа к таблице.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-107">Because of restrictions on isolation level use in cross-container transactions, uses of memory-optimized tables in interpreted [!INCLUDE[tsql](../includes/tsql-md.md)] must often be accompanied by a table hint specifying the isolation level used to access the table.</span></span> <span data-ttu-id="d8c9e-108">Дополнительные сведения о подсказках уровней изоляции и транзакциях между контейнерами см. в разделе [уровни изоляции транзакций](../../2014/database-engine/transaction-isolation-levels.md).</span><span class="sxs-lookup"><span data-stu-id="d8c9e-108">For more information about isolation level hints and cross-container transactions, see [Transaction Isolation Levels](../../2014/database-engine/transaction-isolation-levels.md).</span></span>  
  
-   <span data-ttu-id="d8c9e-109">Заданный уровень изоляции транзакции должен быть явно объявлен.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-109">The desired transaction isolation level must be explicitly declared.</span></span> <span data-ttu-id="d8c9e-110">Нельзя использовать подсказки блокировки (например, XLOCK), чтобы обеспечить изоляцию определенных строк или таблиц в транзакции.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-110">It is not possible to use locking hints (such as XLOCK) to guarantee the isolation of certain rows or tables in the transaction.</span></span>  
  
-   <span data-ttu-id="d8c9e-111">Приложение, которое обращается к базе данных, должно реализовать логику повторов для обработки ошибок, возникающих в результате конфликтов транзакций, ошибок проверки и ошибок, связанных с зависимостью фиксации.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-111">The application accessing the database should implement retry logic to deal with errors resulting from transaction-dooming conflicts, validation failures, and commit-dependency failures.</span></span> <span data-ttu-id="d8c9e-112">Обратите внимание, что ошибки зависимости фиксации могут возникать даже в транзакциях только для чтения.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-112">Note that commit dependency failures can occur even with read-only transactions.</span></span>  
  
-   <span data-ttu-id="d8c9e-113">Следует избегать длительных транзакций при работе с таблицами, оптимизированными для памяти.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-113">Long-running transactions should be avoided with memory-optimized tables.</span></span> <span data-ttu-id="d8c9e-114">Такие транзакции увеличивают вероятность конфликтов и прерывания последующих транзакций.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-114">Such transactions increase the likelihood of conflicts and subsequent transaction terminations.</span></span> <span data-ttu-id="d8c9e-115">Выполнение длительной транзакции приводит к откладыванию сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-115">A long-running transaction also defers garbage collection.</span></span> <span data-ttu-id="d8c9e-116">Чем дольше выполняется транзакция, тем дольше In-Memory OLTP хранит недавно удаленные версии строк, что может уменьшить производительность подстановки при выполнении новых транзакций.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-116">The longer a transaction runs, the longer In-Memory OLTP keeps recently deleted row versions, which can decrease lookup performance for new transactions.</span></span>  
  
 <span data-ttu-id="d8c9e-117">Таблицы, сохраняемые на диске, обычно реализуют блокировку для изоляции транзакций.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-117">Disk-based tables typically rely on locking and blocking for transaction isolation.</span></span> <span data-ttu-id="d8c9e-118">Таблицы, оптимизированные для памяти, обеспечивают изоляцию через управление разными версиям и обнаружение конфликтов.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-118">Memory-optimized tables rely on multi-versioning and conflict detection to guarantee isolation.</span></span> <span data-ttu-id="d8c9e-119">Дополнительные сведения см. в разделе об обнаружении конфликтов, проверке и проверке зависимостей фиксации в [транзакциях в таблицах, оптимизированных для памяти](../relational-databases/in-memory-oltp/memory-optimized-tables.md).</span><span class="sxs-lookup"><span data-stu-id="d8c9e-119">For details, see the section on Conflict Detection, Validation, and Commit Dependency Checks in [Transactions in Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).</span></span>  
  
 <span data-ttu-id="d8c9e-120">Таблицы, сохраняемые на диске, позволяет управлять разными версиями с уровнями изоляции SNAPSHOT и READ_COMMITTED_SNAPSHOT.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-120">Disk-based tables do allow multi-versioning with the isolation levels SNAPSHOT and READ_COMMITTED_SNAPSHOT.</span></span> <span data-ttu-id="d8c9e-121">Для таблиц, оптимизированных для памяти, все уровни изоляции основываются на управлении разными версиями, включая REPEATABLE READ и SERIALIZABLE.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-121">For memory-optimized tables all isolation levels are multi-version based, including REPEATABLE READ and SERIALIZABLE.</span></span>  
  
## <a name="types-of-transactions"></a><span data-ttu-id="d8c9e-122">Типы транзакций</span><span class="sxs-lookup"><span data-stu-id="d8c9e-122">Types of Transactions</span></span>  
 <span data-ttu-id="d8c9e-123">Каждый запрос в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] выполняется в контексте транзакции.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-123">Every query in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] runs in the context of a transaction.</span></span>  
  
 <span data-ttu-id="d8c9e-124">В [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] существует три типа транзакций.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-124">There are three types of transactions in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]:</span></span>  
  
-   <span data-ttu-id="d8c9e-125">Транзакции с автоматической фиксацией.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-125">Autocommit transactions.</span></span> <span data-ttu-id="d8c9e-126">Если нет активного контекста транзакции и в сеансе не включены неявные транзакции, каждый запрос будет иметь собственный контекст транзакции.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-126">If there is no active transaction context and implicit transactions are not set to ON in the session, each query has its own transaction context.</span></span> <span data-ttu-id="d8c9e-127">Транзакция запускается, когда начинается исполнение инструкции, и завершается при завершении инструкции.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-127">The transaction starts when the statement starts execution, and completes when the statement finishes.</span></span>  
  
-   <span data-ttu-id="d8c9e-128">Явные транзакции.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-128">Explicit transactions.</span></span> <span data-ttu-id="d8c9e-129">Пользователь запускает транзакцию с помощью явных инструкций BEGIN TRAN или BEGIN ATOMIC.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-129">The user starts the transaction through an explicit BEGIN TRAN or BEGIN ATOMIC.</span></span> <span data-ttu-id="d8c9e-130">Транзакция завершается после соответствующей инструкции COMMIT, ROLLBACK или END (для блока ATOMIC).</span><span class="sxs-lookup"><span data-stu-id="d8c9e-130">The transaction is completed following the corresponding COMMIT and ROLLBACK or END (in the case of an atomic block).</span></span>  
  
-   <span data-ttu-id="d8c9e-131">Неявные транзакции.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-131">Implicit transactions.</span></span> <span data-ttu-id="d8c9e-132">Если параметр IMPLICIT_TRANSACTIONS установлен в значение ON, транзакция запускается неявно каждый раз, когда пользователь выполняет инструкцию и активный контекст транзакции отсутствует.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-132">When the option IMPLICIT_TRANSACTIONS is set to ON, a transaction is started implicitly whenever the user executes a statement and there is no active transaction context.</span></span> <span data-ttu-id="d8c9e-133">Транзакция завершается посредством явной инструкции COMMIT или ROLLBACK.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-133">The transaction is completed through an explicit COMMIT and ROLLBACK.</span></span>  
  
## <a name="baseline-read-committed-isolation"></a><span data-ttu-id="d8c9e-134">Базовая изоляция READ COMMITTED</span><span class="sxs-lookup"><span data-stu-id="d8c9e-134">Baseline READ COMMITTED Isolation</span></span>  
 <span data-ttu-id="d8c9e-135">READ COMMITTED — это уровень изоляции по умолчанию в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="d8c9e-135">READ COMMITTED is the default isolation level in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span>  
  
 <span data-ttu-id="d8c9e-136">Уровень изоляции READ COMMITTED гарантирует, что транзакции не обнаруживают какие-либо незафиксированные данные из любых изменений за пределами текущей транзакции.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-136">The isolation level READ COMMITTED guarantees that transactions do not see any uncommitted data from changes outside the current transaction.</span></span> <span data-ttu-id="d8c9e-137">Другими словами, транзакция считывает только те данные, которые были либо зафиксированы в базе данных, либо изменены текущей транзакцией.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-137">In other words, the transaction only reads data which has either been committed to the database, or has been changed by the current transaction.</span></span>  
  
 <span data-ttu-id="d8c9e-138">Все поддерживаемые уровни изоляции оптимизированных для памяти таблиц обеспечивают применение зафиксированных операций чтения.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-138">All isolation levels supported for memory-optimized tables provide the read committed guarantee.</span></span> <span data-ttu-id="d8c9e-139">Поэтому, если транзакция не требует более жестких гарантий, можно использовать любые поддерживаемые уровни изоляции для таблиц, оптимизированных для памяти.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-139">Therefore, if the transaction does not require stronger guarantees, you can use any of the isolation levels supported for memory-optimized tables.</span></span> <span data-ttu-id="d8c9e-140">SNAPSHOT использует минимальный объем системных ресурсов по сравнению с другими уровнями изоляции.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-140">SNAPSHOT uses the fewest system resources, compared to other isolation levels.</span></span>  
  
 <span data-ttu-id="d8c9e-141">Гарантия, обеспечиваемая уровнем изоляции SNAPSHOT (самый низкий уровень изоляции, поддерживаемый для таблиц, оптимизированных для памяти), включает гарантию READ COMMITTED.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-141">The guarantee provided by the SNAPSHOT isolation level (the lowest level of isolation supported for memory-optimized tables) includes the guarantees of READ COMMITTED.</span></span> <span data-ttu-id="d8c9e-142">Каждая инструкция в транзакции считывает одинаковую, согласованную версию базы данных.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-142">Every statement in the transaction reads the same, consistent version of the database.</span></span> <span data-ttu-id="d8c9e-143">Все строки, считываемые транзакцией, фиксируются в базе данных, кроме того, все операции чтения видят набор изменений, внесенных одним и тем же набором транзакций.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-143">Not only are all the rows read by the transaction committed to the database, also all the read operations see the set of changes made by the same set of transactions.</span></span>  
  
 <span data-ttu-id="d8c9e-144">**Рекомендация**: Если требуется только гарантия изоляции READ COMMITTED, используйте изоляцию моментального снимка с хранимыми процедурами, скомпилированными в собственном коде, а также для доступа к оптимизированным для памяти таблицам с помощью интерпретации [!INCLUDE[tsql](../includes/tsql-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="d8c9e-144">**Guideline**: If only the READ COMMITTED isolation guarantee is required, use SNAPSHOT isolation with natively compiled stored procedures and for accessing memory-optimized tables through interpreted [!INCLUDE[tsql](../includes/tsql-md.md)].</span></span>  
  
 <span data-ttu-id="d8c9e-145">Для транзакций с автоматической фиксацией уровень изоляции READ COMMITTED неявным образом сопоставляется с уровнем SNAPSHOT для таблиц, оптимизированных для памяти.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-145">For autocommit transactions, the isolation level READ COMMITTED is implicitly mapped to SNAPSHOT for memory-optimized tables.</span></span> <span data-ttu-id="d8c9e-146">Поэтому, если параметр сеанса TRANSACTION ISOLATION LEVEL установлен в значение READ COMMITTED, нет необходимости указывать уровень изоляции посредством табличного указания при доступе к таблицам, оптимизированным для памяти.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-146">Therefore, if the TRANSACTION ISOLATION LEVEL session setting is set to READ COMMITTED, it is not necessary to specify the isolation level through a table hint when accessing memory-optimized tables.</span></span>  
  
 <span data-ttu-id="d8c9e-147">В следующем примере транзакции с автоматической фиксацией показано соединение между таблицей Customers с оптимизацией для памяти и обычной таблицей [Order History] в составе нерегламентированного пакета:</span><span class="sxs-lookup"><span data-stu-id="d8c9e-147">The following autocommit transaction example shows a join between a memory-optimized table Customers and a regular table [Order History], as part of an ad hoc batch:</span></span>  
  
```sql  
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;  
GO  
SELECT *   
FROM dbo.Customers AS c   
LEFT JOIN dbo.[Order History] AS oh   
    ON c.customer_id = oh.customer_id;  
```  
  
 <span data-ttu-id="d8c9e-148">Далее в примере с явными и неявными транзакциями представлено то же соединение, но в этот раз в составе явной пользовательской транзакции.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-148">The following explicit or implicit transactions example shows the same join, but this time in an explicit user transaction.</span></span> <span data-ttu-id="d8c9e-149">Доступ к оптимизированной для памяти таблице Customers осуществляется с уровнем изоляции SNAPSHOT (табличное указание WITH (SNAPSHOT)), а к обычной таблице [Order History] — с уровнем изоляции READ COMMITTED:</span><span class="sxs-lookup"><span data-stu-id="d8c9e-149">The memory-optimized table Customers is accessed under snapshot isolation, as indicated through the table hint WITH (SNAPSHOT), and the regular table [Order History] is accessed under read committed isolation:</span></span>  
  
```sql  
SET TRANSACTION ISOLATION LEVEL READ COMMITTED  
GO  
BEGIN TRAN  
SELECT * FROM dbo.Customers c with (SNAPSHOT)   
LEFT JOIN dbo.[Order History] oh   
    ON c.customer_id=oh.customer_id  
...  
COMMIT  
```  
  
### <a name="operational-differences"></a><span data-ttu-id="d8c9e-150">Эксплуатационные различия</span><span class="sxs-lookup"><span data-stu-id="d8c9e-150">Operational Differences</span></span>  
 <span data-ttu-id="d8c9e-151">Помимо гарантии READ COMMITTED существуют еще две ключевые особенности реализации, на которые могут опираться приложения, работающие с сохраняемыми на диске таблицами.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-151">Besides the read committed guarantee, there are also two key implementation details that applications using disk-based tables may rely on.</span></span> <span data-ttu-id="d8c9e-152">Во время преобразования таблицы, сохраняемой на диске, доступ к которой выполняется с уровнем изоляции READ COMMITTED, в таблицу, оптимизированную для памяти, доступ к которой выполняется с уровнем изоляции SNAPSHOT, следует иметь в виду следующее.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-152">Be aware of the following when converting a disk-based table that is accessed using READ COMMITTED isolation to a memory-optimized table that is accessed using SNAPSHOT isolation:</span></span>  
  
-   <span data-ttu-id="d8c9e-153">Реализация уровня изоляции READ COMMITED для таблиц, сохраняемых на диске (предполагая, что параметр READ_COMMITTED_SNAPSHOT установлен в значение OFF), использует блокировку для предотвращения конфликтов между операциями чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-153">The implementation of the READ COMMITTED isolation level for disk-based tables (assuming READ_COMMITTED_SNAPSHOT is OFF) uses locks to prevent conflicts between readers and writers.</span></span> <span data-ttu-id="d8c9e-154">Если модуль записи обновляет строку, строка блокируется и блокировка сохраняется до фиксации транзакции.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-154">When a writer starts updating a row, it takes a lock and does not release the lock until the transaction is committed.</span></span> <span data-ttu-id="d8c9e-155">Другие операции чтения блокируются, пока транзакция записи не будет зафиксирована.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-155">Any read operations are blocked and will wait for the write transaction to commit.</span></span>  
  
     <span data-ttu-id="d8c9e-156">В некоторых приложениях может применяться предположение, что операции чтения будут ждать завершения операций записи, особенно если между двумя транзакциями на уровне приложений есть синхронизация.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-156">Some applications may assume readers always wait for writers to commit, particularly if there is any synchronization between the two transactions in the application tier.</span></span>  
  
     <span data-ttu-id="d8c9e-157">**Рекомендации:** Приложения не могут полагаться на поведение блокировки.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-157">**Guideline:** Applications cannot rely on blocking behavior.</span></span> <span data-ttu-id="d8c9e-158">Если приложению требуется синхронизация между параллельными транзакциями, такую логику можно реализовать на уровне приложения или на уровне базы данных, используя [sp_getapplock &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-getapplock-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="d8c9e-158">If an application needs synchronization between concurrent transactions, such logic can be implemented in the application tier or in the database tier, through [sp_getapplock &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-getapplock-transact-sql).</span></span>  
  
-   <span data-ttu-id="d8c9e-159">В транзакциях, использующих уровень изоляции READ COMMITTED, каждая инструкция видит самую последнюю версию строк в базе данных.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-159">In transactions that use READ COMMITTED isolation, each statement sees the most recent version of the rows in the database.</span></span> <span data-ttu-id="d8c9e-160">Следовательно, последующие инструкции видят изменения состояния базы данных.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-160">Therefore, subsequent statements see changes in the state of the database.</span></span>  
  
     <span data-ttu-id="d8c9e-161">Примером модели приложения, работающего на основе этого предположения, является опрос таблицы с помощью цикла WHILE до нахождения новой строки.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-161">Polling a table using a WHILE loop until a new row has been found is an example of an application pattern that uses this assumption.</span></span> <span data-ttu-id="d8c9e-162">С каждой итерацией цикла запрос будет видеть последние обновления в базе данных.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-162">With each iteration of the loop, the query will see the latest updates in the database.</span></span>  
  
     <span data-ttu-id="d8c9e-163">**Рекомендации:** Если приложению необходимо опросить оптимизированную для памяти таблицу для получения последних строк, записанных в таблицу, переместите цикл опроса за пределы области транзакции.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-163">**Guideline:** If an application needs to poll a memory-optimized table to obtain the most recent rows written to the table, move the polling loop outside the scope of the transaction.</span></span>  
  
     <span data-ttu-id="d8c9e-164">Далее приводится пример модели приложения, использующей это предположение.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-164">The following is an example application pattern that uses this assumption.</span></span> <span data-ttu-id="d8c9e-165">Опрос таблицы с помощью цикла WHILE, пока не будет найдена новая строка.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-165">Polling a table using a WHILE loop until a new row is found.</span></span> <span data-ttu-id="d8c9e-166">В каждой итерации цикла запрос получает доступ к последним обновлениям в базе данных.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-166">In each loop iteration, the query will access the latest updates in the database.</span></span>  
  
 <span data-ttu-id="d8c9e-167">В следующем примере скрипт опрашивает таблицу t1, пока в ней не появится новая строка.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-167">The following example script polls a table t1 until it has a row.</span></span> <span data-ttu-id="d8c9e-168">Затем скрипт удаляет одну строку из таблицы для дальнейшей обработки.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-168">It then removes a single row from the table for further processing.</span></span>  
  
 <span data-ttu-id="d8c9e-169">Обратите внимание, что логика опроса должна быть вне области транзакции, так как она использует уровень изоляции SNAPSHOT для получения доступа к таблице t1.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-169">Notice that the polling logic needs to be outside the scope of the transaction, as it is using snapshot isolation to access table t1.</span></span> <span data-ttu-id="d8c9e-170">Использование логики опроса внутри области транзакции может привести к созданию длительной транзакции, что является нежелательным.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-170">Using polling logic inside the scope of a transaction would create a long-running transaction, which is a bad practice.</span></span>  
  
```sql  
-- poll table  
WHILE NOT EXISTS (SELECT 1 FROM dbo.t1)  
BEGIN   
  -- if empty, wait and poll again  
  WAITFOR DELAY '00:00:01'  
END  
  
BEGIN TRANSACTION  
  DECLARE @id int  
  SELECT TOP 1 @id=id FROM dbo.t1 WITH (SNAPSHOT)  
  DELETE FROM dbo.t1 WITH (SNAPSHOT) WHERE id=@id  
  
  -- insert processing based on @id  
COMMIT  
```  
  
## <a name="locking-table-hints"></a><span data-ttu-id="d8c9e-171">Табличные указания блокировки</span><span class="sxs-lookup"><span data-stu-id="d8c9e-171">Locking Table Hints</span></span>  
 <span data-ttu-id="d8c9e-172">Подсказки блокировки ([Табличные указания &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-table)), такие как HOLDLOCK и XLOCK, можно использовать с таблицами на диске, чтобы иметь [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] больше блокировок, чем требуется для указанного уровня изоляции.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-172">Locking hints ([Table Hints &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-table)) such as HOLDLOCK and XLOCK can be used with disk-based tables to have [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] take more locks than are required for the specified isolation level.</span></span>  
  
 <span data-ttu-id="d8c9e-173">Таблицы, оптимизированные для памяти, не используют блокировки.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-173">Memory-optimized tables do not use locks.</span></span> <span data-ttu-id="d8c9e-174">Нужные гарантии могут быть декларированы с помощью более высоких уровней изоляции, например REPEATABLE READ или SERIALIZABLE.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-174">Higher isolation levels such as REPEATABLE READ and SERIALIZABLE can be used to declare the desired guarantees.</span></span>  
  
 <span data-ttu-id="d8c9e-175">Указания блокировки не поддерживаются.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-175">Locking hints are not supported.</span></span> <span data-ttu-id="d8c9e-176">Вместо этого следует объявить необходимые гарантии через уровни изоляции транзакций.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-176">Instead, declare the required guarantees through the transaction isolation levels.</span></span> <span data-ttu-id="d8c9e-177">(Поддерживается NOLOCK, так как [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] не принимает блокировки на оптимизированные для памяти таблицы.</span><span class="sxs-lookup"><span data-stu-id="d8c9e-177">(NOLOCK is supported because [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] does not take locks on memory-optimized tables.</span></span> <span data-ttu-id="d8c9e-178">Обратите внимание, что в отличие от дисковых таблиц NOLOCK не подразумевает поведение уровня изоляции READ UNCOMMITTED для таблиц, оптимизированных для памяти.)</span><span class="sxs-lookup"><span data-stu-id="d8c9e-178">Note that, in contrast to disk-based tables, NOLOCK does not imply READ UNCOMMITTED behavior for memory-optimized tables.)</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d8c9e-179">См. также:</span><span class="sxs-lookup"><span data-stu-id="d8c9e-179">See Also</span></span>  
 <span data-ttu-id="d8c9e-180">[Основные сведения о транзакциях в таблицах, оптимизированных для памяти](../../2014/database-engine/understanding-transactions-on-memory-optimized-tables.md) </span><span class="sxs-lookup"><span data-stu-id="d8c9e-180">[Understanding Transactions on Memory-Optimized Tables](../../2014/database-engine/understanding-transactions-on-memory-optimized-tables.md) </span></span>  
 <span data-ttu-id="d8c9e-181">[Рекомендации по логике повторных попыток для транзакций в таблицах, оптимизированных для памяти](../../2014/database-engine/guidelines-for-retry-logic-for-transactions-on-memory-optimized-tables.md) </span><span class="sxs-lookup"><span data-stu-id="d8c9e-181">[Guidelines for Retry Logic for Transactions on Memory-Optimized Tables](../../2014/database-engine/guidelines-for-retry-logic-for-transactions-on-memory-optimized-tables.md) </span></span>  
 [<span data-ttu-id="d8c9e-182">Уровни изоляции транзакций</span><span class="sxs-lookup"><span data-stu-id="d8c9e-182">Transaction Isolation Levels</span></span>](../../2014/database-engine/transaction-isolation-levels.md)  
  
  

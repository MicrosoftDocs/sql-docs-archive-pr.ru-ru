---
title: Рекомендации по уровню изоляции транзакций с таблицами, оптимизированными для памяти | Документация Майкрософт
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: e365e9ca-c34b-44ae-840c-10e599fa614f
author: stevestein
ms.author: sstein
ms.openlocfilehash: 834c5950a8f8b0ddf8854d06c6fb1073a264fc22
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87732918"
---
# <a name="guidelines-for-transaction-isolation-levels-with-memory-optimized-tables"></a>Рекомендации для уровней изоляции транзакций с таблицами, оптимизированными для памяти
  Во многих сценариях необходимо указать уровень изоляции транзакции. Уровень изоляции транзакции для таблиц, оптимизированных для памяти, отличается от уровня для таблиц, сохраняемых на диске.  
  
 Требования для указания уровня изоляции транзакции:  
  
-   TRANSACTION ISOLATION LEVEL — это обязательный параметр для блока ATOMIC, который включает содержимое хранимой процедуры, скомпилированной в собственном коде.  
  
-   Из-за ограничений, применяемых к уровням изоляции в кросс-контейнерных транзакциях, использование таблиц с оптимизацией для памяти в интерпретируемых инструкциях [!INCLUDE[tsql](../includes/tsql-md.md)] часто следует сопровождать табличным указанием уровня изоляции, используемого для доступа к таблице. Дополнительные сведения о подсказках уровней изоляции и транзакциях между контейнерами см. в разделе [уровни изоляции транзакций](../../2014/database-engine/transaction-isolation-levels.md).  
  
-   Заданный уровень изоляции транзакции должен быть явно объявлен. Нельзя использовать подсказки блокировки (например, XLOCK), чтобы обеспечить изоляцию определенных строк или таблиц в транзакции.  
  
-   Приложение, которое обращается к базе данных, должно реализовать логику повторов для обработки ошибок, возникающих в результате конфликтов транзакций, ошибок проверки и ошибок, связанных с зависимостью фиксации. Обратите внимание, что ошибки зависимости фиксации могут возникать даже в транзакциях только для чтения.  
  
-   Следует избегать длительных транзакций при работе с таблицами, оптимизированными для памяти. Такие транзакции увеличивают вероятность конфликтов и прерывания последующих транзакций. Выполнение длительной транзакции приводит к откладыванию сборки мусора. Чем дольше выполняется транзакция, тем дольше In-Memory OLTP хранит недавно удаленные версии строк, что может уменьшить производительность подстановки при выполнении новых транзакций.  
  
 Таблицы, сохраняемые на диске, обычно реализуют блокировку для изоляции транзакций. Таблицы, оптимизированные для памяти, обеспечивают изоляцию через управление разными версиям и обнаружение конфликтов. Дополнительные сведения см. в разделе об обнаружении конфликтов, проверке и проверке зависимостей фиксации в [транзакциях в таблицах, оптимизированных для памяти](../relational-databases/in-memory-oltp/memory-optimized-tables.md).  
  
 Таблицы, сохраняемые на диске, позволяет управлять разными версиями с уровнями изоляции SNAPSHOT и READ_COMMITTED_SNAPSHOT. Для таблиц, оптимизированных для памяти, все уровни изоляции основываются на управлении разными версиями, включая REPEATABLE READ и SERIALIZABLE.  
  
## <a name="types-of-transactions"></a>Типы транзакций  
 Каждый запрос в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] выполняется в контексте транзакции.  
  
 В [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] существует три типа транзакций.  
  
-   Транзакции с автоматической фиксацией. Если нет активного контекста транзакции и в сеансе не включены неявные транзакции, каждый запрос будет иметь собственный контекст транзакции. Транзакция запускается, когда начинается исполнение инструкции, и завершается при завершении инструкции.  
  
-   Явные транзакции. Пользователь запускает транзакцию с помощью явных инструкций BEGIN TRAN или BEGIN ATOMIC. Транзакция завершается после соответствующей инструкции COMMIT, ROLLBACK или END (для блока ATOMIC).  
  
-   Неявные транзакции. Если параметр IMPLICIT_TRANSACTIONS установлен в значение ON, транзакция запускается неявно каждый раз, когда пользователь выполняет инструкцию и активный контекст транзакции отсутствует. Транзакция завершается посредством явной инструкции COMMIT или ROLLBACK.  
  
## <a name="baseline-read-committed-isolation"></a>Базовая изоляция READ COMMITTED  
 READ COMMITTED — это уровень изоляции по умолчанию в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].  
  
 Уровень изоляции READ COMMITTED гарантирует, что транзакции не обнаруживают какие-либо незафиксированные данные из любых изменений за пределами текущей транзакции. Другими словами, транзакция считывает только те данные, которые были либо зафиксированы в базе данных, либо изменены текущей транзакцией.  
  
 Все поддерживаемые уровни изоляции оптимизированных для памяти таблиц обеспечивают применение зафиксированных операций чтения. Поэтому, если транзакция не требует более жестких гарантий, можно использовать любые поддерживаемые уровни изоляции для таблиц, оптимизированных для памяти. SNAPSHOT использует минимальный объем системных ресурсов по сравнению с другими уровнями изоляции.  
  
 Гарантия, обеспечиваемая уровнем изоляции SNAPSHOT (самый низкий уровень изоляции, поддерживаемый для таблиц, оптимизированных для памяти), включает гарантию READ COMMITTED. Каждая инструкция в транзакции считывает одинаковую, согласованную версию базы данных. Все строки, считываемые транзакцией, фиксируются в базе данных, кроме того, все операции чтения видят набор изменений, внесенных одним и тем же набором транзакций.  
  
 **Рекомендация**: Если требуется только гарантия изоляции READ COMMITTED, используйте изоляцию моментального снимка с хранимыми процедурами, скомпилированными в собственном коде, а также для доступа к оптимизированным для памяти таблицам с помощью интерпретации [!INCLUDE[tsql](../includes/tsql-md.md)] .  
  
 Для транзакций с автоматической фиксацией уровень изоляции READ COMMITTED неявным образом сопоставляется с уровнем SNAPSHOT для таблиц, оптимизированных для памяти. Поэтому, если параметр сеанса TRANSACTION ISOLATION LEVEL установлен в значение READ COMMITTED, нет необходимости указывать уровень изоляции посредством табличного указания при доступе к таблицам, оптимизированным для памяти.  
  
 В следующем примере транзакции с автоматической фиксацией показано соединение между таблицей Customers с оптимизацией для памяти и обычной таблицей [Order History] в составе нерегламентированного пакета:  
  
```sql  
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;  
GO  
SELECT *   
FROM dbo.Customers AS c   
LEFT JOIN dbo.[Order History] AS oh   
    ON c.customer_id = oh.customer_id;  
```  
  
 Далее в примере с явными и неявными транзакциями представлено то же соединение, но в этот раз в составе явной пользовательской транзакции. Доступ к оптимизированной для памяти таблице Customers осуществляется с уровнем изоляции SNAPSHOT (табличное указание WITH (SNAPSHOT)), а к обычной таблице [Order History] — с уровнем изоляции READ COMMITTED:  
  
```sql  
SET TRANSACTION ISOLATION LEVEL READ COMMITTED  
GO  
BEGIN TRAN  
SELECT * FROM dbo.Customers c with (SNAPSHOT)   
LEFT JOIN dbo.[Order History] oh   
    ON c.customer_id=oh.customer_id  
...  
COMMIT  
```  
  
### <a name="operational-differences"></a>Эксплуатационные различия  
 Помимо гарантии READ COMMITTED существуют еще две ключевые особенности реализации, на которые могут опираться приложения, работающие с сохраняемыми на диске таблицами. Во время преобразования таблицы, сохраняемой на диске, доступ к которой выполняется с уровнем изоляции READ COMMITTED, в таблицу, оптимизированную для памяти, доступ к которой выполняется с уровнем изоляции SNAPSHOT, следует иметь в виду следующее.  
  
-   Реализация уровня изоляции READ COMMITED для таблиц, сохраняемых на диске (предполагая, что параметр READ_COMMITTED_SNAPSHOT установлен в значение OFF), использует блокировку для предотвращения конфликтов между операциями чтения и записи. Если модуль записи обновляет строку, строка блокируется и блокировка сохраняется до фиксации транзакции. Другие операции чтения блокируются, пока транзакция записи не будет зафиксирована.  
  
     В некоторых приложениях может применяться предположение, что операции чтения будут ждать завершения операций записи, особенно если между двумя транзакциями на уровне приложений есть синхронизация.  
  
     **Рекомендации:** Приложения не могут полагаться на поведение блокировки. Если приложению требуется синхронизация между параллельными транзакциями, такую логику можно реализовать на уровне приложения или на уровне базы данных, используя [sp_getapplock &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-getapplock-transact-sql).  
  
-   В транзакциях, использующих уровень изоляции READ COMMITTED, каждая инструкция видит самую последнюю версию строк в базе данных. Следовательно, последующие инструкции видят изменения состояния базы данных.  
  
     Примером модели приложения, работающего на основе этого предположения, является опрос таблицы с помощью цикла WHILE до нахождения новой строки. С каждой итерацией цикла запрос будет видеть последние обновления в базе данных.  
  
     **Рекомендации:** Если приложению необходимо опросить оптимизированную для памяти таблицу для получения последних строк, записанных в таблицу, переместите цикл опроса за пределы области транзакции.  
  
     Далее приводится пример модели приложения, использующей это предположение. Опрос таблицы с помощью цикла WHILE, пока не будет найдена новая строка. В каждой итерации цикла запрос получает доступ к последним обновлениям в базе данных.  
  
 В следующем примере скрипт опрашивает таблицу t1, пока в ней не появится новая строка. Затем скрипт удаляет одну строку из таблицы для дальнейшей обработки.  
  
 Обратите внимание, что логика опроса должна быть вне области транзакции, так как она использует уровень изоляции SNAPSHOT для получения доступа к таблице t1. Использование логики опроса внутри области транзакции может привести к созданию длительной транзакции, что является нежелательным.  
  
```sql  
-- poll table  
WHILE NOT EXISTS (SELECT 1 FROM dbo.t1)  
BEGIN   
  -- if empty, wait and poll again  
  WAITFOR DELAY '00:00:01'  
END  
  
BEGIN TRANSACTION  
  DECLARE @id int  
  SELECT TOP 1 @id=id FROM dbo.t1 WITH (SNAPSHOT)  
  DELETE FROM dbo.t1 WITH (SNAPSHOT) WHERE id=@id  
  
  -- insert processing based on @id  
COMMIT  
```  
  
## <a name="locking-table-hints"></a>Табличные указания блокировки  
 Подсказки блокировки ([Табличные указания &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-table)), такие как HOLDLOCK и XLOCK, можно использовать с таблицами на диске, чтобы иметь [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] больше блокировок, чем требуется для указанного уровня изоляции.  
  
 Таблицы, оптимизированные для памяти, не используют блокировки. Нужные гарантии могут быть декларированы с помощью более высоких уровней изоляции, например REPEATABLE READ или SERIALIZABLE.  
  
 Указания блокировки не поддерживаются. Вместо этого следует объявить необходимые гарантии через уровни изоляции транзакций. (Поддерживается NOLOCK, так как [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] не принимает блокировки на оптимизированные для памяти таблицы. Обратите внимание, что в отличие от дисковых таблиц NOLOCK не подразумевает поведение уровня изоляции READ UNCOMMITTED для таблиц, оптимизированных для памяти.)  
  
## <a name="see-also"></a>См. также:  
 [Основные сведения о транзакциях в таблицах, оптимизированных для памяти](../../2014/database-engine/understanding-transactions-on-memory-optimized-tables.md)   
 [Рекомендации по логике повторных попыток для транзакций в таблицах, оптимизированных для памяти](../../2014/database-engine/guidelines-for-retry-logic-for-transactions-on-memory-optimized-tables.md)   
 [Уровни изоляции транзакций](../../2014/database-engine/transaction-isolation-levels.md)  
  
  

---
title: Создание уникальных индексов | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: table-view-index
ms.topic: conceptual
helpviewer_keywords:
- unique indexes
- designing indexes [SQL Server], unique
- clustered indexes, unique
- indexes [SQL Server], unique
- nonclustered indexes [SQL Server], unique
- unique indexes, design guidelines
ms.assetid: 56b5982e-cb94-46c0-8fbb-772fc275354a
author: MikeRayMSFT
ms.author: mikeray
ms.openlocfilehash: 8c96c4e17a8ce0863452db171302d650f6114919
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87749840"
---
# <a name="create-unique-indexes"></a>Создание уникальных индексов
  В данном разделе описывается создание уникальных индексов в таблице в [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] с помощью [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)] или [!INCLUDE[tsql](../../includes/tsql-md.md)]. Уникальный индекс гарантирует, что ключ индекса не будет содержать одинаковых значений, а значит, каждая строка в таблице будет уникальна. Нет существенных различий между созданием ограничения UNIQUE и созданием уникального индекса, не зависящего от ограничения. Проверка данных происходит подобным же образом, и оптимизатор запросов не делает различия между уникальным индексом, который создан ограничением, и индексом, созданным вручную. Однако при создании ограничения UNIQUE для столбца назначение индекса становится очевидным. Дополнительные сведения об ограничениях UNIQUE см. в разделе [Unique Constraints and Check Constraints](../tables/unique-constraints-and-check-constraints.md).  
  
 При создании уникального индекса можно установить параметр пропуска дублирующихся ключей. Если для этого параметра установлено значение **Да** , то при попытке создать дублирующиеся ключи путем добавления данных, которые влияют на несколько строк (при помощи инструкции INSERT), строка, содержащая дубликат, добавлена не будет. Если для параметра установлено значение **Нет**, вся операция вставки завершится неудачно и будет выполнен откат всех данных.  
  
> [!NOTE]  
>  Нельзя создать уникальный индекс для одного столбца, если в более чем одной строке этого столбца содержится значение NULL. Нельзя также создать уникальный индекс для нескольких столбцов, если в более чем одной строке такой комбинации столбцов содержится значение NULL. При индексировании такие значения будут рассматриваться как дубликаты.  
  
 **В этом разделе**  
  
-   **Перед началом работы**  
  
     [Преимущества уникального индекса](#Benefits)  
  
     [Стандартные реализации](#Implementations)  
  
     [Ограничения](#Restrictions)  
  
     [Безопасность](#Security)  
  
-   **Создание уникального индекса для таблицы с помощью следующих средств:**  
  
     [Среда SQL Server Management Studio](#SSMSProcedure)  
  
     [Transact-SQL](#TsqlProcedure)  
  
##  <a name="before-you-begin"></a><a name="BeforeYouBegin"></a> Перед началом  
  
###  <a name="benefits-of-a-unique-index"></a><a name="Benefits"></a> Преимущества уникального индекса  
  
-   Использование уникальных индексов по нескольким столбцам позволяет гарантировать уникальность всех сочетаний значений в ключе индекса. Например, если уникальный индекс создан для комбинации столбцов **LastName**, **FirstName**и **MiddleName** , то никакие две строки в таблице не могут образовывать одну и ту же комбинацию этих значений.  
  
-   При условии уникальности данных в каждом столбце можно создать уникальный кластеризованный индекс и несколько уникальных некластеризованных индексов для одной и той же таблицы.  
  
-   Уникальные индексы гарантируют целостность данных в определенных столбцах.  
  
-   Уникальные индексы обеспечивают дополнительные сведения, которые могут использоваться оптимизатором запросов для создания более эффективных планов выполнения.  
  
###  <a name="typical-implementations"></a><a name="Implementations"></a> Стандартные реализации  
 Уникальные индексы реализуются следующими способами:  
  
-   **Ограничение PRIMARY KEY или UNIQUE**  
  
     Если кластеризованный индекс в таблице еще не создан, а уникальный некластеризованный индекс еще не указан, то при создании ограничения PRIMARY KEY в одном или нескольких столбцах автоматически создается уникальный кластеризованный индекс. В первичном ключевом столбце недопустимы значения NULL.  
  
     При создании ограничения UNIQUE создается уникальный некластеризованный индекс. Он нужен, чтобы принудительно применять ограничение UNIQUE по умолчанию. Если кластеризованный индекс в таблице еще не создан, то можно указать уникальный кластеризованный индекс.  
  
     Дополнительные сведения см. в разделах [Unique Constraints and Check Constraints](../tables/unique-constraints-and-check-constraints.md) и [Primary and Foreign Key Constraints](../tables/primary-and-foreign-key-constraints.md).  
  
-   **Индекс, не зависящий от ограничения**  
  
     По таблице может быть определено несколько уникальных некластеризованных индексов.  
  
     Дополнительные сведения см. в разделе [CREATE INDEX (Transact-SQL)](/sql/t-sql/statements/create-index-transact-sql).  
  
-   **Индексированное представление**  
  
     Чтобы создать индексированное представление, по одному или нескольким столбцам представления определяется уникальный кластеризованный индекс. Представление выполняется и результирующий набор сохраняется на конечном уровне индекса аналогично хранению данных таблиц в кластеризованном индексе. Дополнительные сведения см. в разделе [Создание индексированных представлений](../views/views.md).  
  
###  <a name="limitations-and-restrictions"></a><a name="Restrictions"></a> Ограничения  
  
-   Уникальный индекс и ограничения UNIQUE и PRIMARY KEY не могут быть созданы, если дублирующиеся значения уже существуют.  
  
-   Уникальный некластеризованный индекс может содержать любые неключевые столбцы. Дополнительные сведения см. в статье [Create Indexes with Included Columns](create-indexes-with-included-columns.md).  
  
###  <a name="security"></a><a name="Security"></a> безопасность  
  
####  <a name="permissions"></a><a name="Permissions"></a> Permissions  
 Необходимо разрешение ALTER для таблицы или представления. Пользователь должен быть членом предопределенной роли сервера **sysadmin** или предопределенных ролей базы данных **db_ddladmin** и **db_owner**.  
  
##  <a name="using-sql-server-management-studio"></a><a name="SSMSProcedure"></a> Использование среды SQL Server Management Studio  
  
#### <a name="to-create-a-unique-index-by-using-the-table-designer"></a>Создание уникального индекса с помощью конструктора таблиц  
  
1.  В обозревателе объектов разверните базу данных, содержащую таблицу, в которой необходимо создать уникальный индекс.  
  
2.  Разверните папку **Таблицы**.  
  
3.  Щелкните правой кнопкой мыши таблицу, в которой нужно создать уникальный индекс, и выберите **Конструктор**.  
  
4.  В меню **Конструктор таблиц** выберите пункт **Индексы и ключи**.  
  
5.  В диалоговом окне **Индексы и ключи** нажмите **Добавить**.  
  
6.  Выберите новый индекс в текстовом поле **Выбранный первичный/уникальный ключ или индекс** .  
  
7.  В основной сетке в **(Общие)** выберите **Тип** , а затем выберите в списке **Индекс** .  
  
8.  Выберите **Столбцы** и затем нажмите кнопку с многоточием **(…)** .  
  
9. В диалоговом окне **Столбцы индекса** в поле **Имя столбца**выберите столбцы, которые необходимо индексировать. Выбрать можно до 16 столбцов. Для оптимальной производительности следует выбирать только один или два столбца на индекс. Для каждого выбранного столбца укажите, будут ли значения данного столбца располагаться в индексе в возрастающем или убывающем порядке.  
  
10. После выбора всех столбцов для индекса щелкните **ОК**.  
  
11. В сетке в **(Общие)** выберите **Уникальный** , а затем выберите в списке **Да** .  
  
12. Дополнительно. В основной сетке в разделе **Конструктор таблиц**выберите **Пропустить повторяющиеся ключи** , а затем выберите в списке значение **Да** . Сделайте это, если необходимо пропустить попытки добавления данных, создающих повторяющиеся ключи в уникальном индексе.  
  
13. Щелкните **Закрыть**.  
  
14. В меню **Файл** выберите пункт **Сохранить**_имя_таблицы_.  
  
#### <a name="create-a-unique-index-by-using-object-explorer"></a>Создание уникального индекса в обозревателе объектов  
  
1.  В обозревателе объектов разверните базу данных, содержащую таблицу, в которой необходимо создать уникальный индекс.  
  
2.  Разверните папку **Таблицы**.  
  
3.  Разверните таблицу, для которой необходимо создать уникальный индекс.  
  
4.  Щелкните правой кнопкой мыши папку **Индексы**, выберите **Создать индекс** и **Некластеризованный индекс...**  
  
5.  В диалоговом окне **Создание индекса** на странице **Общие** введите имя нового индекса в поле **Имя индекса** .  
  
6.  Установите флажок **Уникальный** .  
  
7.  В разделе **Ключевые столбцы индекса** щелкните **Добавить…** .  
  
8.  В диалоговом окне **Выбор столбцов из**_table_name_ установите флажки для столбцов таблицы или столбцов, которые будут добавлены в уникальный индекс.  
  
9. Нажмите кнопку **ОК**.  
  
10. В диалоговом окне **Создание индекса** нажмите кнопку **ОК**.  
  
##  <a name="using-transact-sql"></a><a name="TsqlProcedure"></a> Использование Transact-SQL  
  
#### <a name="to-create-a-unique-index-on-a-table"></a>Создание уникального индекса в таблице  
  
1.  В **обозревателе объектов**подключитесь к экземпляру компонента [!INCLUDE[ssDE](../../includes/ssde-md.md)].  
  
2.  На стандартной панели выберите пункт **Создать запрос**.  
  
3.  Скопируйте следующий пример в окно запроса и нажмите кнопку **Выполнить**.  
  
    ```  
    USE AdventureWorks2012;  
    GO  
    -- Find an existing index named AK_UnitMeasure_Name and delete it if found  
    IF EXISTS (SELECT name from sys.indexes  
               WHERE name = N'AK_UnitMeasure_Name')   
       DROP INDEX AK_UnitMeasure_Name ON Production.UnitMeasure;   
    GO  
    -- Create a unique index called AK_UnitMeasure_Name  
    -- on the Production.UnitMeasure table using the Name column.  
    CREATE UNIQUE INDEX AK_UnitMeasure_Name   
       ON Production.UnitMeasure (Name);   
    GO  
    ```  
  
 Дополнительные сведения см. в разделе [CREATE INDEX (Transact-SQL)](/sql/t-sql/statements/create-index-transact-sql).  
  
  

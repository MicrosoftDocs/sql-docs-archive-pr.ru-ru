---
title: Использование возвращающих табличные значения параметров ODBC | Документация Майкрософт
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- table-valued parameters (ODBC), scenarios
- ODBC, table-valued parameters
ms.assetid: f1b73932-4570-4a8a-baa0-0f229d9c32ee
author: rothja
ms.author: jroth
ms.openlocfilehash: 2b128246f7c4ed9a9cec5e28698c743877f9873d
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87749784"
---
# <a name="uses-of-odbc-table-valued-parameters"></a><span data-ttu-id="9a628-102">Сценарии использования возвращающих табличное значение параметров ODBC</span><span class="sxs-lookup"><span data-stu-id="9a628-102">Uses of ODBC Table-Valued Parameters</span></span>
  <span data-ttu-id="9a628-103">В данном разделе обсуждаются основные пользовательские сценарии для использования возвращающих табличное значение параметров ODBC.</span><span class="sxs-lookup"><span data-stu-id="9a628-103">This topic discusses the primary user scenarios for using table-valued parameters with ODBC:</span></span>  
  
-   <span data-ttu-id="9a628-104">Возвращающий табличное значение параметр с многострочными буферами с полной привязкой (отправка данных в виде возвращающего табличное значение параметра со всеми значениями в памяти)</span><span class="sxs-lookup"><span data-stu-id="9a628-104">Table-Valued Parameter with Fully Bound Multirow Buffers (Send Data as a TVP with All Values in Memory)</span></span>  
  
-   <span data-ttu-id="9a628-105">Возвращающий табличное значение параметр с поддержкой потоковой работы со строками (отправка данных в виде возвращающего табличное значение параметра с использованием данных времени выполнения).</span><span class="sxs-lookup"><span data-stu-id="9a628-105">Table-Valued Parameter with Row Streaming (Send Data as a TVP Using Data-At-Execution)</span></span>  
  
-   <span data-ttu-id="9a628-106">Получение метаданных возвращающих табличное значение параметров из системного каталога</span><span class="sxs-lookup"><span data-stu-id="9a628-106">Retrieving Table-Valued Parameter Metadata from the System Catalog</span></span>  
  
-   <span data-ttu-id="9a628-107">Получение метаданных возвращающих табличное значение параметров для подготовленной инструкции</span><span class="sxs-lookup"><span data-stu-id="9a628-107">Retrieving Table-Valued Parameter Metadata for a Prepared Statement</span></span>  
  
## <a name="table-valued-parameter-with-fully-bound-multirow-buffers-send-data-as-a-tvp-with-all-values-in-memory"></a><span data-ttu-id="9a628-108">Возвращающий табличное значение параметр с многострочными буферами с полной привязкой (отправка данных в виде возвращающего табличное значение параметра со всеми значениями в памяти)</span><span class="sxs-lookup"><span data-stu-id="9a628-108">Table-Valued Parameter with Fully Bound Multirow Buffers (Send Data as a TVP with All Values in Memory)</span></span>  
 <span data-ttu-id="9a628-109">При использовании с многострочными буферами с полной привязкой все значения параметров доступны в памяти.</span><span class="sxs-lookup"><span data-stu-id="9a628-109">When used with fully bound multirow buffers, all parameter values are available in memory.</span></span> <span data-ttu-id="9a628-110">Например, это характерно для транзакции OLTP, в которой возвращающие табличное значение параметры могут быть упакованы в одну хранимую процедуру.</span><span class="sxs-lookup"><span data-stu-id="9a628-110">This is typical, for example, of an OLTP transaction, in which table-valued parameters can be packaged into a single stored procedure.</span></span> <span data-ttu-id="9a628-111">Без возвращающих табличное значение параметров для этого потребовалось бы динамическое создание сложного пакета с несколькими инструкциями или несколько обращений к серверу.</span><span class="sxs-lookup"><span data-stu-id="9a628-111">Without table-valued parameters, this would involve either generating a complex multi-statement batch dynamically, or making multiple calls to the server.</span></span>  
  
 <span data-ttu-id="9a628-112">Возвращающий табличное значение параметр привязывается с помощью [SQLBindParameter](https://go.microsoft.com/fwlink/?LinkId=59328) вместе с другими параметрами.</span><span class="sxs-lookup"><span data-stu-id="9a628-112">The table-valued parameter itself is bound by using [SQLBindParameter](https://go.microsoft.com/fwlink/?LinkId=59328) along with the other parameters.</span></span> <span data-ttu-id="9a628-113">После привязки всех параметров приложение задает атрибут фокуса параметра, SQL_SOPT_SS_PARAM_FOCUS, для каждого возвращающего табличное значение параметра и вызывает SQLBindParameter для столбцов возвращающего табличное значение параметра.</span><span class="sxs-lookup"><span data-stu-id="9a628-113">After all parameters have been bound, the application sets the parameter focus attribute, SQL_SOPT_SS_PARAM_FOCUS, on each table-valued parameter and calls SQLBindParameter for the columns of the table-valued parameter.</span></span>  
  
 <span data-ttu-id="9a628-114">Тип сервера для возвращающего табличное значение параметра является новым типом [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], SQL_SS_TABLE.</span><span class="sxs-lookup"><span data-stu-id="9a628-114">The server type for a table-valued parameter is a new [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]-specific type, SQL_SS_TABLE.</span></span> <span data-ttu-id="9a628-115">Типом привязки C для типа SQL_SS_TABLE должен быть всегда SQL_C_DEFAULT.</span><span class="sxs-lookup"><span data-stu-id="9a628-115">The binding C type for SQL_SS_TABLE must always be SQL_C_DEFAULT.</span></span> <span data-ttu-id="9a628-116">Никакие данные для параметра, привязанного к возвращающему табличное значение параметру, не передаются; они используются, чтобы передавать метаданные таблицы и управлять передачей данных в столбцах, составляющих возвращающий табличное значение параметр.</span><span class="sxs-lookup"><span data-stu-id="9a628-116">No data is transferred for the table-valued parameter bound parameter; it is used to pass table metadata and to control how to pass data in the constituent columns of the table-valued parameter.</span></span>  
  
 <span data-ttu-id="9a628-117">Длина возвращающего табличное значение параметра устанавливается в значение количества строк, отправленных серверу.</span><span class="sxs-lookup"><span data-stu-id="9a628-117">The length of the table-valued parameter is set to the number of rows being sent to the server.</span></span> <span data-ttu-id="9a628-118">Параметр *ColumnSize* объекта SQLBindParameter для возвращающего табличное значение параметра указывает максимальное количество строк, которые могут быть отправлены. это размер массива буферов столбцов.</span><span class="sxs-lookup"><span data-stu-id="9a628-118">The *ColumnSize* parameter of SQLBindParameter for a table-valued parameter specifies the maximum number of rows that can be sent; this is the array size of the column buffers.</span></span> <span data-ttu-id="9a628-119">*Параметервалуептр* — это буфер параметров для возвращающего табличное значение параметра в SQLBindParameter.</span><span class="sxs-lookup"><span data-stu-id="9a628-119">*ParameterValuePtr* is the parameter buffer,for a table-valued parameter in SQLBindParameter.</span></span> <span data-ttu-id="9a628-120">*Параметервалуептр* и связанные с ним *BufferLength* используются для передачи имени типа возвращающего табличное значение параметра, если это необходимо.</span><span class="sxs-lookup"><span data-stu-id="9a628-120">*ParameterValuePtr* and its associated *BufferLength* are used to pass the type name of the table-valued parameter when required.</span></span> <span data-ttu-id="9a628-121">Имя типа не требуется для вызова хранимой процедуры, но требуется для инструкций SQL.</span><span class="sxs-lookup"><span data-stu-id="9a628-121">The type name is not required for stored procedure calls, but it is required for SQL statements.</span></span>  
  
 <span data-ttu-id="9a628-122">Если в вызове SQLBindParameter указано имя типа возвращающего табличное значение параметра, оно всегда должно быть указано в Юникоде даже в приложениях, созданных как приложения ANSI.</span><span class="sxs-lookup"><span data-stu-id="9a628-122">When a table-valued parameter type name is specified on a call to SQLBindParameter, it must always be specified as a Unicode value, even in applications that are built as ANSI applications.</span></span> <span data-ttu-id="9a628-123">При указании имени типа возвращающего табличное значение параметра с помощью SQLSetDescField можно использовать литерал, который соответствует способу построения приложения.</span><span class="sxs-lookup"><span data-stu-id="9a628-123">When you specify a table-valued parameter type name by using SQLSetDescField, you can use a literal that conforms to the way the application is built.</span></span> <span data-ttu-id="9a628-124">Диспетчер драйвера ODBC выполнит все необходимые преобразования данных в Юникод.</span><span class="sxs-lookup"><span data-stu-id="9a628-124">The ODBC Driver Manager will perform any required Unicode conversion.</span></span>  
  
 <span data-ttu-id="9a628-125">Метаданные для возвращающих табличные значения параметров и столбцов возвращающих табличное значение параметров можно манипулировать по отдельности и явно с помощью SQLGetDescRec, SQLSetDescRec, SQLGetDescField и SQLSetDescField.</span><span class="sxs-lookup"><span data-stu-id="9a628-125">Metadata for table-valued parameters and table-valued parameter columns can be manipulated individually and explicitly by using SQLGetDescRec, SQLSetDescRec, SQLGetDescField, and SQLSetDescField.</span></span> <span data-ttu-id="9a628-126">Однако перегрузка SQLBindParameter обычно более удобна и не требует явного доступа к дескриптору в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="9a628-126">However, overloading SQLBindParameter is usually more convenient and does not require explicit descriptor access in most cases.</span></span> <span data-ttu-id="9a628-127">Этот подход согласуется с определением SQLBindParameter для других типов данных, за исключением того, что для возвращающего табличное значение параметра затронутые поля дескриптора немного отличаются.</span><span class="sxs-lookup"><span data-stu-id="9a628-127">This approach is consistent with the definition of SQLBindParameter for other data types, except that for a table-valued parameter the affected descriptor fields are slightly different.</span></span>  
  
 <span data-ttu-id="9a628-128">Иногда приложение использует возвращающий табличное значение параметр с динамическими инструкциями SQL, при этом имя типа возвращающего табличное значение параметра должно быть указано.</span><span class="sxs-lookup"><span data-stu-id="9a628-128">Sometimes, an application uses a table-valued parameter with dynamic SQL and the type name of the table-valued parameter must be supplied.</span></span> <span data-ttu-id="9a628-129">Если это так, а параметр, возвращающий табличное значение, не определен в текущей схеме по умолчанию для соединения, SQL_CA_SS_TYPE_CATALOG_NAME и SQL_CA_SS_TYPE_SCHEMA_NAME должны быть заданы с помощью SQLSetDescField.</span><span class="sxs-lookup"><span data-stu-id="9a628-129">If this is the case and the table-valued parameter is not defined in the current default schema for the connection, SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME must be set by using SQLSetDescField.</span></span> <span data-ttu-id="9a628-130">Так как определения табличного типа и возвращающие табличное значение параметры должны находиться в одной базе данных, значение SQL_CA_SS_TYPE_CATALOG_NAME не должно быть установлено, если приложение использует возвращающие табличное значение параметры.</span><span class="sxs-lookup"><span data-stu-id="9a628-130">Because table type definitions and table-valued parameters must be in the same database, SQL_CA_SS_TYPE_CATALOG_NAME must not be set if the application uses table-valued parameters.</span></span> <span data-ttu-id="9a628-131">В противном случае SQLSetDescField сообщит об ошибке.</span><span class="sxs-lookup"><span data-stu-id="9a628-131">Otherwise, SQLSetDescField will report an error.</span></span>  
  
 <span data-ttu-id="9a628-132">Пример кода для этого сценария приведен в процедуре `demo_fixed_TVP_binding` [Использование возвращающих табличное значение параметров &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span><span class="sxs-lookup"><span data-stu-id="9a628-132">Sample code for this scenario is in the procedure `demo_fixed_TVP_binding` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="table-valued-parameter-with-row-streaming-send-data-as-a-tvp-using-data-at-execution"></a><span data-ttu-id="9a628-133">Возвращающий табличное значение параметр с поддержкой потоковой работы со строками (отправка данных в виде возвращающего табличное значение параметра с использованием данных времени выполнения).</span><span class="sxs-lookup"><span data-stu-id="9a628-133">Table-Valued Parameter with Row Streaming (Send Data as a TVP Using Data-At-Execution)</span></span>  
 <span data-ttu-id="9a628-134">В данном сценарии приложение передает строки драйверу, когда он их запрашивает, и они передаются потоком на сервер.</span><span class="sxs-lookup"><span data-stu-id="9a628-134">In this scenario, the application supplies rows to the driver as it requests them and they are streamed to the server.</span></span> <span data-ttu-id="9a628-135">Это помогает избежать буферизации всех строк в памяти.</span><span class="sxs-lookup"><span data-stu-id="9a628-135">This avoids having to buffer all rows in memory.</span></span> <span data-ttu-id="9a628-136">Это типично для массовой вставки или обновления сценариев.</span><span class="sxs-lookup"><span data-stu-id="9a628-136">This is representative of bulk insert/update scenarios.</span></span> <span data-ttu-id="9a628-137">Возвращающие табличное значение параметры обеспечивают показатель производительности где-то между массивами параметров и массовым копированием.</span><span class="sxs-lookup"><span data-stu-id="9a628-137">Table-valued parameters provide a performance point somewhere between parameter arrays and bulk copy.</span></span> <span data-ttu-id="9a628-138">То есть возвращающие табличное значение параметры почти так же легко программировать, как и массивы параметров, но они дают большую гибкость на сервере.</span><span class="sxs-lookup"><span data-stu-id="9a628-138">That is, table-valued parameters are about as easy to program as parameter arrays, but they provide greater flexibility at the server.</span></span>  
  
 <span data-ttu-id="9a628-139">Возвращающий табличное значение параметр и его столбцы привязаны, как описано в предыдущем разделе «Возвращающий табличное значение параметр с многострочными буферами с полной привязкой», но признак длины возвращающего табличное значение параметра установлен в значение SQL_DATA_AT_EXEC.</span><span class="sxs-lookup"><span data-stu-id="9a628-139">The table-valued parameter and its columns are bound as discussed in the previous section, Table-Valued Parameter with Fully Bound Multirow Buffers, but the length indicator of the table-valued parameter itself is set to SQL_DATA_AT_EXEC.</span></span> <span data-ttu-id="9a628-140">Драйвер реагирует на SQLExecute или Склексекутедирект обычным способом для параметров выполнения данных, то есть путем возвращения SQL_NEED_DATA.</span><span class="sxs-lookup"><span data-stu-id="9a628-140">The driver responds to SQLExecute or SQLExecuteDirect in the usual way for data-at-execution parameters-that is, by returning SQL_NEED_DATA.</span></span> <span data-ttu-id="9a628-141">Когда драйвер готов принять данные для возвращающего табличное значение параметра, метод SQLParamData возвращает значения *параметервалуептр* в SQLBindParameter.</span><span class="sxs-lookup"><span data-stu-id="9a628-141">When the driver is ready to accept data for a table-valued parameter, SQLParamData returns the value of *ParameterValuePtr* in SQLBindParameter.</span></span>  
  
 <span data-ttu-id="9a628-142">Приложение использует SQLPutData для возвращающего табличное значение параметра, чтобы указать доступность данных для составных столбцов возвращающего табличное значение параметра.</span><span class="sxs-lookup"><span data-stu-id="9a628-142">An application uses SQLPutData for a table-valued parameter to indicate the availability of data for table-valued parameter constituent columns.</span></span> <span data-ttu-id="9a628-143">При вызове SQLPutData для возвращающего табличное значение параметра *датаптр* должен быть равен null, а *StrLen_Or_Ind* должен быть равен 0 или быть числом, меньшим или равным размеру массива, заданному для буферов параметров, возвращающих табличное значение (параметр *ColumnSize* метода SQLBindParameter).</span><span class="sxs-lookup"><span data-stu-id="9a628-143">When SQLPutData is called for a table-valued parameter, *DataPtr* must always be null and *StrLen_or_Ind* must be either 0 or a number less than or equal to the array size specified for table-valued parameter buffers (the *ColumnSize* parameter of SQLBindParameter).</span></span> <span data-ttu-id="9a628-144">0 обозначает, что в возвращающем табличное значение параметре больше нет строк и драйвер продолжит обработку со следующего фактического параметра процедуры.</span><span class="sxs-lookup"><span data-stu-id="9a628-144">0 signifies that there are no more rows for the table-valued parameter, and the driver will proceed to process to the next actual procedure parameter.</span></span> <span data-ttu-id="9a628-145">Если значение *StrLen_Or_Ind* не равно 0, драйвер будет обрабатывать составные столбцы возвращающего табличное значение параметра так же, как параметры, связанные с параметрами, не являющиеся табличными. в каждом столбце возвращающего табличное значение параметра можно указать его фактическую длину данных, SQL_NULL_DATA или указать данные во время выполнения через буфер длины или индикатора.</span><span class="sxs-lookup"><span data-stu-id="9a628-145">When *StrLen_or_Ind* is not 0, the driver will process the table-valued parameter constituent columns in the same way as non-table-valued parameter bound parameters: Each table-valued parameter column can specify its actual data length, SQL_NULL_DATA, or it can specify data at execution via its length/indicator buffer.</span></span> <span data-ttu-id="9a628-146">Значения столбцов возвращающего табличное значение параметра могут передаваться повторными вызовами SQLPutData в обычном режиме, когда символьное или двоичное значения передаются в части.</span><span class="sxs-lookup"><span data-stu-id="9a628-146">Table-valued parameter column values can be passed by repeated calls to SQLPutData as usual when a character or binary value is to be passed in pieces.</span></span>  
  
 <span data-ttu-id="9a628-147">После того как все столбцы возвращающего табличное значение параметра были обработаны, драйвер снова обращается к возвращающему табличное значение параметру для обработки следующих строк данных возвращающего табличное значение параметра.</span><span class="sxs-lookup"><span data-stu-id="9a628-147">When all table-valued parameter columns have been processed, the driver returns to the table-valued parameter to process further rows of table-valued parameter data.</span></span> <span data-ttu-id="9a628-148">Поэтому для возвращающих табличное значение параметров с данными времени выполнения драйвер не выполняет обычный последовательный просмотр привязанных параметров.</span><span class="sxs-lookup"><span data-stu-id="9a628-148">Therefore, for data-at-execution table-valued parameters, the driver does not follow the usual sequential scan of bound parameters.</span></span> <span data-ttu-id="9a628-149">Связанный возвращающий табличное значение параметр будет опрашиваться до тех пор, пока SQLPutData не вызовется с *StrLen_or_IndPtr* равно 0, когда драйвер пропускает столбцы возвращающего табличное значение параметра и переходит к следующему реальному параметру хранимой процедуры.</span><span class="sxs-lookup"><span data-stu-id="9a628-149">A bound table-valued parameter will be polled until SQLPutData is called with *StrLen_Or_IndPtr* equal to 0, at which time the driver skips table-valued parameter columns and moves to the next actual stored procedure parameter.</span></span>  <span data-ttu-id="9a628-150">Когда SQLPutData передает значение индикатора, большее или равное 1, драйвер обрабатывает столбцы и строки возвращающих табличные значения параметров последовательно до тех пор, пока они не поступают со значениями для всех привязанных строк и столбцов.</span><span class="sxs-lookup"><span data-stu-id="9a628-150">When SQLPutData passes an indicator value greater than or equal to 1, the driver processes table-valued parameter columns and rows sequentially until it has values for all bound rows and columns.</span></span> <span data-ttu-id="9a628-151">Затем драйвер возвращается к возвращающему табличное значение параметру.</span><span class="sxs-lookup"><span data-stu-id="9a628-151">Then the driver returns to the table-valued parameter.</span></span> <span data-ttu-id="9a628-152">Между получением маркера для возвращающего табличное значение параметра из метод SQLParamData и вызовом SQLPutData (хстмт, NULL, n) для возвращающего табличное значение параметра приложение должно установить возвращающий табличное значение параметр, составляющий данные столбцов и содержимое буфера индикаторов для следующей строки или строк, которые будут переданы на сервер.</span><span class="sxs-lookup"><span data-stu-id="9a628-152">Between receiving the token for the table-valued parameter from SQLParamData and calling SQLPutData(hstmt, NULL, n) for a table-valued parameter, the application must set table-valued parameter constituent column data and indicator buffer contents for the next row or rows to be passed to the server.</span></span>  
  
 <span data-ttu-id="9a628-153">Пример кода для этого сценария приведен в подпрограмме, `demo_variable_TVP_binding` в которой [используются возвращающие табличное значение параметры &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span><span class="sxs-lookup"><span data-stu-id="9a628-153">Sample code for this scenario is in the routine `demo_variable_TVP_binding` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="retrieving-table-valued-parameter-metadata-from-the-system-catalog"></a><span data-ttu-id="9a628-154">Получение метаданных возвращающих табличное значение параметров из системного каталога</span><span class="sxs-lookup"><span data-stu-id="9a628-154">Retrieving Table-Valued Parameter Metadata from the System Catalog</span></span>  
 <span data-ttu-id="9a628-155">Когда приложение вызывает SQLProcedureColumns для процедуры, которая содержит параметры возвращающего табличное значение параметра, DATA_TYPE возвращается как SQL_SS_TABLE, а TYPE_NAME — имя табличного типа для возвращающего табличное значение параметра.</span><span class="sxs-lookup"><span data-stu-id="9a628-155">When an application calls SQLProcedureColumns for a procedure that has table-valued parameter parameters, DATA_TYPE is returned as SQL_SS_TABLE and TYPE_NAME is the name of the table type for the table-valued parameter.</span></span> <span data-ttu-id="9a628-156">В результирующий набор, возвращаемый функцией SQLProcedureColumns, добавляются два дополнительных столбца. SS_TYPE_CATALOG_NAME возвращает имя каталога, в котором определен табличный тип параметра table-value, и SS_TYPE_SCHEMA_NAME возвращает имя схемы, в которой определен тип таблицы параметра table-value.</span><span class="sxs-lookup"><span data-stu-id="9a628-156">Two additional columns are added to the result set returned by SQLProcedureColumns: SS_TYPE_CATALOG_NAME returns the name of the catalog where the table type of the table-value parameter is defined, and SS_TYPE_SCHEMA_NAME returns the name of the schema where the where the table type of the table-value parameter is defined.</span></span> <span data-ttu-id="9a628-157">В соответствии со спецификацией ODBC SS_TYPE_CATALOG_NAME и SS_TYPE_SCHEMA_NAME применяются до всех столбцов драйвера, которые были добавлены в предыдущих версиях [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], и после всех столбцов, применяемых ODBC.</span><span class="sxs-lookup"><span data-stu-id="9a628-157">In conformance with the ODBC specification, SS_TYPE_CATALOG_NAME and SS_TYPE_SCHEMA_NAME appear before all driver specific columns that were added in previous versions of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], and after all columns mandated by ODBC itself.</span></span>  
  
 <span data-ttu-id="9a628-158">Новые столбцы будут заполнены не только для возвращающих табличное значение параметров, но и для параметров определенного пользователем типа данных CLR.</span><span class="sxs-lookup"><span data-stu-id="9a628-158">The new columns will be populated not only for table-valued parameters, but also for CLR user-defined type parameters.</span></span> <span data-ttu-id="9a628-159">Существующие схема и столбцы каталога параметров определяемого пользователем типа будут все равно заполнены, но наличие общих схемы и столбцов каталога для типов данных, для которых они требуются, упростит разработку приложения в будущем.</span><span class="sxs-lookup"><span data-stu-id="9a628-159">The existing schema and catalog columns of UDT parameters will still be populated, but having common schema and catalog columns for data types that require them will simplify application development in the future.</span></span> <span data-ttu-id="9a628-160">(Следует отметить, что коллекции схем XML несколько отличаются и не включаются в это изменение).</span><span class="sxs-lookup"><span data-stu-id="9a628-160">(Note that XML schema collections are somewhat different and are not included in this change.)</span></span>  
  
 <span data-ttu-id="9a628-161">Приложение использует SQLTables для определения имен табличных типов так же, как и для постоянных таблиц, системных таблиц и представлений.</span><span class="sxs-lookup"><span data-stu-id="9a628-161">An application uses SQLTables to determine the names of table types the same way it does for persistent tables, system tables, and views.</span></span> <span data-ttu-id="9a628-162">Новый табличный тип TABLE TYPE вводится, чтобы приложение могло определить табличный тип, связанный с возвращающими табличное значение параметрами.</span><span class="sxs-lookup"><span data-stu-id="9a628-162">A new table type, TABLE TYPE, is introduced to enable an application to identify table types associated with table-valued parameters.</span></span> <span data-ttu-id="9a628-163">Табличные типы и обычные таблицы используют различные пространства имен.</span><span class="sxs-lookup"><span data-stu-id="9a628-163">Table types and regular tables use different namespaces.</span></span> <span data-ttu-id="9a628-164">Это значит, что можно использовать одно и то же имя как для табличного типа, так и для существующей таблицы.</span><span class="sxs-lookup"><span data-stu-id="9a628-164">This means that you can use the same name for both a table type and an actual table.</span></span> <span data-ttu-id="9a628-165">Для обработки этой ситуации был введен новый атрибут инструкции SQL_SOPT_SS_NAME_SCOPE.</span><span class="sxs-lookup"><span data-stu-id="9a628-165">To handle this, a new statement attribute, SQL_SOPT_SS_NAME_SCOPE, has been introduced.</span></span> <span data-ttu-id="9a628-166">Этот атрибут указывает, должны ли SQLTables и другие функции каталога, принимающие имя таблицы в качестве параметра, интерпретировать имя таблицы как имя фактической таблицы или имя табличного типа.</span><span class="sxs-lookup"><span data-stu-id="9a628-166">This attribute specifies whether SQLTables and other catalog functions that take a table name as a parameter should interpret the table name as the name of an actual table or the name of a table type.</span></span>  
  
 <span data-ttu-id="9a628-167">Приложение использует SQLColumns, чтобы определить столбцы для табличного типа так же, как и для постоянных таблиц, но сначала необходимо задать SQL_SOPT_SS_NAME_SCOPE, чтобы указать, что она работает с табличными типами, а не с реальными таблицами.</span><span class="sxs-lookup"><span data-stu-id="9a628-167">An application uses SQLColumns to determine the columns for a table type in the same way it does for persistent tables, but must first set SQL_SOPT_SS_NAME_SCOPE to indicate that it is working with table types rather than actual tables.</span></span> <span data-ttu-id="9a628-168">SQLPrimaryKeys также можно использовать с табличными типами, опять же используя SQL_SOPT_SS_NAME_SCOPE.</span><span class="sxs-lookup"><span data-stu-id="9a628-168">SQLPrimaryKeys can also be used with table types, again using SQL_SOPT_SS_NAME_SCOPE.</span></span>  
  
 <span data-ttu-id="9a628-169">Пример кода для этого сценария приведен в подпрограмме, `demo_metadata_from_catalog_APIs` в которой [используются возвращающие табличное значение параметры &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span><span class="sxs-lookup"><span data-stu-id="9a628-169">Sample code for this scenario is in the routine `demo_metadata_from_catalog_APIs` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="retrieving-table-valued-parameter-metadata-for-a-prepared-statement"></a><span data-ttu-id="9a628-170">Получение метаданных возвращающих табличное значение параметров для подготовленной инструкции</span><span class="sxs-lookup"><span data-stu-id="9a628-170">Retrieving Table-Valued Parameter Metadata for a Prepared Statement</span></span>  
 <span data-ttu-id="9a628-171">В этом сценарии приложение использует Склнумпараметерс и SQLDescribeParam для получения метаданных для возвращающих табличное значение параметров.</span><span class="sxs-lookup"><span data-stu-id="9a628-171">In this scenario, an application uses SQLNumParameters and SQLDescribeParam to retrieve metadata for table-valued parameters.</span></span>  
  
 <span data-ttu-id="9a628-172">IPD-поле атрибута SQL_CA_SS_TYPE_NAME используется для получения имени типа для возвращающего табличное значение параметра.</span><span class="sxs-lookup"><span data-stu-id="9a628-172">The IPD field SQL_CA_SS_TYPE_NAME is used to retrieve the type name for the table-valued parameter.</span></span> <span data-ttu-id="9a628-173">IPD-поля атрибутов SQL_CA_SS_TYPE_SCHEMA_NAME и SQL_CA_SS_TYPE_CATALOG_NAME используются соответственно для получения каталога и схемы этого параметра.</span><span class="sxs-lookup"><span data-stu-id="9a628-173">The IPD fields SQL_CA_SS_TYPE_SCHEMA_NAME and SQL_CA_SS_TYPE_CATALOG_NAME are used to retrieve its catalog and schema, respectively.</span></span>  
  
 <span data-ttu-id="9a628-174">Определения табличных типов и возвращающие табличное значение параметры должны находиться в одной базе данных.</span><span class="sxs-lookup"><span data-stu-id="9a628-174">Table type definitions and table-valued parameters must be in the same database.</span></span> <span data-ttu-id="9a628-175">SQLSetDescField будет сообщать об ошибке, если приложение задает SQL_CA_SS_TYPE_CATALOG_NAME при использовании возвращающих табличное значение параметров.</span><span class="sxs-lookup"><span data-stu-id="9a628-175">SQLSetDescField will report an error if an application sets SQL_CA_SS_TYPE_CATALOG_NAME when using table-valued parameters.</span></span>  
  
 <span data-ttu-id="9a628-176">Атрибуты SQL_CA_SS_TYPE_CATALOG_NAME и SQL_CA_SS_TYPE_SCHEMA_NAME могут также использоваться для получения каталога и схемы, связанных с параметрами определяемых пользователем типов данных CLR.</span><span class="sxs-lookup"><span data-stu-id="9a628-176">SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME can also be used to retrieve the catalog and schema associated with CLR user-defined type parameters.</span></span> <span data-ttu-id="9a628-177">Атрибуты SQL_CA_SS_TYPE_CATALOG_NAME и SQL_CA_SS_TYPE_SCHEMA_NAME представляют собой альтернативу существующим атрибутам типов в схеме каталогов для определяемых пользователем типов данных CLR.</span><span class="sxs-lookup"><span data-stu-id="9a628-177">SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME are alternatives to the existing type specific catalog schema attributes for CLR UDT types.</span></span>  
  
 <span data-ttu-id="9a628-178">Приложение использует SQLColumns для получения метаданных столбца для возвращающего табличное значение параметра в этом сценарии, так как SQLDescribeParam не возвращает метаданные для столбцов возвращающего табличное значение параметра столбца.</span><span class="sxs-lookup"><span data-stu-id="9a628-178">An application uses SQLColumns to retrieve column metadata for a table-valued parameter in this scenario, too, because SQLDescribeParam does not return metadata for the columns of a table-valued parameter column.</span></span>  
  
 <span data-ttu-id="9a628-179">Пример кода для этого варианта использования — в подпрограмме, `demo_metadata_from_prepared_statement` [использующей возвращающие табличное значение параметры, &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span><span class="sxs-lookup"><span data-stu-id="9a628-179">Sample code for this use case is in the routine `demo_metadata_from_prepared_statement` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9a628-180">См. также:</span><span class="sxs-lookup"><span data-stu-id="9a628-180">See Also</span></span>  
 [<span data-ttu-id="9a628-181">Возвращающие табличное значение параметры &#40;ODBC&#41;</span><span class="sxs-lookup"><span data-stu-id="9a628-181">Table-Valued Parameters &#40;ODBC&#41;</span></span>](table-valued-parameters-odbc.md)  
  
  

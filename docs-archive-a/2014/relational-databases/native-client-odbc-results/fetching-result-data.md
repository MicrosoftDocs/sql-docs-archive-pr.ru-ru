---
title: Выборка результирующих данных | Документация Майкрософт
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- SQLFetchScroll function
- SQL Server Native Client ODBC driver, result sets
- ODBC applications, result sets
- data types [ODBC], fetching
- SQLBindCol function
- result sets [ODBC], fetching
- fetching [ODBC]
- ODBC data types, fetching
- SQLFetch function
- SQL Server Native Client ODBC driver, data types
- SQLGetData function
ms.assetid: b289c7fb-5017-4d7e-a2d3-19401e9fc4cd
author: rothja
ms.author: jroth
ms.openlocfilehash: 7eb038d431dd7f733c36e5913d72cdc6a161acad
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87750871"
---
# <a name="fetching-result-data"></a><span data-ttu-id="e6118-102">Выборка итоговых данных</span><span class="sxs-lookup"><span data-stu-id="e6118-102">Fetching Result Data</span></span>
  <span data-ttu-id="e6118-103">Приложение ODBC имеет три параметра для выборки данных результата.</span><span class="sxs-lookup"><span data-stu-id="e6118-103">An ODBC application has three options for fetching result data.</span></span>  
  
 <span data-ttu-id="e6118-104">Первый вариант основан на [SQLBindCol](../native-client-odbc-api/sqlbindcol.md).</span><span class="sxs-lookup"><span data-stu-id="e6118-104">The first option is based on [SQLBindCol](../native-client-odbc-api/sqlbindcol.md).</span></span> <span data-ttu-id="e6118-105">Перед получением результирующего набора приложение использует **SQLBindCol** для привязки каждого столбца результирующего набора к программной переменной.</span><span class="sxs-lookup"><span data-stu-id="e6118-105">Before fetching the result set, the application uses **SQLBindCol** to bind each column in the result set to a program variable.</span></span> <span data-ttu-id="e6118-106">После привязки столбцов драйвер передает данные текущей строки в переменные, привязанные к столбцам результирующего набора каждый раз, когда приложение вызывает **SQLFetch** или [SQLFetchScroll](../native-client-odbc-api/sqlfetchscroll.md).</span><span class="sxs-lookup"><span data-stu-id="e6118-106">After the columns have been bound, the driver transfers the data of the current row into the variables bound to the result set columns each time the application calls **SQLFetch** or [SQLFetchScroll](../native-client-odbc-api/sqlfetchscroll.md).</span></span> <span data-ttu-id="e6118-107">Если столбец результирующего набора и программная переменная имеют разные типы данных, драйвер выполняет преобразования данных.</span><span class="sxs-lookup"><span data-stu-id="e6118-107">The driver handles data conversions if the result set column and program variable have different data types.</span></span> <span data-ttu-id="e6118-108">Если приложение имеет SQL_ATTR_ROW_ARRAY_SIZE больше 1, оно может привязать результирующие столбцы к массивам переменных, которые будут заполнены при каждом вызове **SQLFetchScroll**.</span><span class="sxs-lookup"><span data-stu-id="e6118-108">If the application has SQL_ATTR_ROW_ARRAY_SIZE set greater than 1, it can bind result columns to arrays of variables, which will all be filled on each call to **SQLFetchScroll**.</span></span>  
  
 <span data-ttu-id="e6118-109">Второй вариант основан на [SQLGetData](../native-client-odbc-api/sqlgetdata.md).</span><span class="sxs-lookup"><span data-stu-id="e6118-109">The second option is based on [SQLGetData](../native-client-odbc-api/sqlgetdata.md).</span></span> <span data-ttu-id="e6118-110">Приложение не использует **SQLBindCol** для привязки столбцов результирующего набора к переменным программы.</span><span class="sxs-lookup"><span data-stu-id="e6118-110">The application does not use **SQLBindCol** to bind result set columns to program variables.</span></span> <span data-ttu-id="e6118-111">После каждого вызова **SQLFetch**приложение вызывает **SQLGetData** один раз для каждого столбца в результирующем наборе.</span><span class="sxs-lookup"><span data-stu-id="e6118-111">After each call to **SQLFetch**, the application calls **SQLGetData** once for each column in the result set.</span></span> <span data-ttu-id="e6118-112">**SQLGetData** инструктирует драйвер для передачи данных из определенного столбца результирующего набора в определенную переменную программы и задает типы данных столбца и переменной.</span><span class="sxs-lookup"><span data-stu-id="e6118-112">**SQLGetData** instructs the driver to transfer data from a specific result set column to a specific program variable and specifies the data types of the column and variable.</span></span> <span data-ttu-id="e6118-113">Это позволяет драйверу преобразовать данные, если столбец результата и программная переменная имеют разные типы данных.</span><span class="sxs-lookup"><span data-stu-id="e6118-113">This allows the driver to convert data if the result column and program variable have different data types.</span></span> <span data-ttu-id="e6118-114">Столбцы типа **Text**, **ntext**и **Image** обычно слишком велики, чтобы вместить их в переменную программы, но по-прежнему можно получить с помощью **SQLGetData**.</span><span class="sxs-lookup"><span data-stu-id="e6118-114">**Text**, **ntext**, and **image** columns are typically too large to fit into a program variable but can still be retrieved using **SQLGetData**.</span></span> <span data-ttu-id="e6118-115">Если данные типа **Text**, **ntext**или **Image** в столбце Result больше, чем переменная программы, **SQLGetData** возвращает SQL_SUCCESS_WITH_INFO и SQLSTATE 01004 (строковые данные, усеченные справа).</span><span class="sxs-lookup"><span data-stu-id="e6118-115">If the **text**, **ntext**, or **image** data in the result column is larger than the program variable, **SQLGetData** returns SQL_SUCCESS_WITH_INFO and SQLSTATE 01004 (string data, right truncated).</span></span> <span data-ttu-id="e6118-116">Последовательные вызовы **SQLGetData** возвращают последовательные фрагменты данных **текста** или **изображения** .</span><span class="sxs-lookup"><span data-stu-id="e6118-116">Successive calls to **SQLGetData** return successive chunks of the **text** or **image** data.</span></span> <span data-ttu-id="e6118-117">По достижении конца данных **SQLGetData** возвращает SQL_SUCCESS.</span><span class="sxs-lookup"><span data-stu-id="e6118-117">When the end of the data is reached, **SQLGetData** returns SQL_SUCCESS.</span></span> <span data-ttu-id="e6118-118">Если SQL_ATTR_ROW_ARRAY_SIZE больше 1, то каждая выборка возвращает набор строк.</span><span class="sxs-lookup"><span data-stu-id="e6118-118">Each fetch returns a set of rows, or rowset, if SQL_ATTR_ROW_ARRAY_SIZE is greater than 1.</span></span> <span data-ttu-id="e6118-119">Перед использованием **SQLGetData**необходимо сначала использовать функцию **SQLSetPos** , чтобы указать определенную строку в наборе строк в качестве текущей строки.</span><span class="sxs-lookup"><span data-stu-id="e6118-119">Before using **SQLGetData**, you must first use **SQLSetPos** to specify a specific row within the rowset as the current row.</span></span>  
  
 <span data-ttu-id="e6118-120">Третий вариант — использовать сочетание **SQLBindCol** и **SQLGetData**.</span><span class="sxs-lookup"><span data-stu-id="e6118-120">The third option is to use a mix of **SQLBindCol** and **SQLGetData**.</span></span> <span data-ttu-id="e6118-121">Приложение может, например, привязать первые десять столбцов результирующего набора, а затем при каждой выборки вызвать **SQLGetData** три раза, чтобы получить данные из трех несвязанных столбцов.</span><span class="sxs-lookup"><span data-stu-id="e6118-121">An application could, for example, bind the first ten columns of a result set and then, on each fetch, call **SQLGetData** three times to retrieve the data from three unbound columns.</span></span> <span data-ttu-id="e6118-122">Обычно это используется, когда результирующий набор содержит один или несколько столбцов типа **Text** или **Image** .</span><span class="sxs-lookup"><span data-stu-id="e6118-122">This would typically be used when a result set contains one or more **text** or **image** columns.</span></span>  
  
 <span data-ttu-id="e6118-123">В зависимости от параметров курсора, заданных для результирующего набора, приложение может также использовать параметры прокрутки **SQLFetchScroll** для прокрутки результирующего набора.</span><span class="sxs-lookup"><span data-stu-id="e6118-123">Depending on the cursor options set for the result set, an application can also use the scrolling options of **SQLFetchScroll** to scroll around the result set.</span></span>  
  
 <span data-ttu-id="e6118-124">Чрезмерное использование **SQLBindCol** для привязки столбца результирующего набора к программной переменной является дорогостоящим, так как **SQLBindCol** приводит к тому, что драйвер ODBC выделяет память.</span><span class="sxs-lookup"><span data-stu-id="e6118-124">Excess use of **SQLBindCol** to bind a result set column to a program variable is expensive because **SQLBindCol** causes an ODBC driver to allocate memory.</span></span> <span data-ttu-id="e6118-125">При привязке результирующего столбца к переменной эта привязка остается действующей до тех пор, пока не будет вызван [SQLFreeHandle](../native-client-odbc-api/sqlfreehandle.md) для освобождения маркера инструкции или вызов [SQLFreeStmt](../native-client-odbc-api/sqlfreestmt.md) с *параметром fOption* , для которого задано значение SQL_UNBIND.</span><span class="sxs-lookup"><span data-stu-id="e6118-125">When you bind a result column to a variable, that binding remains in effect until you either call [SQLFreeHandle](../native-client-odbc-api/sqlfreehandle.md) to free the statement handle or call [SQLFreeStmt](../native-client-odbc-api/sqlfreestmt.md) with *fOption* set to SQL_UNBIND.</span></span> <span data-ttu-id="e6118-126">По завершении инструкции привязки автоматически не снимаются.</span><span class="sxs-lookup"><span data-stu-id="e6118-126">The bindings are not automatically undone when the statement completes.</span></span>  
  
 <span data-ttu-id="e6118-127">Эта логика позволяет эффективно выполнять инструкцию SELECT несколько раз с различными параметрами.</span><span class="sxs-lookup"><span data-stu-id="e6118-127">This logic allows you to effectively deal with executing the same SELECT statement several times with different parameters.</span></span> <span data-ttu-id="e6118-128">Так как результирующий набор сохраняет одну и ту же структуру, можно привязать результирующий набор один раз, обработать все инструкции SELECT, а затем вызвать **SQLFreeStmt** с параметром *параметром foption* , чтобы SQL_UNBIND после последнего выполнения.</span><span class="sxs-lookup"><span data-stu-id="e6118-128">Because the result set keeps the same structure, you can bind the result set once, process all the SELECT statements, then call **SQLFreeStmt** with *fOption* set to SQL_UNBIND after the last execution.</span></span> <span data-ttu-id="e6118-129">Не следует вызывать **SQLBindCol** для привязки столбцов в результирующем наборе без предварительного вызова **SQLFreeStmt** с *параметром fOption* , равным SQL_UNBIND, чтобы освободить все предыдущие привязки.</span><span class="sxs-lookup"><span data-stu-id="e6118-129">You should not call **SQLBindCol** to bind the columns in a result set without first calling **SQLFreeStmt** with *fOption* set to SQL_UNBIND to free any previous bindings.</span></span>  
  
 <span data-ttu-id="e6118-130">При использовании **SQLBindCol**можно выполнить привязку на уровне строки или на уровне столбца.</span><span class="sxs-lookup"><span data-stu-id="e6118-130">When using **SQLBindCol**, you can either do row-wise or column-wise binding.</span></span> <span data-ttu-id="e6118-131">Привязка параметров на уровне строк быстрее, чем привязка на уровне столбцов.</span><span class="sxs-lookup"><span data-stu-id="e6118-131">Row-wise binding is somewhat faster than column-wise binding.</span></span>  
  
 <span data-ttu-id="e6118-132">**SQLGetData** можно использовать для получения данных по столбцам вместо привязки столбцов результирующего набора с помощью **SQLBindCol**.</span><span class="sxs-lookup"><span data-stu-id="e6118-132">You can use **SQLGetData** to retrieve data on a column-by-column basis instead of binding result set columns using **SQLBindCol**.</span></span> <span data-ttu-id="e6118-133">Если результирующий набор содержит всего несколько строк, использование **SQLGetData** вместо **SQLBindCol** выполняется быстрее. в противном случае **SQLBindCol** обеспечивает наилучшую производительность.</span><span class="sxs-lookup"><span data-stu-id="e6118-133">If a result set contains only a few rows, using **SQLGetData** instead of **SQLBindCol** is faster; otherwise, **SQLBindCol** gives the best performance.</span></span> <span data-ttu-id="e6118-134">Если данные не всегда помещаются в один и тот же набор переменных, следует использовать **SQLGetData** вместо постоянной повторной привязки.</span><span class="sxs-lookup"><span data-stu-id="e6118-134">If you do not always put the data in the same set of variables, you should use **SQLGetData** instead of constantly rebinding.</span></span> <span data-ttu-id="e6118-135">**SQLGetData** можно использовать только для столбцов, которые находятся в списке выбора после привязки всех столбцов к **SQLBindCol**.</span><span class="sxs-lookup"><span data-stu-id="e6118-135">You can only use **SQLGetData** on columns that are in the select list after all columns are bound with **SQLBindCol**.</span></span> <span data-ttu-id="e6118-136">Этот столбец также должен присутствовать после всех столбцов, на которых уже используется **SQLGetData**.</span><span class="sxs-lookup"><span data-stu-id="e6118-136">The column must also appear after any columns on which you have already used **SQLGetData**.</span></span>  
  
 <span data-ttu-id="e6118-137">Функции ODBC, которые работают с перемещением данных в переменные программы, такие как **SQLGetData**, **SQLBindCol**и [SQLBindParameter](../native-client-odbc-api/sqlbindparameter.md), поддерживают неявное преобразование типов данных.</span><span class="sxs-lookup"><span data-stu-id="e6118-137">The ODBC functions that deal with moving data into or out of program variables, such as **SQLGetData**, **SQLBindCol**, and [SQLBindParameter](../native-client-odbc-api/sqlbindparameter.md), support implicit data type conversion.</span></span> <span data-ttu-id="e6118-138">Например, если приложение привязывает целочисленный столбец к строковой программной переменной, драйвер автоматически преобразует данные из целочисленного в символьный тип перед тем, как поместить их в программную переменную.</span><span class="sxs-lookup"><span data-stu-id="e6118-138">For example, if an application binds an integer column to a character string program variable, the driver automatically converts the data from integer to character before placing it into the program variable.</span></span>  
  
 <span data-ttu-id="e6118-139">Количество преобразований данных в приложениях должно быть минимальным.</span><span class="sxs-lookup"><span data-stu-id="e6118-139">Data conversion in applications should be minimized.</span></span> <span data-ttu-id="e6118-140">Если преобразование данных не требуется для вычислений, производимых приложением, приложения привяжут столбцы и параметры к программным переменным того же типа данных.</span><span class="sxs-lookup"><span data-stu-id="e6118-140">Unless data conversion is required for the processing done by the application, applications should bind columns and parameters to program variables of the same data type.</span></span> <span data-ttu-id="e6118-141">Однако, если данные должны быть преобразованы из одного типа в другой, более эффективным будет преобразовать данные с помощью драйвера, чем делать это в приложении.</span><span class="sxs-lookup"><span data-stu-id="e6118-141">If the data must be converted from one type to another, however, it is more efficient to have the driver do the conversion than doing it in the application.</span></span> <span data-ttu-id="e6118-142">Драйвер для собственного клиента ODBC [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] обычно только передает данные непосредственно из сетевых буферов в переменные приложения.</span><span class="sxs-lookup"><span data-stu-id="e6118-142">The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver normally just transfers data directly from the network buffers to the variables of the application.</span></span> <span data-ttu-id="e6118-143">Обращение к драйверу для добавления преобразования данных приведет к буферизации данных драйвером и использованию времени ЦП для преобразования данных.</span><span class="sxs-lookup"><span data-stu-id="e6118-143">Requesting the driver to do data conversion forces the driver to buffer the data and use CPU cycles to convert the data.</span></span>  
  
 <span data-ttu-id="e6118-144">Программные переменные должны быть достаточно большими для хранения данных, передаваемых из столбца, за исключением данных типа **Text**, **ntext**и **Image** .</span><span class="sxs-lookup"><span data-stu-id="e6118-144">Program variables should be large enough to hold data transferred in from a column, except for **text**, **ntext**, and **image** data.</span></span> <span data-ttu-id="e6118-145">Если приложение пытается получить результирующий набор данных и сохранить его в переменной недостаточного размера, драйвер сформирует предупреждение.</span><span class="sxs-lookup"><span data-stu-id="e6118-145">If an application attempts to retrieve result set data and place it into a variable that is too small to hold it, the driver generates a warning.</span></span> <span data-ttu-id="e6118-146">Это заставит драйвер выделить память для сообщения, а драйвер и приложение будут вынуждены тратить время ЦП на обработку сообщения и ошибок.</span><span class="sxs-lookup"><span data-stu-id="e6118-146">This forces the driver to allocate memory for the message, and the driver and application both have to spend CPU cycles processing the message and doing error handling.</span></span> <span data-ttu-id="e6118-147">Приложение должно либо выделить достаточно большую переменную для сохранения полученных данных, либо использовать функцию SUBSTRING в списке выбора для уменьшения размера столбца в результирующем наборе.</span><span class="sxs-lookup"><span data-stu-id="e6118-147">The application should either allocate a variable large enough to hold the data being retrieved or use the SUBSTRING function in the select list to reduce the size of the column in the result set.</span></span>  
  
 <span data-ttu-id="e6118-148">Следует соблюдать осторожность при использовании SQL_C_DEFAULT для указания типа переменной C.</span><span class="sxs-lookup"><span data-stu-id="e6118-148">Care must be taken when using SQL_C_DEFAULT to specify the type of the C variable.</span></span> <span data-ttu-id="e6118-149">SQL_C_DEFAULT указывает, что тип переменной C соответствует типу данных SQL столбца или параметра.</span><span class="sxs-lookup"><span data-stu-id="e6118-149">SQL_C_DEFAULT specifies that the type of the C variable matches the SQL data type of the column or parameter.</span></span> <span data-ttu-id="e6118-150">Если для столбца **ntext**, **nchar**или **nvarchar** задано SQL_C_DEFAULT, в приложение возвращаются данные в Юникоде.</span><span class="sxs-lookup"><span data-stu-id="e6118-150">If SQL_C_DEFAULT is specified for an **ntext**, **nchar**, or **nvarchar** column, Unicode data is returned to the application.</span></span> <span data-ttu-id="e6118-151">Это может привести к возникновению различных проблем, если приложение не было настроено для обработки данных в Юникоде.</span><span class="sxs-lookup"><span data-stu-id="e6118-151">This can cause various problems if the application has not been coded to handle Unicode data.</span></span> <span data-ttu-id="e6118-152">Аналогичные типы проблем могут возникать при использовании типа данных **uniqueidentifier** (SQL_GUID).</span><span class="sxs-lookup"><span data-stu-id="e6118-152">The same types of problems can occur with the **uniqueidentifier** (SQL_GUID) data type.</span></span>  
  
 <span data-ttu-id="e6118-153">данные типа **Text**, **ntext**и **Image** обычно слишком велики, чтобы вместить их в одну переменную программы, и обычно обрабатываются с помощью **SQLGetData** вместо **SQLBindCol**.</span><span class="sxs-lookup"><span data-stu-id="e6118-153">**text**, **ntext**, and **image** data is typically too large to fit into a single program variable, and is usually processed with **SQLGetData** instead of **SQLBindCol**.</span></span> <span data-ttu-id="e6118-154">При использовании серверных курсоров [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] драйвер ODBC для собственного клиента оптимизирован для передачи данных для непривязанных столбцов типа **Text**, **ntext**или **Image** на момент выборки строки.</span><span class="sxs-lookup"><span data-stu-id="e6118-154">When using server cursors, the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver is optimized to not transmit the data for unbound **text**, **ntext**, or **image** columns at the time the row is fetched.</span></span> <span data-ttu-id="e6118-155">Данные типа **Text**, **ntext**или **Image** на самом деле не извлекаются с сервера, пока приложение не выдаст **SQLGetData** для столбца.</span><span class="sxs-lookup"><span data-stu-id="e6118-155">The **text**, **ntext**, or **image** data is not actually retrieved from the server until the application issues **SQLGetData** for the column.</span></span>  
  
 <span data-ttu-id="e6118-156">Эту оптимизацию можно применить к приложениям, чтобы не отображались данные типа **Text**, **ntext**или **Image** , пока пользователь прокручивает курсор вверх и вниз.</span><span class="sxs-lookup"><span data-stu-id="e6118-156">This optimization can be applied to applications so that no **text**, **ntext**, or **image** data is displayed while a user is scrolling up and down a cursor.</span></span> <span data-ttu-id="e6118-157">После того как пользователь выберет строку, приложение может вызвать **SQLGetData** для получения данных типа **Text**, **ntext**или **Image** .</span><span class="sxs-lookup"><span data-stu-id="e6118-157">After the user selects a row, the application can call **SQLGetData** to retrieve the **text**, **ntext**, or **image** data.</span></span> <span data-ttu-id="e6118-158">Это сохраняет передачу данных типа **Text**, **ntext**или **Image** для любой строки, которую пользователь не выбирает, и может сохранять передачу очень больших объемов данных.</span><span class="sxs-lookup"><span data-stu-id="e6118-158">This saves transmitting the **text**, **ntext**, or **image** data for any of the rows the user does not select and can save the transmission of very large amounts of data.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e6118-159">См. также:</span><span class="sxs-lookup"><span data-stu-id="e6118-159">See Also</span></span>  
 [<span data-ttu-id="e6118-160">Обработка результатов &#40;ODBC&#41;</span><span class="sxs-lookup"><span data-stu-id="e6118-160">Processing Results &#40;ODBC&#41;</span></span>](processing-results-odbc.md)  
  
  

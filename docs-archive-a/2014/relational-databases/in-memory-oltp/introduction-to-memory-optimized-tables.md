---
title: Введение в таблицы, оптимизированные для памяти | Документация Майкрософт
ms.custom: ''
ms.date: 07/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: ef1cc7de-63be-4fa3-a622-6d93b440e3ac
author: rothja
ms.author: jroth
ms.openlocfilehash: edcdea9d266cf0ef231b1e16be4da7009372dcd6
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87751000"
---
# <a name="introduction-to-memory-optimized-tables"></a><span data-ttu-id="04078-102">Введение в таблицы, оптимизированные для памяти</span><span class="sxs-lookup"><span data-stu-id="04078-102">Introduction to Memory-Optimized Tables</span></span>
  <span data-ttu-id="04078-103">Оптимизированные для памяти таблицы, созданные с помощью инструкции [CREATE TABLE (Transact-SQL)](/sql/t-sql/statements/create-table-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="04078-103">Memory-optimized tables are tables, created using [CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql).</span></span>  
  
 <span data-ttu-id="04078-104">Оптимизированные для памяти таблицы находятся в памяти.</span><span class="sxs-lookup"><span data-stu-id="04078-104">Memory-optimized tables reside in memory.</span></span> <span data-ttu-id="04078-105">Строки из таблицы считываются и записываются в память.</span><span class="sxs-lookup"><span data-stu-id="04078-105">Rows in the table are read from and written to memory.</span></span> <span data-ttu-id="04078-106">Вся таблица находится в памяти.</span><span class="sxs-lookup"><span data-stu-id="04078-106">The entire table resides in memory.</span></span> <span data-ttu-id="04078-107">Вторая копия табличных данных хранится на диске, но только с целью увеличения устойчивости.</span><span class="sxs-lookup"><span data-stu-id="04078-107">A second copy of the table data is maintained on disk, but only for durability purposes.</span></span>  
  
 <span data-ttu-id="04078-108">OLTP-операции в памяти интегрированы с [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] для эффективной работы в любых областях, таких как разработка, развертывание, управление и поддержка.</span><span class="sxs-lookup"><span data-stu-id="04078-108">In-Memory OLTP is integrated with [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to provide a seamless experience in all areas such as development, deployment, manageability, and supportability.</span></span> <span data-ttu-id="04078-109">База данных может содержать как объекты в памяти, так и объекты на диске.</span><span class="sxs-lookup"><span data-stu-id="04078-109">A database can contain in-memory as well as disk-based objects.</span></span>  
  
 <span data-ttu-id="04078-110">Строки в оптимизированных для памяти таблицах имеют версии.</span><span class="sxs-lookup"><span data-stu-id="04078-110">Rows in memory-optimized tables are versioned.</span></span> <span data-ttu-id="04078-111">То есть каждая строка в таблице потенциально имеет несколько версий.</span><span class="sxs-lookup"><span data-stu-id="04078-111">This means that each row in the table potentially has multiple versions.</span></span> <span data-ttu-id="04078-112">Все версии строк сохраняются в одной структуре данных таблицы.</span><span class="sxs-lookup"><span data-stu-id="04078-112">All row versions are maintained in the same table data structure.</span></span> <span data-ttu-id="04078-113">Управление версиями строк используется, чтобы разрешить параллельный режим чтения и записи для одной строки.</span><span class="sxs-lookup"><span data-stu-id="04078-113">Row versioning is used to allow concurrent reads and writes on the same row.</span></span> <span data-ttu-id="04078-114">Дополнительные сведения о параллельном режиме чтения и записи для одной строки см. в разделе [Transactions in Memory-Optimized Tables](memory-optimized-tables.md).</span><span class="sxs-lookup"><span data-stu-id="04078-114">For more information about concurrent reads and writes on the same row, see [Transactions in Memory-Optimized Tables](memory-optimized-tables.md).</span></span>  
  
 <span data-ttu-id="04078-115">На следующем рисунке показана работа с несколькими версиями строк.</span><span class="sxs-lookup"><span data-stu-id="04078-115">The following figure illustrates multi-versioning.</span></span> <span data-ttu-id="04078-116">На схеме показана таблица с тремя строками, у каждой строки своя версия.</span><span class="sxs-lookup"><span data-stu-id="04078-116">The figure shows a table with three rows and each row has different versions.</span></span>  
  
 <span data-ttu-id="04078-117">![Управление версиями.](../../database-engine/media/hekaton-tables-1.gif "Управление версиями.")</span><span class="sxs-lookup"><span data-stu-id="04078-117">![Multi-versioning.](../../database-engine/media/hekaton-tables-1.gif "Multi-versioning.")</span></span>  
  
 <span data-ttu-id="04078-118">Таблица содержит три строки: r1, r2 и r3.</span><span class="sxs-lookup"><span data-stu-id="04078-118">The table has three rows: r1, r2, and r3.</span></span> <span data-ttu-id="04078-119">r1 содержит три версии, r2 — 2 версии, и r3 — 4 версии.</span><span class="sxs-lookup"><span data-stu-id="04078-119">r1 has three versions, r2 has two versions, and r3 has four versions.</span></span> <span data-ttu-id="04078-120">Обратите внимание, что разные версии одной и той же строки не обязательно занимают последовательные области памяти.</span><span class="sxs-lookup"><span data-stu-id="04078-120">Note that different versions of the same row do not necessarily occupy consecutive memory locations.</span></span> <span data-ttu-id="04078-121">Различные версии строк могут быть распределены по всей структуре данных таблицы.</span><span class="sxs-lookup"><span data-stu-id="04078-121">The different row versions can be dispersed throughout the table data structure.</span></span>  
  
 <span data-ttu-id="04078-122">Структуру данных таблицы, оптимизированной для памяти, можно рассматривать как коллекцию версий строк.</span><span class="sxs-lookup"><span data-stu-id="04078-122">The memory-optimized table data structure can be seen as a collection of row versions.</span></span> <span data-ttu-id="04078-123">Строки в таблицах, сохраняемых на диске, разбиты по страницам и расширениям, при этом доступ к отдельным строкам осуществляется через номер страницы и смещение. Доступ к версиям строк в таблицах с оптимизацией для памяти осуществляется посредством указателей памяти, занимающих 8 байт.</span><span class="sxs-lookup"><span data-stu-id="04078-123">Rows in disk-based tables are organized in pages and extents, and individual rows addressed using page number and page offset, row versions in memory-optimized tables are addressed using 8-byte memory pointers.</span></span>  
  
## <a name="durability"></a><span data-ttu-id="04078-124">Устойчивость</span><span class="sxs-lookup"><span data-stu-id="04078-124">Durability</span></span>  
 <span data-ttu-id="04078-125">Таблицы, оптимизированные для памяти, по умолчанию полностью устойчивы, и подобно транзакциям в обычных таблицах на диске полностью устойчивые транзакции на оптимизированных для памяти таблицах полностью соответствуют классификации ACID (atomic, consistent, isolated, durable — атомарные, целостные, изолированные, устойчивые).</span><span class="sxs-lookup"><span data-stu-id="04078-125">Memory-optimized tables are fully durable by default, and, like transactions on (traditional) disk-based tables, fully durable transactions on memory-optimized tables are fully atomic, consistent, isolated, and durable (ACID).</span></span> <span data-ttu-id="04078-126">Оптимизированные для памяти таблицы и скомпилированные в собственном коде хранимые процедуры поддерживают подмножество [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="04078-126">Memory-optimized tables and natively compiled stored procedures support a subset of [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span>  
  
 <span data-ttu-id="04078-127">OLTP в памяти поддерживает устойчивые таблицы с отложенной устойчивостью транзакций.</span><span class="sxs-lookup"><span data-stu-id="04078-127">In-Memory OLTP supports durable tables with transaction durability delayed.</span></span> <span data-ttu-id="04078-128">Отложенные устойчивые транзакции сохраняются на диск сразу после совершения транзакции.</span><span class="sxs-lookup"><span data-stu-id="04078-128">Delayed durable transactions are saved to disk soon after the transaction has committed.</span></span> <span data-ttu-id="04078-129">Платой за повышение производительности является то, что зафиксированные транзакции, не сохраненные на диск, теряются при сбое или отработке отказа сервера.</span><span class="sxs-lookup"><span data-stu-id="04078-129">In exchange for the increased performance, committed transactions that have not saved to disk are lost in a server crash or failover.</span></span>  
  
 <span data-ttu-id="04078-130">Помимо устойчивых оптимизированных для памяти таблиц [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] также поддерживает неустойчивые таблицы в памяти, которые не заносятся в журнал, а их данные не сохраняются на диске.</span><span class="sxs-lookup"><span data-stu-id="04078-130">Besides the default durable memory-optimized tables, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] also supports non-durable memory-optimized tables, which are not logged and their data is not persisted on disk.</span></span> <span data-ttu-id="04078-131">Это означает, что транзакции на этих таблицах не требуют каких-либо дисковых операций ввода-вывода, но их данные не будут восстановлены при сбое или отработке отказа сервера.</span><span class="sxs-lookup"><span data-stu-id="04078-131">This means that transactions on these tables do not require any disk IO, but the data will not be recovered if there is a server crash or failover.</span></span>  
  
## <a name="accessing-data-in-memory-optimized-tables"></a><span data-ttu-id="04078-132">Доступ к данным в оптимизированных для памяти таблицах</span><span class="sxs-lookup"><span data-stu-id="04078-132">Accessing Data in Memory-Optimized Tables</span></span>  
 <span data-ttu-id="04078-133">Доступ к данным в таблицах, оптимизированных для памяти, можно получить двумя способами:</span><span class="sxs-lookup"><span data-stu-id="04078-133">Data in memory-optimized tables is accessed in two ways:</span></span>  
  
-   <span data-ttu-id="04078-134">С помощью интерпретированного [!INCLUDE[tsql](../../../includes/tsql-md.md)] (вне компилированной в собственном коде хранимой процедуры).</span><span class="sxs-lookup"><span data-stu-id="04078-134">Through interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] (outside of a natively-compiled stored procedure).</span></span> <span data-ttu-id="04078-135">Эти инструкции [!INCLUDE[tsql](../../../includes/tsql-md.md)] могут находиться в интерпретируемых хранимых процедурах или представлять собой специализированные инструкции [!INCLUDE[tsql](../../../includes/tsql-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="04078-135">These [!INCLUDE[tsql](../../../includes/tsql-md.md)] statements may be either inside interpreted stored procedures or they may be ad-hoc [!INCLUDE[tsql](../../../includes/tsql-md.md)] statements.</span></span>  
  
-   <span data-ttu-id="04078-136">Использование хранимых процедур, скомпилированных в собственном коде.</span><span class="sxs-lookup"><span data-stu-id="04078-136">Through natively compiled stored procedures.</span></span>  
  
 <span data-ttu-id="04078-137">Доступ к оптимизированным для памяти таблицам наиболее эффективным образом можно осуществлять из скомпилированных в собственном коде хранимых процедур ([Скомпилированные в собственном коде хранимые процедуры](natively-compiled-stored-procedures.md)).</span><span class="sxs-lookup"><span data-stu-id="04078-137">Memory-optimized tables can be accessed most efficiently from natively compiled stored procedures ([Natively Compiled Stored Procedures](natively-compiled-stored-procedures.md)).</span></span> <span data-ttu-id="04078-138">К оптимизированным для памяти таблицам можно обращаться через обычный интерпретируемый [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="04078-138">Memory-optimized tables can also be accessed with (traditional) interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="04078-139">Термин «интерпретируемый [!INCLUDE[tsql](../../../includes/tsql-md.md)] » означает доступ к оптимизированным для памяти таблицам без использования скомпилированной хранимой процедуры.</span><span class="sxs-lookup"><span data-stu-id="04078-139">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] refers to accessing memory-optimized tables without a natively compiled stored procedure.</span></span> <span data-ttu-id="04078-140">Примеры интерпретируемого доступа [!INCLUDE[tsql](../../../includes/tsql-md.md)] — доступ к оптимизированной для памяти таблице из триггера DML или специального пакета [!INCLUDE[tsql](../../../includes/tsql-md.md)] , представления и функции с табличным значением.</span><span class="sxs-lookup"><span data-stu-id="04078-140">Some examples of interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access include accessing a memory-optimized table from a DML trigger, ad hoc [!INCLUDE[tsql](../../../includes/tsql-md.md)] batch, view, and table-valued function.</span></span>  
  
 <span data-ttu-id="04078-141">В следующей таблице представлены средства собственного и интерпретируемого доступа [!INCLUDE[tsql](../../../includes/tsql-md.md)] для различных объектов.</span><span class="sxs-lookup"><span data-stu-id="04078-141">The following table summarizes native and interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access for various objects.</span></span>  
  
|<span data-ttu-id="04078-142">Компонент</span><span class="sxs-lookup"><span data-stu-id="04078-142">Feature</span></span>|<span data-ttu-id="04078-143">Доступ с помощью хранимой процедуры, скомпилированной в собственном коде</span><span class="sxs-lookup"><span data-stu-id="04078-143">Access Using a Natively Compiled Stored Procedure</span></span>|<span data-ttu-id="04078-144">Интерпретируемый доступ [!INCLUDE[tsql](../../../includes/tsql-md.md)]</span><span class="sxs-lookup"><span data-stu-id="04078-144">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] Access</span></span>|<span data-ttu-id="04078-145">Доступ по CLR-адресу</span><span class="sxs-lookup"><span data-stu-id="04078-145">CLR Access</span></span>|  
|-------------|-------------------------------------------------------|-------------------------------------------|----------------|  
|<span data-ttu-id="04078-146">Таблицы, оптимизированные для памяти</span><span class="sxs-lookup"><span data-stu-id="04078-146">Memory-optimized tables</span></span>|<span data-ttu-id="04078-147">Да</span><span class="sxs-lookup"><span data-stu-id="04078-147">Yes</span></span>|<span data-ttu-id="04078-148">Да</span><span class="sxs-lookup"><span data-stu-id="04078-148">Yes</span></span>|<span data-ttu-id="04078-149">Нет <sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="04078-149">No <sup>1</sup></span></span>|  
|[<span data-ttu-id="04078-150">Основные сведения о табличных переменных, оптимизированных для памяти</span><span class="sxs-lookup"><span data-stu-id="04078-150">Memory-Optimized Table Variables</span></span>](../../database-engine/memory-optimized-table-variables.md)|<span data-ttu-id="04078-151">Да</span><span class="sxs-lookup"><span data-stu-id="04078-151">Yes</span></span>|<span data-ttu-id="04078-152">Да</span><span class="sxs-lookup"><span data-stu-id="04078-152">Yes</span></span>|<span data-ttu-id="04078-153">Нет</span><span class="sxs-lookup"><span data-stu-id="04078-153">No</span></span>|  
|[<span data-ttu-id="04078-154">Скомпилированные в собственном коде хранимые процедуры</span><span class="sxs-lookup"><span data-stu-id="04078-154">Natively Compiled Stored Procedures</span></span>](https://msdn.microsoft.com/library/dn133184.aspx)|<span data-ttu-id="04078-155">Нельзя выполнить любую хранимую процедуру из хранимой процедуры, скомпилированной в собственном коде, путем копирования инструкции EXECUTE.</span><span class="sxs-lookup"><span data-stu-id="04078-155">You cannot use the EXECUTE statement to execute any stored procedure from a natively compiled stored procedure.</span></span>|<span data-ttu-id="04078-156">Да</span><span class="sxs-lookup"><span data-stu-id="04078-156">Yes</span></span>|<span data-ttu-id="04078-157">Нет <sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="04078-157">No <sup>1</sup></span></span>|  
  
 <span data-ttu-id="04078-158"><sup>1</sup> невозможно получить доступ к оптимизированной для памяти таблице или хранимой процедуре, скомпилированной в собственном режиме, из контекстного соединения (соединение [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] выполняется при выполнении модуля CLR).</span><span class="sxs-lookup"><span data-stu-id="04078-158"><sup>1</sup> You cannot access a memory-optimized table or natively compiled stored procedure from the context connection (the connection from [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] when executing a CLR module).</span></span> <span data-ttu-id="04078-159">Однако можно создать и открыть другое соединение, из которого можно получить доступ к оптимизированным для памяти таблицам и хранимым процедурам, скомпилированным в собственном коде.</span><span class="sxs-lookup"><span data-stu-id="04078-159">You can, however, create and open another connection from which you can access memory-optimized tables and natively compiled stored procedures.</span></span> <span data-ttu-id="04078-160">Дополнительные сведения см. в разделе [регулярные и контекстные соединения](../clr-integration/data-access/context-connections-vs-regular-connections.md).</span><span class="sxs-lookup"><span data-stu-id="04078-160">For more information, see [Regular vs. Context Connections](../clr-integration/data-access/context-connections-vs-regular-connections.md).</span></span>  
  
## <a name="performance-and-scalability"></a><span data-ttu-id="04078-161">Производительность и масштабируемость</span><span class="sxs-lookup"><span data-stu-id="04078-161">Performance and Scalability</span></span>  
 <span data-ttu-id="04078-162">Следующие факторы влияют на повышение производительности при использовании OLTP в памяти:</span><span class="sxs-lookup"><span data-stu-id="04078-162">The following factors will affect the performance gains that can be achieved with In-Memory OLTP:</span></span>  
  
 <span data-ttu-id="04078-163">Коммуникация</span><span class="sxs-lookup"><span data-stu-id="04078-163">Communication</span></span>  
 <span data-ttu-id="04078-164">Выигрыш в производительности приложения с множеством вызовов коротких хранимых процедур может быть меньше, чем у приложения с меньшим числом вызовов и более функциональными хранимыми процедурами.</span><span class="sxs-lookup"><span data-stu-id="04078-164">An application with many calls to short stored procedures may see a smaller performance gain compared to an application with fewer calls and more functionality implemented in each stored procedure.</span></span>  
  
 [!INCLUDE[tsql](../../../includes/tsql-md.md)] <span data-ttu-id="04078-165">Выполнение</span><span class="sxs-lookup"><span data-stu-id="04078-165">Execution</span></span>  
 <span data-ttu-id="04078-166">OLTP в памяти достигает наивысшей производительности при использовании хранимых процедур, скомпилированных в собственном коде, вместо интерпретированных хранимых процедур или выполнения запроса.</span><span class="sxs-lookup"><span data-stu-id="04078-166">In-Memory OLTP achieves the best performance when using natively compiled stored procedures rather than interpreted stored procedures or query execution.</span></span> <span data-ttu-id="04078-167">Хранимые процедуры, выполняющие другие хранимые процедуры, не могут быть скомпилированы в собственном коде, но из таких хранимых процедур иногда бывает нужен доступ к оптимизированным для памяти таблицам.</span><span class="sxs-lookup"><span data-stu-id="04078-167">Stored procedures that execute other stored procedures cannot be natively compiled, but there can be a benefit to accessing memory-optimized tables from such stored procedures.</span></span>  
  
 <span data-ttu-id="04078-168">Просмотр диапазона или поиск точек</span><span class="sxs-lookup"><span data-stu-id="04078-168">Range Scan vs Point Lookup</span></span>  
 <span data-ttu-id="04078-169">Некластеризованные, оптимизированные для памяти индексы поддерживают просмотр диапазона и упорядоченные просмотры.</span><span class="sxs-lookup"><span data-stu-id="04078-169">Memory-optimized nonclustered indexes support range scans and ordered scans.</span></span> <span data-ttu-id="04078-170">С уточняющими запросами оптимизированные для памяти хэш-индексы более производительны, чем оптимизированные для памяти некластеризованные индексы.</span><span class="sxs-lookup"><span data-stu-id="04078-170">For point lookups, memory-optimized hash indexes have better performance than memory-optimized nonclustered indexes.</span></span> <span data-ttu-id="04078-171">Оптимизированные для памяти некластеризованные индексы имеют более высокую производительность, чем дисковые индексы.</span><span class="sxs-lookup"><span data-stu-id="04078-171">Memory-optimized nonclustered indexes have better performance than disk-based indexes.</span></span>  
  
 <span data-ttu-id="04078-172">Операции с индексами не регистрируются и находятся только в памяти.</span><span class="sxs-lookup"><span data-stu-id="04078-172">Index operations are not logged and they exist only in memory.</span></span>  
  
 <span data-ttu-id="04078-173">Параллелизм</span><span class="sxs-lookup"><span data-stu-id="04078-173">Concurrency</span></span>  
 <span data-ttu-id="04078-174">Производительность приложений, которая зависит от параллелизма компонента уровня СУБД, например от конфликтов кратковременной блокировки, значительно повышается при переходе на OLTP в памяти.</span><span class="sxs-lookup"><span data-stu-id="04078-174">Applications whose performance is affected by engine-level concurrency, such as latch contention or blocking, improves significantly when the application moves to In-Memory OLTP.</span></span>  
  
 <span data-ttu-id="04078-175">В следующей таблице перечислены проблемы с производительностью и масштабируемостью, которые часто встречаются в реляционных базах данных, и описывается, как OLTP в памяти может улучшить производительность.</span><span class="sxs-lookup"><span data-stu-id="04078-175">The following table lists the performance and scalability issues that are commonly found in relational databases and how In-Memory OLTP can improve performance.</span></span>  
  
|<span data-ttu-id="04078-176">Проблема</span><span class="sxs-lookup"><span data-stu-id="04078-176">Issue</span></span>|<span data-ttu-id="04078-177">Влияние OLTP в памяти</span><span class="sxs-lookup"><span data-stu-id="04078-177">In-Memory OLTP Impact</span></span>|  
|-----------|----------------------------|  
|<span data-ttu-id="04078-178">Производительность</span><span class="sxs-lookup"><span data-stu-id="04078-178">Performance</span></span><br /><br /> <span data-ttu-id="04078-179">Высокая интенсивность использования ресурсов (ЦП, ввода-вывода, сети или памяти).</span><span class="sxs-lookup"><span data-stu-id="04078-179">High resource (CPU, I/O, network or memory) usage.</span></span>|<span data-ttu-id="04078-180">ЦП</span><span class="sxs-lookup"><span data-stu-id="04078-180">CPU</span></span><br /> <span data-ttu-id="04078-181">Скомпилированные в собственном коде хранимые процедуры могут значительно снизить уровень загрузки ЦП, так как им требуется значительно меньше инструкций на выполнение команды [!INCLUDE[tsql](../../../includes/tsql-md.md)] , чем интерпретированным хранимым процедурам.</span><span class="sxs-lookup"><span data-stu-id="04078-181">Natively compiled stored procedures can lower CPU usage significantly because they require significantly fewer instructions to execute a [!INCLUDE[tsql](../../../includes/tsql-md.md)] statement compared to interpreted stored procedures.</span></span><br /><br /> <span data-ttu-id="04078-182">In-Memory OLTP может снизить затраты на оборудование для масштабированных рабочих нагрузок, поскольку один сервер потенциально может обеспечить пропускную способность 5–10 серверов.</span><span class="sxs-lookup"><span data-stu-id="04078-182">In-Memory OLTP can help reduce the hardware investment in scaled-out workloads because one server can potentially deliver the throughput of five to ten servers.</span></span><br /><br /> <span data-ttu-id="04078-183">Ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="04078-183">I/O</span></span><br /> <span data-ttu-id="04078-184">OLTP в памяти может уменьшить влияние узких мест в операциях ввода-вывода при обработке страниц данных или индекса.</span><span class="sxs-lookup"><span data-stu-id="04078-184">If you encounter an I/O bottleneck from processing to data or index pages, In-Memory OLTP may reduce the bottleneck.</span></span> <span data-ttu-id="04078-185">Кроме того, назначение контрольных точек для объектов OLTP в памяти происходит непрерывно и не приводит к неожиданному увеличению количества операций ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="04078-185">Additionally, the checkpointing of In-Memory OLTP objects is continuous and does not lead to sudden increases in I/O operations.</span></span> <span data-ttu-id="04078-186">Однако если рабочее множество важных для производительности таблиц не помещается в памяти, то OLTP в памяти не улучшит производительность, поскольку данные должны быть резидентными.</span><span class="sxs-lookup"><span data-stu-id="04078-186">However, if the working set of the performance critical tables does not fit in memory, In-Memory OLTP will not improve performance because it requires data to be memory resident.</span></span> <span data-ttu-id="04078-187">Если возникает задержка в операциях ввода-вывода при ведении журнала, то OLTP в памяти может снизить эту задержку, так как в журнал записывается меньше данных.</span><span class="sxs-lookup"><span data-stu-id="04078-187">If you encounter an I/O bottleneck in logging, In-Memory OLTP can reduce the bottleneck because it does less logging.</span></span> <span data-ttu-id="04078-188">Если одна или несколько таблиц, оптимизированных для памяти, настроены как устойчивые, журналирование данных можно исключить.</span><span class="sxs-lookup"><span data-stu-id="04078-188">If one or more memory-optimized tables are configured as non-durable tables, you can eliminate logging for data.</span></span><br /><br /> <span data-ttu-id="04078-189">Память</span><span class="sxs-lookup"><span data-stu-id="04078-189">Memory</span></span><br /> <span data-ttu-id="04078-190">OLTP в памяти не повышает производительность.</span><span class="sxs-lookup"><span data-stu-id="04078-190">In-Memory OLTP does not offer any performance benefit.</span></span> <span data-ttu-id="04078-191">OLTP в памяти может вызывать дополнительную нагрузку на память, так как объекты должны быть резидентными.</span><span class="sxs-lookup"><span data-stu-id="04078-191">In-Memory OLTP can put extra pressure on memory as the objects need to be memory resident.</span></span><br /><br /> <span data-ttu-id="04078-192">Сеть</span><span class="sxs-lookup"><span data-stu-id="04078-192">Network</span></span><br /> <span data-ttu-id="04078-193">OLTP в памяти не повышает производительность.</span><span class="sxs-lookup"><span data-stu-id="04078-193">In-Memory OLTP does not offer any performance benefit.</span></span> <span data-ttu-id="04078-194">Данные нужно передавать с уровня данных на уровень приложения.</span><span class="sxs-lookup"><span data-stu-id="04078-194">The data needs to be communicated from data tier to application tier.</span></span>|  
|<span data-ttu-id="04078-195">Масштабируемость</span><span class="sxs-lookup"><span data-stu-id="04078-195">Scalability</span></span><br /><br /> <span data-ttu-id="04078-196">Большинство проблем с масштабированием в приложениях [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] вызываются проблемами параллелизма, такими как конфликт в блокировках, кратковременных блокировках и спин-блокировках.</span><span class="sxs-lookup"><span data-stu-id="04078-196">Most scaling issues in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] applications are caused by concurrency issues such as contention in locks, latches, and spinlocks.</span></span>|<span data-ttu-id="04078-197">Конфликты кратковременных блокировок</span><span class="sxs-lookup"><span data-stu-id="04078-197">Latch Contention</span></span><br /> <span data-ttu-id="04078-198">Типичный сценарий — конфликт на последней странице индекса при параллельной вставке строк в порядке значений ключей.</span><span class="sxs-lookup"><span data-stu-id="04078-198">A typical scenario is contention on the last page of an index when inserting rows concurrently in key order.</span></span> <span data-ttu-id="04078-199">OLTP в памяти не использует кратковременные блокировки при доступе к данным, поэтому проблемы масштабируемости, связанные с конфликтом за кратковременные блокировки, полностью устраняются.</span><span class="sxs-lookup"><span data-stu-id="04078-199">Because In-Memory OLTP does not take latches when accessing data, the scalability issues related to latch contentions are fully removed.</span></span><br /><br /> <span data-ttu-id="04078-200">Конфликт спин-блокировок</span><span class="sxs-lookup"><span data-stu-id="04078-200">Spinlock Contention</span></span><br /> <span data-ttu-id="04078-201">OLTP в памяти не использует кратковременные блокировки при доступе к данным, поэтому проблемы масштабируемости, связанные с состязанием за спин-блокировки, полностью устраняются.</span><span class="sxs-lookup"><span data-stu-id="04078-201">Because In-Memory OLTP does not take latches when accessing data, the scalability issues related to spinlock contentions are fully removed.</span></span><br /><br /> <span data-ttu-id="04078-202">Конфликты, связанные с блокировкой</span><span class="sxs-lookup"><span data-stu-id="04078-202">Locking Related Contention</span></span><br /> <span data-ttu-id="04078-203">OLTP в памяти устраняет критические препятствия между операциями чтения и записи в приложении базы данных, поскольку используется новая форма управления оптимистической конкуренцией для реализации всех уровней изоляции транзакций.</span><span class="sxs-lookup"><span data-stu-id="04078-203">If your database application encounters blocking issues between read and write operations, In-Memory OLTP removes the blocking issues because it uses a new form of optimistic concurrency control to implement all transaction isolation levels.</span></span> <span data-ttu-id="04078-204">OLTP в памяти не использует базу данных TempDB для хранения версий строк.</span><span class="sxs-lookup"><span data-stu-id="04078-204">In-Memory OLTP does not use TempDB to store row versions.</span></span><br /><br /> <span data-ttu-id="04078-205">Если ошибка масштабирования вызвана конфликтом между двумя операциями записи, например двумя параллельными транзакциями, которые пытаются обновить одну и ту же строку, OLTP в памяти позволяет завершить одну транзакцию и отклоняет другую.</span><span class="sxs-lookup"><span data-stu-id="04078-205">If the scaling issue is caused by conflict between two write operations, such as two concurrent transactions trying to update the same row, In-Memory OLTP lets one transaction succeed and fails the other transaction.</span></span> <span data-ttu-id="04078-206">Поврежденную транзакцию необходимо представить повторно явно или неявно.</span><span class="sxs-lookup"><span data-stu-id="04078-206">The failed transaction must be re-submitted either explicitly or implicitly, re-trying the transaction.</span></span> <span data-ttu-id="04078-207">В любом случае необходимо внести изменения в приложение.</span><span class="sxs-lookup"><span data-stu-id="04078-207">In either case, you need to make changes to the application.</span></span><br /><br /> <span data-ttu-id="04078-208">Если в приложении часто возникают конфликты между двумя операциями записи, значимость оптимистической блокировки уменьшается.</span><span class="sxs-lookup"><span data-stu-id="04078-208">If your application experiences frequent conflicts between two write operations, the value of optimistic locking is diminished.</span></span> <span data-ttu-id="04078-209">Приложение не подходит для работы с OLTP в памяти.</span><span class="sxs-lookup"><span data-stu-id="04078-209">The application is not suitable for In-Memory OLTP.</span></span> <span data-ttu-id="04078-210">В большинстве OLTP-приложений отсутствуют конфликты записи, если конфликт не вызывается укрупнением блокировки.</span><span class="sxs-lookup"><span data-stu-id="04078-210">Most OLTP applications don't have a write conflicts unless the conflict is induced by lock escalation.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="04078-211">См. также:</span><span class="sxs-lookup"><span data-stu-id="04078-211">See Also</span></span>  
 [<span data-ttu-id="04078-212">Выполняющаяся в памяти OLTP (оптимизация в памяти)</span><span class="sxs-lookup"><span data-stu-id="04078-212">In-Memory OLTP &#40;In-Memory Optimization&#41;</span></span>](in-memory-oltp-in-memory-optimization.md)  
  
  

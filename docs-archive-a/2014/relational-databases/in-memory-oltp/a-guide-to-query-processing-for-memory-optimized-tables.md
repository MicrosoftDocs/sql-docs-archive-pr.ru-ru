---
title: Руководство по обработке запросов к таблицам, оптимизированных для памяти | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 065296fe-6711-4837-965e-252ef6c13a0f
author: rothja
ms.author: jroth
ms.openlocfilehash: 93489e5dea295964826005e081bcffe889cb7586
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87667093"
---
# <a name="a-guide-to-query-processing-for-memory-optimized-tables"></a><span data-ttu-id="c9265-102">Руководство по обработке запросов для таблиц, оптимизированных для памяти</span><span class="sxs-lookup"><span data-stu-id="c9265-102">A Guide to Query Processing for Memory-Optimized Tables</span></span>
  <span data-ttu-id="c9265-103">В [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]In-Memory OLTP вводятся оптимизированные для памяти таблицы и скомпилированные в собственном коде хранимые процедуры.</span><span class="sxs-lookup"><span data-stu-id="c9265-103">In-Memory OLTP introduces memory-optimized tables and natively compiled stored procedures in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="c9265-104">В данной статье приводится обзор обработки запросов для таблиц, оптимизированных для памяти, и хранимых процедур, скомпилированных в собственном коде.</span><span class="sxs-lookup"><span data-stu-id="c9265-104">This article gives an overview of query processing for both memory-optimized tables and natively compiled stored procedures.</span></span>  
  
 <span data-ttu-id="c9265-105">Документ поясняет процесс компиляции и выполнения запросов к таблицам, оптимизированным для памяти, включая:</span><span class="sxs-lookup"><span data-stu-id="c9265-105">The document explains how queries on memory-optimized tables are compiled and executed, including:</span></span>  
  
-   <span data-ttu-id="c9265-106">канал обработки запросов в [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] для дисковых таблиц;</span><span class="sxs-lookup"><span data-stu-id="c9265-106">The query processing pipeline in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] for disk-based tables.</span></span>  
  
-   <span data-ttu-id="c9265-107">оптимизацию запросов, роль статистических данных в таблицах, оптимизированных для памяти, а также рекомендации по решению проблем, связанных с неоптимальными планами запросов;</span><span class="sxs-lookup"><span data-stu-id="c9265-107">Query optimization; the role of statistics on memory-optimized tables as well as guidelines for troubleshooting bad query plans.</span></span>  
  
-   <span data-ttu-id="c9265-108">использование интерпретируемого кода [!INCLUDE[tsql](../../../includes/tsql-md.md)] для доступа к таблицам, оптимизированным для памяти.</span><span class="sxs-lookup"><span data-stu-id="c9265-108">The use of interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] to access memory-optimized tables.</span></span>  
  
-   <span data-ttu-id="c9265-109">аспекты оптимизации запросов для доступа к таблицам, оптимизированным для памяти;</span><span class="sxs-lookup"><span data-stu-id="c9265-109">Considerations about query optimization for memory-optimized table access.</span></span>  
  
-   <span data-ttu-id="c9265-110">компиляция и обработка хранимых процедур, скомпилированных в собственном коде;</span><span class="sxs-lookup"><span data-stu-id="c9265-110">Natively compiled stored procedure compilation and processing.</span></span>  
  
-   <span data-ttu-id="c9265-111">статистические данные, которые используются для оценки затрат оптимизатора;</span><span class="sxs-lookup"><span data-stu-id="c9265-111">Statistics that are used for cost estimation by the optimizer.</span></span>  
  
-   <span data-ttu-id="c9265-112">способы исправления неоптимальных планов запросов;</span><span class="sxs-lookup"><span data-stu-id="c9265-112">Ways to fix bad query plans.</span></span>  
  
## <a name="example-query"></a><span data-ttu-id="c9265-113">Пример запроса</span><span class="sxs-lookup"><span data-stu-id="c9265-113">Example Query</span></span>  
 <span data-ttu-id="c9265-114">Следующий пример иллюстрирует концепции обработки запросов, рассматриваемые в данной статье.</span><span class="sxs-lookup"><span data-stu-id="c9265-114">The following example will be used to illustrate the query processing concepts discussed in this article.</span></span>  
  
 <span data-ttu-id="c9265-115">Мы рассмотрим две таблицы, Customer и Order.</span><span class="sxs-lookup"><span data-stu-id="c9265-115">We consider two tables, Customer and Order.</span></span> <span data-ttu-id="c9265-116">Следующий скрипт [!INCLUDE[tsql](../../../includes/tsql-md.md)] содержит определения для этих двух таблиц и связанных индексов (в их традиционной форме для таблиц на диске):</span><span class="sxs-lookup"><span data-stu-id="c9265-116">The following [!INCLUDE[tsql](../../../includes/tsql-md.md)] script contains the definitions for these two tables and associated indexes, in their (traditional) disk-based form:</span></span>  
  
```sql  
CREATE TABLE dbo.[Customer] (  
  CustomerID nchar (5) NOT NULL PRIMARY KEY,  
  ContactName nvarchar (30) NOT NULL   
)  
GO  
  
CREATE TABLE dbo.[Order] (  
  OrderID int NOT NULL PRIMARY KEY,  
  CustomerID nchar (5) NOT NULL,  
  OrderDate date NOT NULL  
)  
GO  
CREATE INDEX IX_CustomerID ON dbo.[Order](CustomerID)  
GO  
CREATE INDEX IX_OrderDate ON dbo.[Order](OrderDate)  
GO  
```  
  
 <span data-ttu-id="c9265-117">Для конструирования планов запросов, показанных в данной статье, две таблицы были заполнены примерами данных из учебной базы данных Northwind, которую можно загрузить по следующий ссылке: [Образцы баз данных Northwind и pubs для SQL Server 2000](https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/northwind-pubs).</span><span class="sxs-lookup"><span data-stu-id="c9265-117">For constructing the query plans shown in this article, the two tables were populated with sample data from the Northwind sample database, which you can download from [Northwind and pubs Sample Databases for SQL Server 2000](https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/northwind-pubs).</span></span>  
  
 <span data-ttu-id="c9265-118">Рассмотрим следующий запрос, который выполняет соединение таблиц Customer и Order и возвращает идентификатор заказа и связанную с ним информацию о клиенте:</span><span class="sxs-lookup"><span data-stu-id="c9265-118">Consider the following query, which joins the tables Customer and Order and returns the ID of the order and the associated customer information:</span></span>  
  
```sql  
SELECT o.OrderID, c.* FROM dbo.[Customer] c INNER JOIN dbo.[Order] o ON c.CustomerID = o.CustomerID  
```  
  
 <span data-ttu-id="c9265-119">Предполагаемый план выполнения в соответствии с отображением в [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)] следующий:</span><span class="sxs-lookup"><span data-stu-id="c9265-119">The estimated execution plan as displayed by [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)] is as follows</span></span>  
  
 <span data-ttu-id="c9265-120">![План запроса для соединения дисковых таблиц.](../../database-engine/media/hekaton-query-plan-1.gif "План запроса для соединения дисковых таблиц.")</span><span class="sxs-lookup"><span data-stu-id="c9265-120">![Query plan for join of disk-based tables.](../../database-engine/media/hekaton-query-plan-1.gif "Query plan for join of disk-based tables.")</span></span>  
<span data-ttu-id="c9265-121">План запроса для соединения дисковых таблиц.</span><span class="sxs-lookup"><span data-stu-id="c9265-121">Query plan for join of disk-based tables.</span></span>  
  
 <span data-ttu-id="c9265-122">О данном плане запроса:</span><span class="sxs-lookup"><span data-stu-id="c9265-122">About this query plan:</span></span>  
  
-   <span data-ttu-id="c9265-123">строки из таблицы Customer получены из кластеризованного индекса, который представляет собой основную структуру данных и содержит все данные таблицы;</span><span class="sxs-lookup"><span data-stu-id="c9265-123">The rows from the Customer table are retrieved from the clustered index, which is the primary data structure and has the full table data.</span></span>  
  
-   <span data-ttu-id="c9265-124">данные из таблицы Order получены с помощью некластеризованного индекса в столбце CustomerID.</span><span class="sxs-lookup"><span data-stu-id="c9265-124">Data from the Order table is retrieved using the nonclustered index on the CustomerID column.</span></span> <span data-ttu-id="c9265-125">Этот индекс содержит столбец CustomerID, который используется для соединения, и столбец первичного ключа OrderID, который возвращается пользователю.</span><span class="sxs-lookup"><span data-stu-id="c9265-125">This index contains both the CustomerID column, which is used for the join, and the primary key column OrderID, which is returned to the user.</span></span> <span data-ttu-id="c9265-126">Для возвращения дополнительных столбцов из таблицы Order потребуется поиск по кластеризованному индексу для таблицы Order.</span><span class="sxs-lookup"><span data-stu-id="c9265-126">Returning additional columns from the Order table would require lookups in the clustered index for the Order table.</span></span>  
  
-   <span data-ttu-id="c9265-127">Логический оператор `Inner Join` реализован в форме физического оператора `Merge Join`.</span><span class="sxs-lookup"><span data-stu-id="c9265-127">The logical operator `Inner Join` is implemented by the physical operator `Merge Join`.</span></span> <span data-ttu-id="c9265-128">Остальные физические типы соединений — это `Nested Loops` и `Hash Join`.</span><span class="sxs-lookup"><span data-stu-id="c9265-128">The other physical join types are `Nested Loops` and `Hash Join`.</span></span> <span data-ttu-id="c9265-129">В операторе `Merge Join` используется то обстоятельство, что оба индекса отсортированы по столбцу соединения CustomerID.</span><span class="sxs-lookup"><span data-stu-id="c9265-129">The `Merge Join` operator takes advantage of the fact that both indexes are sorted on the join column CustomerID.</span></span>  
  
 <span data-ttu-id="c9265-130">Рассмотрим немного другую версию этого запроса, которая возвращает все строки из таблицы Order, а не только OrderID.</span><span class="sxs-lookup"><span data-stu-id="c9265-130">Consider a slight variation on this query, which returns all rows from the Order table, not only OrderID:</span></span>  
  
```sql  
SELECT o.*, c.* FROM dbo.[Customer] c INNER JOIN dbo.[Order] o ON c.CustomerID = o.CustomerID  
```  
  
 <span data-ttu-id="c9265-131">Предполагаемый план выполнения для этого запроса:</span><span class="sxs-lookup"><span data-stu-id="c9265-131">The estimated plan for this query is:</span></span>  
  
 <span data-ttu-id="c9265-132">![план запроса для хэш-соединений дисковых таблиц.](../../database-engine/media/hekaton-query-plan-2.gif "план запроса для хэш-соединений дисковых таблиц.")</span><span class="sxs-lookup"><span data-stu-id="c9265-132">![Query plan for a hash join of disk-based tables.](../../database-engine/media/hekaton-query-plan-2.gif "Query plan for a hash join of disk-based tables.")</span></span>  
<span data-ttu-id="c9265-133">план запроса для хэш-соединений дисковых таблиц.</span><span class="sxs-lookup"><span data-stu-id="c9265-133">Query plan for a hash join of disk-based tables.</span></span>  
  
 <span data-ttu-id="c9265-134">В этом запросе строки из таблицы заказов получаются с помощью кластеризованного индекса.</span><span class="sxs-lookup"><span data-stu-id="c9265-134">In this query, rows from the Order table are retrieved using the clustered index.</span></span> <span data-ttu-id="c9265-135">Физический оператор `Hash Match` теперь используется для `Inner Join`.</span><span class="sxs-lookup"><span data-stu-id="c9265-135">The `Hash Match` physical operator is now used for the `Inner Join`.</span></span> <span data-ttu-id="c9265-136">Кластеризованный индекс в таблице Order не отсортирован по столбцу CustomerID, поэтому для `Merge Join` потребуется оператор сортировки, который повлияет на производительность запроса.</span><span class="sxs-lookup"><span data-stu-id="c9265-136">The clustered index on Order is not sorted on CustomerID, and so a `Merge Join` would require a sort operator, which would affect performance.</span></span> <span data-ttu-id="c9265-137">Обратите внимание на относительную стоимость оператора `Hash Match` (75%) по сравнению с затратами оператора `Merge Join` в предыдущем примере (46%).</span><span class="sxs-lookup"><span data-stu-id="c9265-137">Note the relative cost of the `Hash Match` operator (75%) compared with the cost of the `Merge Join` operator in the previous example (46%).</span></span> <span data-ttu-id="c9265-138">Оптимизатором также рассматривался оператор `Hash Match` из предыдущего примера, но оказалось, что оператор `Merge Join` обеспечивает лучшую производительность.</span><span class="sxs-lookup"><span data-stu-id="c9265-138">The optimizer would have considered the `Hash Match` operator also in the previous example, but concluded that the `Merge Join` operator gave better performance.</span></span>  
  
## <a name="ssnoversion-query-processing-for-disk-based-tables"></a>[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="c9265-139">Обработка запросов для дисковых таблиц</span><span class="sxs-lookup"><span data-stu-id="c9265-139">Query Processing for Disk-Based Tables</span></span>  
 <span data-ttu-id="c9265-140">На следующей диаграмме показан поток обработки запросов в [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] для нерегламентированных запросов:</span><span class="sxs-lookup"><span data-stu-id="c9265-140">The following diagram outlines the query processing flow in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] for ad hoc queries:</span></span>  
  
 <span data-ttu-id="c9265-141">![Канал обработки запросов в SQL Server.](../../database-engine/media/hekaton-query-plan-3.gif "Канал обработки запросов в SQL Server.")</span><span class="sxs-lookup"><span data-stu-id="c9265-141">![SQL Server query processing pipeline.](../../database-engine/media/hekaton-query-plan-3.gif "SQL Server query processing pipeline.")</span></span>  
<span data-ttu-id="c9265-142">Канал обработки запросов в SQL Server.</span><span class="sxs-lookup"><span data-stu-id="c9265-142">SQL Server query processing pipeline.</span></span>  
  
 <span data-ttu-id="c9265-143">В этом сценарии:</span><span class="sxs-lookup"><span data-stu-id="c9265-143">In this scenario:</span></span>  
  
1.  <span data-ttu-id="c9265-144">Пользователь выполняет запрос.</span><span class="sxs-lookup"><span data-stu-id="c9265-144">The user issues a query.</span></span>  
  
2.  <span data-ttu-id="c9265-145">Средство синтаксического анализа и алгебризатор с помощью логических операторов строят дерево запросов в соответствии с тексом [!INCLUDE[tsql](../../../includes/tsql-md.md)] , переданным пользователем.</span><span class="sxs-lookup"><span data-stu-id="c9265-145">The parser and algebrizer construct a query tree with logical operators based on the [!INCLUDE[tsql](../../../includes/tsql-md.md)] text submitted by the user.</span></span>  
  
3.  <span data-ttu-id="c9265-146">Оптимизатор создает оптимизированный план запроса, содержащий физические операторы (например, соединения вложенных циклов).</span><span class="sxs-lookup"><span data-stu-id="c9265-146">The optimizer creates an optimized query plan containing physical operators (for example, nested-loops join).</span></span> <span data-ttu-id="c9265-147">После оптимизации план может храниться в кэше планов.</span><span class="sxs-lookup"><span data-stu-id="c9265-147">After optimization, the plan may be stored in the plan cache.</span></span> <span data-ttu-id="c9265-148">Это действие пропускается, если кэш планов уже содержит план для этого запроса.</span><span class="sxs-lookup"><span data-stu-id="c9265-148">This step is bypassed if the plan cache already contains a plan for this query.</span></span>  
  
4.  <span data-ttu-id="c9265-149">Подсистема выполнения запросов обрабатывает интерпретацию плана запроса.</span><span class="sxs-lookup"><span data-stu-id="c9265-149">The query execution engine processes an interpretation of the query plan.</span></span>  
  
5.  <span data-ttu-id="c9265-150">Для каждого оператора поиска в индексе, просмотра индекса и просмотра таблицы подсистема выполнения запрашивает строки из соответствующего индекса и табличных структур у методов доступа.</span><span class="sxs-lookup"><span data-stu-id="c9265-150">For each index seek, index scan, and table scan operator, the execution engine requests rows from the respective index and table structures from Access Methods.</span></span>  
  
6.  <span data-ttu-id="c9265-151">Методы доступа получают строки из индекса и страниц данных в буферном пуле, и по мере необходимости загружают страницы из диска в буферный пул.</span><span class="sxs-lookup"><span data-stu-id="c9265-151">Access Methods retrieves the rows from the index and data pages in the buffer pool and loads pages from disk into the buffer pool as needed.</span></span>  
  
 <span data-ttu-id="c9265-152">В первом примере запроса подсистема выполнения запрашивает у методов доступа строки в кластеризованном индексе таблицы Customer и в некластеризованном индексе таблицы Order.</span><span class="sxs-lookup"><span data-stu-id="c9265-152">For the first example query, the execution engine requests rows in the clustered index on Customer and the nonclustered index on Order from Access Methods.</span></span> <span data-ttu-id="c9265-153">Чтобы получить запрашиваемые строки, методы доступа обходят индексные структуры сбалансированного дерева.</span><span class="sxs-lookup"><span data-stu-id="c9265-153">Access Methods traverses the B-tree index structures to retrieve the requested rows.</span></span> <span data-ttu-id="c9265-154">В этом случае извлекаются все строки после полного просмотра индексов в соответствии с планом.</span><span class="sxs-lookup"><span data-stu-id="c9265-154">In this case all rows are retrieved as the plan calls for full index scans.</span></span>  
  
## <a name="interpreted-tsql-access-to-memory-optimized-tables"></a><span data-ttu-id="c9265-155">Доступ к оптимизированным для памяти таблицам с помощью интерпретируемого кода [!INCLUDE[tsql](../../../includes/tsql-md.md)]</span><span class="sxs-lookup"><span data-stu-id="c9265-155">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] Access to Memory-Optimized Tables</span></span>  
 [!INCLUDE[tsql](../../../includes/tsql-md.md)] <span data-ttu-id="c9265-156">также называются интерпретируемым кодом [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="c9265-156">ad hoc batches and stored procedures are also referred to as interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="c9265-157">Термин «интерпретируемый» означает, что план запроса интерпретируется подсистемой выполнения запросов для каждого оператора в плане запроса.</span><span class="sxs-lookup"><span data-stu-id="c9265-157">Interpreted refers to the fact that the query plan is interpreted by the query execution engine for each operator in the query plan.</span></span> <span data-ttu-id="c9265-158">Подсистема выполнения считывает оператор и его параметры и выполняет операцию.</span><span class="sxs-lookup"><span data-stu-id="c9265-158">The execution engine reads the operator and its parameters and performs the operation.</span></span>  
  
 <span data-ttu-id="c9265-159">Интерпретируемый код [!INCLUDE[tsql](../../../includes/tsql-md.md)] можно использовать для доступа к таблицам, оптимизированных для памяти, и к дисковым таблицам.</span><span class="sxs-lookup"><span data-stu-id="c9265-159">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] can be used to access both memory-optimized and disk-based tables.</span></span> <span data-ttu-id="c9265-160">На следующей диаграмме показана обработка запросов для доступа с помощью интерпретируемого кода [!INCLUDE[tsql](../../../includes/tsql-md.md)] к таблицам, оптимизированным для памяти.</span><span class="sxs-lookup"><span data-stu-id="c9265-160">The following figure illustrates query processing for interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access to memory-optimized tables:</span></span>  
  
 <span data-ttu-id="c9265-161">![Канал обработки запросов для интерпретируемых инструкций tsql.](../../database-engine/media/hekaton-query-plan-4.gif "Канал обработки запросов для интерпретируемых инструкций tsql.")</span><span class="sxs-lookup"><span data-stu-id="c9265-161">![Query processing pipeline for interpreted tsql.](../../database-engine/media/hekaton-query-plan-4.gif "Query processing pipeline for interpreted tsql.")</span></span>  
<span data-ttu-id="c9265-162">Конвейер обработки запросов для доступа к оптимизированным для памяти таблицам с помощью интерпретируемого кода Transact-SQL.</span><span class="sxs-lookup"><span data-stu-id="c9265-162">Query processing pipeline for interpreted Transact-SQL access to memory-optimized tables.</span></span>  
  
 <span data-ttu-id="c9265-163">Как показано на рисунке, конвейер обработки запросов в основном остается неизменным:</span><span class="sxs-lookup"><span data-stu-id="c9265-163">As illustrated by the figure, the query processing pipeline remains mostly unchanged:</span></span>  
  
-   <span data-ttu-id="c9265-164">средство синтаксического анализа и алгебризатор строят дерево запроса;</span><span class="sxs-lookup"><span data-stu-id="c9265-164">The parser and algebrizer construct the query tree.</span></span>  
  
-   <span data-ttu-id="c9265-165">оптимизатор запросов создает план выполнения;</span><span class="sxs-lookup"><span data-stu-id="c9265-165">The optimizer creates the execution plan.</span></span>  
  
-   <span data-ttu-id="c9265-166">подсистема выполнения запроса интерпретирует план выполнения;</span><span class="sxs-lookup"><span data-stu-id="c9265-166">The query execution engine interprets the execution plan.</span></span>  
  
 <span data-ttu-id="c9265-167">Основное отличие от традиционного конвейера обработки запросов (рис. 2) заключается в том, что строки для оптимизированной для памяти таблицы получаются из буферного пула при помощи методов доступа.</span><span class="sxs-lookup"><span data-stu-id="c9265-167">The main difference with the traditional query processing pipeline (figure 2) is that rows for memory-optimized tables are not retrieved from the buffer pool using Access Methods.</span></span> <span data-ttu-id="c9265-168">Вместо этого строки извлекаются из структур данных в памяти с помощью подсистемы In-Memory OLTP.</span><span class="sxs-lookup"><span data-stu-id="c9265-168">Instead, rows are retrieved from the in-memory data structures through the In-Memory OLTP engine.</span></span> <span data-ttu-id="c9265-169">Из-за различий в структурах данных оптимизатор в некоторых случаях выбирает разные планы, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="c9265-169">Differences in data structures cause the optimizer to pick different plans in some cases, as illustrated by the following example.</span></span>  
  
 <span data-ttu-id="c9265-170">Следующий скрипт [!INCLUDE[tsql](../../../includes/tsql-md.md)] содержит оптимизированные для памяти версии таблиц Order и Customer, использующих хэш-индексы:</span><span class="sxs-lookup"><span data-stu-id="c9265-170">The following [!INCLUDE[tsql](../../../includes/tsql-md.md)] script contains memory-optimized versions of the Order and Customer tables, using hash indexes:</span></span>  
  
```sql  
CREATE TABLE dbo.[Customer] (  
  CustomerID nchar (5) NOT NULL PRIMARY KEY NONCLUSTERED,  
  ContactName nvarchar (30) NOT NULL   
) WITH (MEMORY_OPTIMIZED=ON)  
GO  
  
CREATE TABLE dbo.[Order] (  
  OrderID int NOT NULL PRIMARY KEY NONCLUSTERED,  
  CustomerID nchar (5) NOT NULL INDEX IX_CustomerID HASH(CustomerID) WITH (BUCKET_COUNT=100000),  
  OrderDate date NOT NULL INDEX IX_OrderDate HASH(OrderDate) WITH (BUCKET_COUNT=100000)  
) WITH (MEMORY_OPTIMIZED=ON)  
GO  
```  
  
 <span data-ttu-id="c9265-171">Тот же запрос, выполненный к таблицам, оптимизированным для памяти:</span><span class="sxs-lookup"><span data-stu-id="c9265-171">Consider the same query executed on memory-optimized tables:</span></span>  
  
```sql  
SELECT o.OrderID, c.* FROM dbo.[Customer] c INNER JOIN dbo.[Order] o ON c.CustomerID = o.CustomerID  
```  
  
 <span data-ttu-id="c9265-172">Предполагаемый план:</span><span class="sxs-lookup"><span data-stu-id="c9265-172">The estimated plan is as follows:</span></span>  
  
 <span data-ttu-id="c9265-173">![План запроса для соединения таблиц, оптимизированных для памяти.](../../database-engine/media/hekaton-query-plan-5.gif "План запроса для соединения таблиц, оптимизированных для памяти.")</span><span class="sxs-lookup"><span data-stu-id="c9265-173">![Query plan for join of memory optimized tables.](../../database-engine/media/hekaton-query-plan-5.gif "Query plan for join of memory optimized tables.")</span></span>  
<span data-ttu-id="c9265-174">План запроса для соединения таблиц, оптимизированных для памяти.</span><span class="sxs-lookup"><span data-stu-id="c9265-174">Query plan for join of memory-optimized tables.</span></span>  
  
 <span data-ttu-id="c9265-175">Изучите следующие отличия от плана для того же запроса к дисковым таблицам (рисунок 1):</span><span class="sxs-lookup"><span data-stu-id="c9265-175">Observe the following differences with the plan for the same query on disk-based tables (figure 1):</span></span>  
  
-   <span data-ttu-id="c9265-176">Этот план для таблицы Customer содержит операцию просмотра таблицы, а не просмотра кластеризованного индекса.</span><span class="sxs-lookup"><span data-stu-id="c9265-176">This plan contains a table scan rather than a clustered index scan for the table Customer:</span></span>  
  
    -   <span data-ttu-id="c9265-177">Определение таблицы не содержит кластеризованный индекс.</span><span class="sxs-lookup"><span data-stu-id="c9265-177">The definition of the table does not contain a clustered index.</span></span>  
  
    -   <span data-ttu-id="c9265-178">Кластеризованные индексы для таблиц, оптимизированных для памяти, не поддерживаются.</span><span class="sxs-lookup"><span data-stu-id="c9265-178">Clustered indexes are not supported with memory-optimized tables.</span></span> <span data-ttu-id="c9265-179">Вместо этого каждая оптимизированная для памяти таблица должна содержать по крайней мере один некластеризованный индекс, а все индексы для оптимизированных в памяти таблиц могут эффективно получать все столбцы таблицы без сохранения их в индексе или ссылки на кластеризованный индекс.</span><span class="sxs-lookup"><span data-stu-id="c9265-179">Instead, every memory-optimized table must have at least one nonclustered index and all indexes on memory-optimized tables can efficiently access all columns in the table without having to store them in the index or refer to a clustered index.</span></span>  
  
-   <span data-ttu-id="c9265-180">Этот план содержит оператор `Hash Match`, а не `Merge Join`.</span><span class="sxs-lookup"><span data-stu-id="c9265-180">This plan contains a `Hash Match` rather than a `Merge Join`.</span></span> <span data-ttu-id="c9265-181">Индексы в таблицах Order и Customer представляют собой хэш-индексы и, следовательно, не упорядочены.</span><span class="sxs-lookup"><span data-stu-id="c9265-181">The indexes on both the Order and the Customer table are hash indexes, and are thus not ordered.</span></span> <span data-ttu-id="c9265-182">Оператор `Merge Join` потребовал бы добавления операторов сортировки, которые вызвали бы снижение производительности запроса.</span><span class="sxs-lookup"><span data-stu-id="c9265-182">A `Merge Join` would require sort operators that would decrease performance.</span></span>  
  
## <a name="natively-compiled-stored-procedures"></a><span data-ttu-id="c9265-183">скомпилированные в собственном коде хранимые процедуры</span><span class="sxs-lookup"><span data-stu-id="c9265-183">Natively Compiled Stored Procedures</span></span>  
 <span data-ttu-id="c9265-184">Скомпилированные в собственном коде хранимые процедуры — это хранимые процедуры [!INCLUDE[tsql](../../../includes/tsql-md.md)] , скомпилированные в машинный код, а не интерпретируемые подсистемой выполнения запросов.</span><span class="sxs-lookup"><span data-stu-id="c9265-184">Natively compiled stored procedures are [!INCLUDE[tsql](../../../includes/tsql-md.md)] stored procedures compiled to machine code, rather than interpreted by the query execution engine.</span></span> <span data-ttu-id="c9265-185">Следующий скрипт создает скомпилированную в собственном коде хранимую процедуру, которая выполняет пример запроса (из раздела «Пример запроса»).</span><span class="sxs-lookup"><span data-stu-id="c9265-185">The following script creates a natively compiled stored procedure that runs the example query (from the Example Query section).</span></span>  
  
```sql  
CREATE PROCEDURE usp_SampleJoin  
WITH NATIVE_COMPILATION, SCHEMABINDING, EXECUTE AS OWNER  
AS BEGIN ATOMIC WITH   
(  TRANSACTION ISOLATION LEVEL = SNAPSHOT,  
  LANGUAGE = 'english')  
  
  SELECT o.OrderID, c.CustomerID, c.ContactName   
FROM dbo.[Order] o INNER JOIN dbo.[Customer] c   
  ON c.CustomerID = o.CustomerID  
  
END  
```  
  
 <span data-ttu-id="c9265-186">Скомпилированные в собственном коде хранимые процедуры компилируются при создании, а интерпретируемые хранимые процедуры компилируются в ходе первого выполнения.</span><span class="sxs-lookup"><span data-stu-id="c9265-186">Natively compiled stored procedures are compiled at create time, whereas interpreted stored procedures are compiled at first execution time.</span></span> <span data-ttu-id="c9265-187">(Частично компиляция, в частности, синтаксический анализ и алгебризация, выполняется при создании.</span><span class="sxs-lookup"><span data-stu-id="c9265-187">(A portion of the compilation, particularly parsing and algebrization, take place at create.</span></span> <span data-ttu-id="c9265-188">Однако для интерпретируемых хранимых процедур оптимизация планов запросов происходит при первом выполнении.) Процесс повторной компиляции имеет аналогичную логику.</span><span class="sxs-lookup"><span data-stu-id="c9265-188">However, for interpreted stored procedures, optimization of the query plans takes place at first execution.) The recompilation logic is similar.</span></span> <span data-ttu-id="c9265-189">При первом выполнении процедуры после перезапуска сервера выполняется перекомпиляция скомпилированных в собственном коде хранимых процедур.</span><span class="sxs-lookup"><span data-stu-id="c9265-189">Natively compiled stored procedures are recompiled on first execution of the procedure if the server is restarted.</span></span> <span data-ttu-id="c9265-190">Интерпретируемые хранимые процедуры повторно компилируются, если в кэше планов отсутствует план запроса.</span><span class="sxs-lookup"><span data-stu-id="c9265-190">Interpreted stored procedures are recompiled if the plan is no longer in the plan cache.</span></span> <span data-ttu-id="c9265-191">В следующей таблице объединены случаи компиляции и повторной компиляции для скомпилированных в собственном коде и интерпретируемых хранимых процедур.</span><span class="sxs-lookup"><span data-stu-id="c9265-191">The following table summarizes compilation and recompilation cases for both natively compiled and interpreted stored procedures:</span></span>  
  
||<span data-ttu-id="c9265-192">Скомпилированные в собственном коде</span><span class="sxs-lookup"><span data-stu-id="c9265-192">Natively compiled</span></span>|<span data-ttu-id="c9265-193">Доступ к оптимизированным для памяти таблицам с помощью интерпретируемого кода</span><span class="sxs-lookup"><span data-stu-id="c9265-193">Interpreted</span></span>|  
|-|-----------------------|-----------------|  
|<span data-ttu-id="c9265-194">Первичная компиляция</span><span class="sxs-lookup"><span data-stu-id="c9265-194">Initial compilation</span></span>|<span data-ttu-id="c9265-195">При создании.</span><span class="sxs-lookup"><span data-stu-id="c9265-195">At create time.</span></span>|<span data-ttu-id="c9265-196">При первом выполнении.</span><span class="sxs-lookup"><span data-stu-id="c9265-196">At first execution.</span></span>|  
|<span data-ttu-id="c9265-197">Автоматическая повторная компиляция</span><span class="sxs-lookup"><span data-stu-id="c9265-197">Automatic recompilation</span></span>|<span data-ttu-id="c9265-198">При первом выполнении процедуры после перезапуска базы данных или сервера.</span><span class="sxs-lookup"><span data-stu-id="c9265-198">Upon first execution of the procedure after a database or server restart.</span></span>|<span data-ttu-id="c9265-199">При перезапуске сервера.</span><span class="sxs-lookup"><span data-stu-id="c9265-199">On server restart.</span></span> <span data-ttu-id="c9265-200">Либо при вытеснении из кэша планов, обычно вследствие изменений схемы или статистических данных или нагрузки на память.</span><span class="sxs-lookup"><span data-stu-id="c9265-200">Or, eviction from the plan cache, usually based on schema or stats changes, or memory pressure.</span></span>|  
|<span data-ttu-id="c9265-201">Повторная компиляция вручную</span><span class="sxs-lookup"><span data-stu-id="c9265-201">Manual recompilation</span></span>|<span data-ttu-id="c9265-202">Не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="c9265-202">Not supported.</span></span> <span data-ttu-id="c9265-203">Решение, позволяющее обойти эти ограничения, заключается в удалении и повторном создании хранимой процедуры.</span><span class="sxs-lookup"><span data-stu-id="c9265-203">The workaround is to drop and recreate the stored procedure.</span></span>|<span data-ttu-id="c9265-204">Используйте ключевое слово `sp_recompile`.</span><span class="sxs-lookup"><span data-stu-id="c9265-204">Use `sp_recompile`.</span></span> <span data-ttu-id="c9265-205">Можно вручную удалить план из кэша при помощи инструкции DBCC FREEPROCCACHE.</span><span class="sxs-lookup"><span data-stu-id="c9265-205">You can manually evict the plan from the cache, for example through DBCC FREEPROCCACHE.</span></span> <span data-ttu-id="c9265-206">Можно также создать хранимую процедуру с параметром WITH RECOMPILE; такая хранимая процедура будет повторно компилироваться при каждом выполнении.</span><span class="sxs-lookup"><span data-stu-id="c9265-206">You can also create the stored procedure WITH RECOMPILE and the stored procedure will be recompiled at every execution.</span></span>|  
  
### <a name="compilation-and-query-processing"></a><span data-ttu-id="c9265-207">Компиляция и обработка запросов</span><span class="sxs-lookup"><span data-stu-id="c9265-207">Compilation and Query Processing</span></span>  
 <span data-ttu-id="c9265-208">На следующей диаграмме показан процесс компиляции для скомпилированных в собственном коде хранимых процедур:</span><span class="sxs-lookup"><span data-stu-id="c9265-208">The following diagram illustrates the compilation process for natively compiled stored procedures:</span></span>  
  
 <span data-ttu-id="c9265-209">![Компиляция хранимых процедур в собственном коде.](../../database-engine/media/hekaton-query-plan-6.gif "Компиляция хранимых процедур в собственном коде.")</span><span class="sxs-lookup"><span data-stu-id="c9265-209">![Native compilation of stored procedures.](../../database-engine/media/hekaton-query-plan-6.gif "Native compilation of stored procedures.")</span></span>  
<span data-ttu-id="c9265-210">Компиляция хранимых процедур в собственном коде.</span><span class="sxs-lookup"><span data-stu-id="c9265-210">Native compilation of stored procedures.</span></span>  
  
 <span data-ttu-id="c9265-211">Описание процесса</span><span class="sxs-lookup"><span data-stu-id="c9265-211">The process is described as,</span></span>  
  
1.  <span data-ttu-id="c9265-212">Пользователь выполняет инструкцию `CREATE PROCEDURE` в [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="c9265-212">The user issues a `CREATE PROCEDURE` statement to [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span>  
  
2.  <span data-ttu-id="c9265-213">Средство синтаксического анализа и алгебризатор создают поток обработки для процедуры, а также запрашивают деревья для запросов [!INCLUDE[tsql](../../../includes/tsql-md.md)] в хранимой процедуре.</span><span class="sxs-lookup"><span data-stu-id="c9265-213">The parser and algebrizer create the processing flow for the procedure, as well as query trees for the [!INCLUDE[tsql](../../../includes/tsql-md.md)] queries in the stored procedure.</span></span>  
  
3.  <span data-ttu-id="c9265-214">Оптимизатор запросов создает оптимизированные планы выполнения запросов для всех запросов в данной хранимой процедуре.</span><span class="sxs-lookup"><span data-stu-id="c9265-214">The optimizer creates optimized query execution plans for all the queries in the stored procedure.</span></span>  
  
4.  <span data-ttu-id="c9265-215">Компилятор In-Memory OLTP принимает поток обработки с внедренными оптимизированными планами запросов и создает библиотеку DLL, которая содержит машинный код для выполнения хранимой процедуры.</span><span class="sxs-lookup"><span data-stu-id="c9265-215">The In-Memory OLTP compiler takes the processing flow with the embedded optimized query plans and generates a DLL that contains the machine code for executing the stored procedure.</span></span>  
  
5.  <span data-ttu-id="c9265-216">Созданная библиотека DDL загружается в память.</span><span class="sxs-lookup"><span data-stu-id="c9265-216">The generated DLL is loaded into memory.</span></span>  
  
 <span data-ttu-id="c9265-217">Вызов хранимой процедуры, скомпилированной в собственном коде, транслируется в вызов функции из библиотеки DLL.</span><span class="sxs-lookup"><span data-stu-id="c9265-217">Invocation of a natively compiled stored procedure translates to calling a function in the DLL.</span></span>  
  
 <span data-ttu-id="c9265-218">![Выполнение хранимых процедур, скомпилированных в собственном коде.](../../database-engine/media/hekaton-query-plan-7.gif "Выполнение хранимых процедур, скомпилированных в собственном коде.")</span><span class="sxs-lookup"><span data-stu-id="c9265-218">![Execution of natively compiled stored procedures.](../../database-engine/media/hekaton-query-plan-7.gif "Execution of natively compiled stored procedures.")</span></span>  
<span data-ttu-id="c9265-219">Выполнение хранимых процедур, скомпилированных в собственном коде.</span><span class="sxs-lookup"><span data-stu-id="c9265-219">Execution of natively compiled stored procedures.</span></span>  
  
 <span data-ttu-id="c9265-220">Описание вызова хранимой процедуры, скомпилированной в собственном коде:</span><span class="sxs-lookup"><span data-stu-id="c9265-220">Invocation of a natively compiled stored procedure is described as follows:</span></span>  
  
1.  <span data-ttu-id="c9265-221">Пользователь выдает `EXEC` инструкцию *usp_myproc* .</span><span class="sxs-lookup"><span data-stu-id="c9265-221">The user issues an `EXEC`*usp_myproc* statement.</span></span>  
  
2.  <span data-ttu-id="c9265-222">Средство синтаксического анализа извлекает имя и параметры хранимой процедуры.</span><span class="sxs-lookup"><span data-stu-id="c9265-222">The parser extracts the name and stored procedure parameters.</span></span>  
  
     <span data-ttu-id="c9265-223">Если инструкция подготовлена, например, с помощью `sp_prep_exec`, анализатору не придется извлекать имя процедуры и параметры во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="c9265-223">If the statement was prepared, for example using `sp_prep_exec`, the parser does not need to extract the procedure name and parameters at execution time.</span></span>  
  
3.  <span data-ttu-id="c9265-224">Среда выполнения In-Memory OLTP находит точки входа библиотеки DLL для хранимой процедуры.</span><span class="sxs-lookup"><span data-stu-id="c9265-224">The In-Memory OLTP runtime locates the DLL entry point for the stored procedure.</span></span>  
  
4.  <span data-ttu-id="c9265-225">Машинный код в DLL выполняется, и результаты возвращаются клиенту.</span><span class="sxs-lookup"><span data-stu-id="c9265-225">The machine code in the DLL is executed and the results of are returned to the client.</span></span>  
  
 <span data-ttu-id="c9265-226">**Пробное сохранение параметров**</span><span class="sxs-lookup"><span data-stu-id="c9265-226">**Parameter sniffing**</span></span>  
  
 <span data-ttu-id="c9265-227">Интерпретируемые хранимые процедуры [!INCLUDE[tsql](../../../includes/tsql-md.md)] компилируются во время первого выполнения в отличие от хранимых процедур, скомпилированных в собственном коде, которые компилируются при создании.</span><span class="sxs-lookup"><span data-stu-id="c9265-227">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] stored procedures are compiled at first execution, in contrast to natively compiled stored procedures, which are compiled at create time.</span></span> <span data-ttu-id="c9265-228">Если интерпретируемые хранимые процедуры компилируются при вызове, значения параметров, указанные для этого вызова, используются оптимизатором для создания плана выполнения.</span><span class="sxs-lookup"><span data-stu-id="c9265-228">When interpreted stored procedures are compiled at invocation, the values of the parameters supplied for this invocation are used by the optimizer when generating the execution plan.</span></span> <span data-ttu-id="c9265-229">Такое использование параметров в процессе компиляции называется пробным сохранением параметров.</span><span class="sxs-lookup"><span data-stu-id="c9265-229">This use of parameters during compilation is called parameter sniffing.</span></span>  
  
 <span data-ttu-id="c9265-230">Пробное сохранение параметров не используется для компиляции хранимых процедур, скомпилированных в собственном коде.</span><span class="sxs-lookup"><span data-stu-id="c9265-230">Parameter sniffing is not used for compiling natively compiled stored procedures.</span></span> <span data-ttu-id="c9265-231">Предполагается, что у всех параметров хранимой процедуры значения UNKNOWN (неизвестны).</span><span class="sxs-lookup"><span data-stu-id="c9265-231">All parameters to the stored procedure are considered to have UNKNOWN values.</span></span> <span data-ttu-id="c9265-232">Как и интерпретируемые хранимые процедуры, скомпилированные в собственном коде хранимые процедуры также поддерживают указание `OPTIMIZE FOR`.</span><span class="sxs-lookup"><span data-stu-id="c9265-232">Like interpreted stored procedures, natively compiled stored procedures also support the `OPTIMIZE FOR` hint.</span></span> <span data-ttu-id="c9265-233">Дополнительные сведения см. в разделе [Указания запросов (Transact-SQL)](/sql/t-sql/queries/hints-transact-sql-query).</span><span class="sxs-lookup"><span data-stu-id="c9265-233">For more information, see [Query Hints &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-query).</span></span>  
  
### <a name="retrieving-a-query-execution-plan-for-natively-compiled-stored-procedures"></a><span data-ttu-id="c9265-234">Получение плана выполнения запроса для скомпилированных в собственном коде хранимых процедур</span><span class="sxs-lookup"><span data-stu-id="c9265-234">Retrieving a Query Execution Plan for Natively Compiled Stored Procedures</span></span>  
 <span data-ttu-id="c9265-235">План выполнения запроса для скомпилированной в собственном коде хранимой процедуры можно получить с помощью **предполагаемого плана выполнения** в среде [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)]или с помощью параметра SHOWPLAN_XML в [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="c9265-235">The query execution plan for a natively compiled stored procedure can be retrieved using **Estimated Execution Plan** in [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)], or using the SHOWPLAN_XML option in [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="c9265-236">Пример:</span><span class="sxs-lookup"><span data-stu-id="c9265-236">For example:</span></span>  
  
```sql  
SET SHOWPLAN_XML ON  
GO  
EXEC dbo.usp_myproc  
GO  
SET SHOWPLAN_XML OFF  
GO  
```  
  
 <span data-ttu-id="c9265-237">План выполнения, созданный с помощью оптимизатора запросов, состоит из дерева с операторами запроса на узлах и конечных узлах дерева.</span><span class="sxs-lookup"><span data-stu-id="c9265-237">The execution plan generated by the query optimizer consists of a tree with query operators on the nodes and leaves of the tree.</span></span> <span data-ttu-id="c9265-238">Структура дерева определяет механизм взаимодействия (поток строк от одного оператора к другому) между операторами.</span><span class="sxs-lookup"><span data-stu-id="c9265-238">The structure of the tree determines the interaction (the flow of rows from one operator to another) between the operators.</span></span> <span data-ttu-id="c9265-239">В графическом представлении [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)]изображен поток справа налево.</span><span class="sxs-lookup"><span data-stu-id="c9265-239">In the graphical view of [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)], the flow is from right to left.</span></span> <span data-ttu-id="c9265-240">Например, план запроса в диаграмме 1 содержит два оператора просмотра индекса, которые передают строки оператору соединения слиянием.</span><span class="sxs-lookup"><span data-stu-id="c9265-240">For example, the query plan in figure 1 contains two index scan operators, which supplies rows to a merge join operator.</span></span> <span data-ttu-id="c9265-241">Оператор соединения слиянием merge join передает строки оператору выбора select.</span><span class="sxs-lookup"><span data-stu-id="c9265-241">The merge join operator supplies rows to a select operator.</span></span> <span data-ttu-id="c9265-242">Наконец, оператор Select возвращает строки клиенту.</span><span class="sxs-lookup"><span data-stu-id="c9265-242">The select operator, finally, returns the rows to the client.</span></span>  
  
### <a name="query-operators-in-natively-compiled-stored-procedures"></a><span data-ttu-id="c9265-243">Операторы запросов в хранимых процедурах, скомпилированных в собственном коде</span><span class="sxs-lookup"><span data-stu-id="c9265-243">Query Operators in Natively Compiled Stored Procedures</span></span>  
 <span data-ttu-id="c9265-244">В следующей таблице перечислены операторы запросов, которые поддерживаются в хранимых процедурах, скомпилированных в собственном коде.</span><span class="sxs-lookup"><span data-stu-id="c9265-244">The following table summarizes the query operators supported inside natively compiled stored procedures:</span></span>  
  
|<span data-ttu-id="c9265-245">Оператор</span><span class="sxs-lookup"><span data-stu-id="c9265-245">Operator</span></span>|<span data-ttu-id="c9265-246">Пример запроса</span><span class="sxs-lookup"><span data-stu-id="c9265-246">Sample query</span></span>|  
|--------------|------------------|  
|<span data-ttu-id="c9265-247">SELECT</span><span class="sxs-lookup"><span data-stu-id="c9265-247">SELECT</span></span>|`SELECT OrderID FROM dbo.[Order]`|  
|<span data-ttu-id="c9265-248">INSERT</span><span class="sxs-lookup"><span data-stu-id="c9265-248">INSERT</span></span>|`INSERT dbo.Customer VALUES ('abc', 'def')`|  
|<span data-ttu-id="c9265-249">UPDATE</span><span class="sxs-lookup"><span data-stu-id="c9265-249">UPDATE</span></span>|`UPDATE dbo.Customer SET ContactName='ghi' WHERE CustomerID='abc'`|  
|<span data-ttu-id="c9265-250">DELETE</span><span class="sxs-lookup"><span data-stu-id="c9265-250">DELETE</span></span>|`DELETE dbo.Customer WHERE CustomerID='abc'`|  
|<span data-ttu-id="c9265-251">Compute Scalar</span><span class="sxs-lookup"><span data-stu-id="c9265-251">Compute Scalar</span></span>|<span data-ttu-id="c9265-252">Этот оператор используется как для встроенных функций, так и для преобразований типов.</span><span class="sxs-lookup"><span data-stu-id="c9265-252">This operator is used both for intrinsic functions and type conversions.</span></span> <span data-ttu-id="c9265-253">Не все функции и преобразования типов поддерживаются в хранимых процедурах, скомпилированных в собственном коде.</span><span class="sxs-lookup"><span data-stu-id="c9265-253">Not all functions and type conversions are supported inside natively compiled stored procedures.</span></span><br /><br /> `SELECT OrderID+1 FROM dbo.[Order]`|  
|<span data-ttu-id="c9265-254">Соединение вложенными циклами</span><span class="sxs-lookup"><span data-stu-id="c9265-254">Nested Loops Join</span></span>|<span data-ttu-id="c9265-255">Nested Loops — единственный оператор соединения, который поддерживается в хранимых процедурах, скомпилированных в собственном коде.</span><span class="sxs-lookup"><span data-stu-id="c9265-255">Nested Loops is the only join operator supported in natively compiled stored procedures.</span></span> <span data-ttu-id="c9265-256">Все планы, которые содержат соединения, будут использовать оператор Nested Loops, даже если план одного и того же запроса, выполненного как интерпретируемый код [!INCLUDE[tsql](../../../includes/tsql-md.md)] , содержит хэш-соединение или соединение слиянием.</span><span class="sxs-lookup"><span data-stu-id="c9265-256">All plans that contain joins will use the Nested Loops operator, even if the plan for same query executed as interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] contains a hash or merge join.</span></span><br /><br /> `SELECT o.OrderID, c.CustomerID`  <br /> `FROM dbo.[Order] o INNER JOIN dbo.[Customer] c`|  
|<span data-ttu-id="c9265-257">Сортировка</span><span class="sxs-lookup"><span data-stu-id="c9265-257">Sort</span></span>|`SELECT ContactName FROM dbo.Customer`  <br /> `ORDER BY ContactName`|  
|<span data-ttu-id="c9265-258">TOP</span><span class="sxs-lookup"><span data-stu-id="c9265-258">Top</span></span>|`SELECT TOP 10 ContactName FROM dbo.Customer`|  
|<span data-ttu-id="c9265-259">Оператор Top-sort</span><span class="sxs-lookup"><span data-stu-id="c9265-259">Top-sort</span></span>|<span data-ttu-id="c9265-260">Выражение `TOP` (количество возвращаемых строк) не может превышать 8000 строк.</span><span class="sxs-lookup"><span data-stu-id="c9265-260">The `TOP` expression (the number of rows to be returned) cannot exceed 8,000 rows.</span></span> <span data-ttu-id="c9265-261">Если в запросе есть операторы объединения и агрегирования, то строк должно быть еще меньше.</span><span class="sxs-lookup"><span data-stu-id="c9265-261">Fewer if there are also join and aggregation operators in the query.</span></span> <span data-ttu-id="c9265-262">Соединения и агрегатные выражения обычно уменьшают количество строк для сортировки в сравнении с количеством строк в базовых таблицах.</span><span class="sxs-lookup"><span data-stu-id="c9265-262">Joins and aggregation do typically reduce the number of rows to be sorted, compared with the row count of the base tables.</span></span><br /><br /> `SELECT TOP 10 ContactName FROM dbo.Customer`  <br /> `ORDER BY ContactName`|  
|<span data-ttu-id="c9265-263">Статистическое выражение потока</span><span class="sxs-lookup"><span data-stu-id="c9265-263">Stream Aggregate</span></span>|<span data-ttu-id="c9265-264">Обратите внимание, что оператор Hash Match для статической обработки не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="c9265-264">Note that the Hash Match operator is not supported for aggregation.</span></span> <span data-ttu-id="c9265-265">Поэтому все агрегаты в скомпилированных в собственном коде хранимых процедурах используют оператор Stream Aggregate, даже если план для этого же запроса в интерпретируемом [!INCLUDE[tsql](../../../includes/tsql-md.md)] использует оператор Hash Match.</span><span class="sxs-lookup"><span data-stu-id="c9265-265">Therefore, all aggregation in natively compiled stored procedures uses the Stream Aggregate operator, even if the plan for the same query in interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] uses the Hash Match operator.</span></span><br /><br /> `SELECT count(CustomerID) FROM dbo.Customer`|  
  
## <a name="column-statistics-and-joins"></a><span data-ttu-id="c9265-266">Статистика столбцов и соединения</span><span class="sxs-lookup"><span data-stu-id="c9265-266">Column Statistics and Joins</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="c9265-267">ведет статистику значений в ключевых столбцах индекса, что позволяет оценить стоимость отдельных операций, таких как просмотр индекса и поиск в индексе.</span><span class="sxs-lookup"><span data-stu-id="c9265-267">maintains statistics on values in index key columns to help estimate the cost of certain operations, such as index scan and index seeks.</span></span> <span data-ttu-id="c9265-268">([!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] также создает статистику по ключевым столбцам вне индекса, если они создаются явно или если оптимизатор запросов создает их в ответ на запрос с предикатом.) Основной показатель в оценке стоимости — количество строк, обрабатываемых одним оператором.</span><span class="sxs-lookup"><span data-stu-id="c9265-268">( [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] also creates statistics on non-index key columns if you explicitly create them or if the query optimizer creates them in response to a query with a predicate.) The main metric in cost estimation is the number of rows processed by a single operator.</span></span> <span data-ttu-id="c9265-269">Обратите внимание, что для дисковых таблиц количество страниц, к которым обращается конкретный оператор, является существенным для оценки стоимости.</span><span class="sxs-lookup"><span data-stu-id="c9265-269">Note that for disk-based tables, the number of pages accessed by a particular operator is significant in cost estimation.</span></span> <span data-ttu-id="c9265-270">Тем не менее, поскольку количество страниц не имеет значения для таблиц, оптимизированных для памяти (оно всегда равно нулю), мы сосредоточимся на количестве строк.</span><span class="sxs-lookup"><span data-stu-id="c9265-270">However, as page count is not important for memory-optimized tables (it is always zero), this discussion focuses on row count.</span></span> <span data-ttu-id="c9265-271">Оценка начинается с операторов поиска в индексе и просмотра индекса в плане, а затем дополняется другими операторами, например, операторами соединения.</span><span class="sxs-lookup"><span data-stu-id="c9265-271">The estimation starts with the index seek and scan operators in the plan, and is then extended to include the other operators, like the join operator.</span></span> <span data-ttu-id="c9265-272">Предполагаемое количество строк, которые будет обрабатывать оператор соединения, основано на оценке базовых операторов поиска и просмотра индекса.</span><span class="sxs-lookup"><span data-stu-id="c9265-272">The estimated number of rows to be processed by a join operator is based on the estimation for the underlying index, seek, and scan operators.</span></span> <span data-ttu-id="c9265-273">При выполнении доступа к оптимизированным для памяти таблицам с помощью интерпретируемого [!INCLUDE[tsql](../../../includes/tsql-md.md)] можно рассмотреть фактический план выполнения, чтобы увидеть разницу между расчетным и фактическим числом строк для операторов в плане.</span><span class="sxs-lookup"><span data-stu-id="c9265-273">For interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access to memory-optimized tables, you can observe the actual execution plan to see the difference between the estimated and actual row counts for the operators in the plan.</span></span>  
  
 <span data-ttu-id="c9265-274">Например, на рисунке 1</span><span class="sxs-lookup"><span data-stu-id="c9265-274">For the example in figure 1,</span></span>  
  
-   <span data-ttu-id="c9265-275">Оператор просмотра кластеризованного индекса в таблице Customer: предполагаемое количество — 91; реальное — 91;</span><span class="sxs-lookup"><span data-stu-id="c9265-275">The clustered index scan on Customer has estimated 91; actual 91.</span></span>  
  
-   <span data-ttu-id="c9265-276">Просмотр некластеризованного индекса в CustomerID: предполагаемое 830, реальное 830.</span><span class="sxs-lookup"><span data-stu-id="c9265-276">The nonclustered index scan on CustomerID has estimated 830; actual 830.</span></span>  
  
-   <span data-ttu-id="c9265-277">Оператор соединения слиянием: предполагаемое 815; реальное 830.</span><span class="sxs-lookup"><span data-stu-id="c9265-277">The Merge Join operator has estimated 815; actual 830.</span></span>  
  
 <span data-ttu-id="c9265-278">Оценки для оператора просмотра индекса являются точными.</span><span class="sxs-lookup"><span data-stu-id="c9265-278">The estimates for the index scans are accurate.</span></span> [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="c9265-279">поддерживает количество строк для дисковых таблиц.</span><span class="sxs-lookup"><span data-stu-id="c9265-279">maintains the row count for disk-based tables.</span></span> <span data-ttu-id="c9265-280">Оценки для всей таблицы и просмотра индекса всегда являются точными.</span><span class="sxs-lookup"><span data-stu-id="c9265-280">Estimates for full table and index scans are always accurate.</span></span> <span data-ttu-id="c9265-281">Оценки для соединений также достаточно точные).</span><span class="sxs-lookup"><span data-stu-id="c9265-281">The estimate for the join is fairly accurate, too.</span></span>  
  
 <span data-ttu-id="c9265-282">Если эти оценки изменяются, расчеты стоимости для различных вариантов плана также изменяются.</span><span class="sxs-lookup"><span data-stu-id="c9265-282">If these estimates change, the cost considerations for different plan alternatives change as well.</span></span> <span data-ttu-id="c9265-283">Например, если один из участников соединения имеет предполагаемое количество строк 1 или всего несколько строк, использование соединений вложенными циклами является менее дорогостоящим.</span><span class="sxs-lookup"><span data-stu-id="c9265-283">For example, if one of the sides of the join has an estimated row count of 1 or just a few rows, using a nested loops joins is less expensive.</span></span>  
  
 <span data-ttu-id="c9265-284">Ниже приводится план запроса:</span><span class="sxs-lookup"><span data-stu-id="c9265-284">The following is the plan for the query:</span></span>  
  
```  
SELECT o.OrderID, c.* FROM dbo.[Customer] c INNER JOIN dbo.[Order] o ON c.CustomerID = o.CustomerID  
```  
  
 <span data-ttu-id="c9265-285">После удаления всех строк, кроме одной, в таблице Customer:</span><span class="sxs-lookup"><span data-stu-id="c9265-285">After deleting all rows but one in the table Customer:</span></span>  
  
 <span data-ttu-id="c9265-286">![Статистика столбцов и соединения.](../../database-engine/media/hekaton-query-plan-9.gif "Статистика столбцов и соединения.")</span><span class="sxs-lookup"><span data-stu-id="c9265-286">![Column statistics and joins.](../../database-engine/media/hekaton-query-plan-9.gif "Column statistics and joins.")</span></span>  
  
 <span data-ttu-id="c9265-287">Относительно этого плана запроса:</span><span class="sxs-lookup"><span data-stu-id="c9265-287">Regarding this query plan:</span></span>  
  
-   <span data-ttu-id="c9265-288">Оператор Hash Match был заменен на физический оператор соединения Nested Loops.</span><span class="sxs-lookup"><span data-stu-id="c9265-288">The Hash Match has been replaced with a Nested Loops physical join operator.</span></span>  
  
-   <span data-ttu-id="c9265-289">Полный просмотр индекса в IX_CustomerID заменен поиском по индексу.</span><span class="sxs-lookup"><span data-stu-id="c9265-289">The full index scan on IX_CustomerID has been replaced with an index seek.</span></span> <span data-ttu-id="c9265-290">В результате для полного просмотра индекса было просмотрено 5 строк вместо 830.</span><span class="sxs-lookup"><span data-stu-id="c9265-290">This resulted in scanning 5 rows, instead of the 830 rows required for the full index scan.</span></span>  
  
### <a name="statistics-and-cardinality-for-memory-optimized-tables"></a><span data-ttu-id="c9265-291">Статистика и количество элементов для таблиц, оптимизированных для памяти</span><span class="sxs-lookup"><span data-stu-id="c9265-291">Statistics and Cardinality for Memory-Optimized Tables</span></span>  
 <span data-ttu-id="c9265-292">В [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] ведется статистика для оптимизированных для памяти таблиц на уровне столбца.</span><span class="sxs-lookup"><span data-stu-id="c9265-292">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] maintains column-level statistics for memory-optimized tables.</span></span> <span data-ttu-id="c9265-293">Кроме того, в нем осуществляется подсчет действительного числа строк таблицы.</span><span class="sxs-lookup"><span data-stu-id="c9265-293">In addition, it maintains the actual row count of the table.</span></span> <span data-ttu-id="c9265-294">Однако в отличие от дисковых таблиц статистика для оптимизированных для памяти таблиц не обновляется автоматически.</span><span class="sxs-lookup"><span data-stu-id="c9265-294">However, in contrast to disk-based tables, the statistics for memory-optimized tables are not automatically updated.</span></span> <span data-ttu-id="c9265-295">Следовательно, необходимо вручную обновлять статистику после значительных изменений в таблицах.</span><span class="sxs-lookup"><span data-stu-id="c9265-295">Therefore, statistics need to be manually updated after significant changes in the tables.</span></span> <span data-ttu-id="c9265-296">Дополнительные сведения см. в статье [Статистика для таблиц, оптимизированных для памяти](memory-optimized-tables.md).</span><span class="sxs-lookup"><span data-stu-id="c9265-296">For more information, see [Statistics for Memory-Optimized Tables](memory-optimized-tables.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c9265-297">См. также:</span><span class="sxs-lookup"><span data-stu-id="c9265-297">See Also</span></span>  
 [<span data-ttu-id="c9265-298">Таблицы, оптимизированные для памяти</span><span class="sxs-lookup"><span data-stu-id="c9265-298">Memory-Optimized Tables</span></span>](memory-optimized-tables.md)  
  
  

---
title: Конструкции языка Transact-SQL, не поддерживаемые для выполняющейся в памяти OLTP | Документация Майкрософт
ms.custom: ''
ms.date: 03/07/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: e3f8009c-319d-4d7b-8993-828e55ccde11
author: rothja
ms.author: jroth
ms.openlocfilehash: 2b5df47d05730b8f6ec6a82045686d462ace1682
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87749879"
---
# <a name="transact-sql-constructs-not-supported-by-in-memory-oltp"></a>Конструкции языка Transact-SQL, неподдерживаемые в In-Memory OLTP
  Оптимизированные для памяти таблицы и скомпилированные хранимые процедуры не поддерживают полную контактную зону [!INCLUDE[tsql](../../includes/tsql-md.md)], которая поддерживается дисковыми таблицами и интерпретируемыми хранимыми процедурами [!INCLUDE[tsql](../../includes/tsql-md.md)]. При попытке использовать одну из неподдерживаемых функций сервер возвращает ошибку.  
  
 Текст сообщения об ошибке указывает тип инструкции [!INCLUDE[tsql](../../includes/tsql-md.md)] (функции, операции, параметра), а также имя функции или ключевое слово [!INCLUDE[tsql](../../includes/tsql-md.md)] . Большинство неподдерживаемых функций возвращают ошибку 10794, а текст сообщения об ошибке указывает на неподдерживаемую функцию. В следующей таблице перечислены функции и ключевые слова [!INCLUDE[tsql](../../includes/tsql-md.md)] , которые могут появиться в тексте сообщения об ошибке, а также действие по ее исправлению.  
  
 Дополнительные сведения о поддерживаемых функциях для оптимизированных для памяти таблиц и скомпилированных в собственном коде хранимых процедур см. на следующих ресурсах:  
  
-   [Проблемы миграции, связанные с хранимыми процедурами, скомпилированными в собственном коде](migration-issues-for-natively-compiled-stored-procedures.md)  
  
-   [Поддержка Transact-SQL для выполняющейся в памяти OLTP](transact-sql-support-for-in-memory-oltp.md)  
  
-   [Поддерживаемые возможности SQL Server](unsupported-sql-server-features-for-in-memory-oltp.md)  
  
-   [Скомпилированные в собственном коде хранимые процедуры](../in-memory-oltp/natively-compiled-stored-procedures.md)  
  
## <a name="databases-that-use-in-memory-oltp"></a>Базы данных, использующие OLTP в памяти  
 В следующей таблице перечислены функции и ключевые слова [!INCLUDE[tsql](../../includes/tsql-md.md)], которые могут присутствовать в тексте сообщения об ошибке, связанной с базой данных In-Memory OLTP.  
  
|Тип|Имя|Решение|  
|----------|----------|----------------|  
|Параметр|AUTO_CLOSE|Параметр базы данных AUTO_CLOSE=ON не поддерживается для баз данных, имеющих файловую группу MEMORY_OPTIMIZED_DATA.|  
|Параметр|ATTACH_REBUILD_LOG|Параметр ATTACH_REBUILD_LOG инструкции CREATE базы данных не поддерживается для баз данных, имеющих файловую группу MEMORY_OPTIMIZED_DATA.|  
|Компонент|DATABASE SNAPSHOT|Создание моментальных снимков базы данных не поддерживается для баз данных, имеющих файловую группу MEMORY_OPTIMIZED_DATA.|  
|Компонент|Репликация с помощью метода синхронизации «database snapshot» или «database snapshot character»|Репликация с помощью метода синхронизации «database snapshot» или «database snapshot character» не поддерживается для баз данных, имеющих файловую группу MEMORY_OPTIMIZED_DATA.|  
|Компонент|DBCC CHECKDB<br /><br /> DBCC CHECKTABLE|DBCC CHECKDB пропускает оптимизированные для памяти таблицы в базе данных.<br /><br /> DBCC CHECKTABLE для таблиц, оптимизированных для памяти, завершается ошибкой.|  
  
## <a name="memory-optimized-tables"></a>Таблицы, оптимизированные для памяти  
 В следующей таблице перечислены функции и ключевые слова [!INCLUDE[tsql](../../includes/tsql-md.md)], которые могут присутствовать в тексте ошибки, связанной с оптимизированной для памяти таблицей, а также действие по исправлению данной ошибки.  
  
|Тип|Имя|Решение|  
|----------|----------|----------------|  
|Компонент|ON|Оптимизированные для памяти таблицы не могут размещаться в файловой группе или схеме секционирования. Удалите предложение ON из инструкции `CREATE TABLE`.|  
|Тип данных|*Название типа данных*|Указанный тип данных не поддерживается. Замените этот тип одним из поддерживаемых типов данных. Дополнительные сведения см. в разделе [Поддерживаемые типы данных](supported-data-types-for-in-memory-oltp.md).|  
|Компонент|Вычисляемые столбцы|Вычисляемые столбцы не поддерживаются для оптимизированных для памяти таблиц. Удалите вычисляемые столбцы из инструкции `CREATE TABLE`.|  
|Компонент|Репликация|Репликация не поддерживается для таблиц, оптимизированных для памяти.|  
|Компонент|FILESTREAM|Хранилище FILESTREAM не поддерживает столбцы оптимизированных для памяти таблиц. Удалите ключевое слово `FILESTREAM` из определения столбца.|  
|Компонент|SPARSE|Столбцы оптимизированных для памяти таблиц не могут быть определены как SPARSE. Удалите ключевое слово `SPARSE` из определения столбца.|  
|Компонент|ROWGUIDCOL|Параметр ROWGUIDCOL не поддерживается для столбцов таблиц, оптимизированных для памяти. Удалите ключевое слово `ROWGUIDCOL` из определения столбца.|  
|Компонент|FOREIGN KEY|Ограничения FOREIGN KEY не поддерживаются для оптимизированных для памяти таблиц. Удалите выбранное ограничение из определения таблицы.<br /><br /> Сведения о том, как устранить отсутствие поддержки ограничений, см. в разделе [Миграция ограничений CHECK и FOREIGN KEY](../../database-engine/migrating-check-and-foreign-key-constraints.md).|  
|Признак|CHECK|Ограничения CHECK не поддерживаются для оптимизированных для памяти таблиц. Удалите выбранное ограничение из определения таблицы.<br /><br /> Сведения о том, как устранить отсутствие поддержки ограничений, см. в разделе [Миграция ограничений CHECK и FOREIGN KEY](../../database-engine/migrating-check-and-foreign-key-constraints.md).|  
|Признак|UNIQUE|Ограничения UNIQUE не поддерживаются для оптимизированных для памяти таблиц. Удалите выбранное ограничение из определения таблицы.<br /><br /> Сведения о том, как устранить отсутствие поддержки ограничений, см. в разделе [Миграция ограничений CHECK и FOREIGN KEY](../../database-engine/migrating-check-and-foreign-key-constraints.md).|  
|Признак|COLUMNSTORE|Индексы COLUMNSTORE не поддерживаются в оптимизированных для памяти таблицах. Укажите вместо этого индекс NONСLUSTERED или NONСLUSTERED HASH.|  
|Компонент|кластеризованный индекс|Укажите некластеризованный индекс. В случае использования индекса первичного ключа необходимо указать `PRIMARY KEY NONCLUSTERED [HASH]`.|  
|Признак|кодовая страница не 1252|Столбцы в оптимизированных для памяти таблицах с типами данных `char` и `varchar` должны использовать кодовую страницу 1252. Используйте n(var)char вместо (var)char или используйте параметры сортировки с кодовой страницей 1252 (например, Latin1_General_BIN2). Дополнительные сведения см. в разделе [Collations and Code Pages](../../database-engine/collations-and-code-pages.md).|  
|Компонент|DDL в транзакциях|Оптимизированные для памяти таблицы и скомпилированные хранимые процедуры нельзя создавать или удалять в контексте пользовательской транзакции. Не начинайте транзакцию до выполнения инструкции CREATE или DROP и проверьте, чтобы параметр сеанса IMPLICIT_TRANSACTIONS имел значение OFF.|  
|Компонент|DDL, триггеры|Оптимизированные для памяти таблицы и скомпилированные хранимые процедуры нельзя создать или удалить, если есть триггер сервера или базы данных для этой DDL-операции. Удалите триггеры сервера и базы данных для операций CREATE/DROP TABLE и CREATE/DROP PROCEDURE.|  
|Компонент|EVENT NOTIFICATION|Оптимизированные для памяти таблицы и скомпилированные хранимые процедуры нельзя создать или удалить, если есть уведомление о событии сервера или базы данных для этой DDL-операции. Удалите уведомления о событиях сервера и базы данных в CREATE TABLE или DROP TABLE, а также в CREATE PROCEDURE или DROP PROCEDURE.|  
|Компонент|FileTable|Оптимизированные для памяти таблицы не могут быть созданы как файловые таблицы. Удалите аргумент `AS FileTable` из инструкции `CREATE TABLE`.|  
|Операция|Обновление столбцов первичного ключа|Столбцы первичного ключа в оптимизированных для памяти таблицах и табличных типах нельзя обновить. Если первичный ключ должен быть обновлен, удалите старую строку и вставьте новую строку с обновленным первичным ключом.|  
|Операция|CREATE INDEX|Индексы в оптимизированных для памяти таблицах необходимо указывать в инструкции `CREATE TABLE`. Чтобы добавить индекс к оптимизированной для памяти таблице, следует удалить и повторно создать таблицу, включив в нее новую спецификацию индекса.|  
|Операция|ALTER TABLE|Изменение оптимизированных для памяти таблиц не поддерживается. Удалите и повторно создайте таблицу с использованием обновленного определения.|  
|Операция|CREATE FULLTEXT INDEX|Полнотекстовые индексы не поддерживаются с оптимизированными для памяти таблицами.|  
|Операция|изменение схемы|Оптимизированные для памяти таблицы и скомпилированные хранимые процедуры не поддерживают изменения схемы, например `sp_rename`.<br /><br /> При попытке внести изменения в схему (в частности, переименовать таблицу) возникает ошибка 12320: «Операции, требующие изменения версии схемы, например переименования, не поддерживаются с таблицами, оптимизированными для памяти».<br /><br /> Чтобы изменить схему, удалите и создайте таблицу или процедуру повторно с использованием обновленного определения.|  
|Операция|CREATE TRIGGER|Триггеры в оптимизированных для памяти таблицах не поддерживаются.|  
|Операция|TRUNCATE TABLE|Операция TRUNCATE не поддерживается для оптимизированных для памяти таблиц. Чтобы удалить все строки из таблицы, удалите все строки с помощью `DELETE FROM` *таблицы* или удалите и заново создайте таблицу.|  
|Операция|ALTER AUTHORIZATION|Изменение владельца существующей оптимизированной для памяти таблицы или скомпилированной хранимой процедуры не поддерживается. Для изменения владельца удалите и заново создайте таблицу или процедуру.|  
|Операция|ALTER SCHEMA|Изменение схемы существующей, оптимизированной для памяти таблицы или скомпилированной хранимой процедуры не поддерживается. Для изменения схемы удалите и создайте повторно таблицу или процедуру.|  
|Операция|DBCC CHECKTABLE|DBCC CHECKTABLE не поддерживается для таблиц, оптимизированных для памяти.|  
|Компонент|ANSI_PADDING OFF|Параметр сеанса `ANSI_PADDING` должен быть установлен в ON при создании оптимизированной для памяти таблицы или скомпилированной хранимой процедуры. Выполните `SET ANSI_PADDING ON` перед выполнением инструкции CREATE.|  
|Параметр|DATA_COMPRESSION|Сжатие данных не поддерживается для оптимизированных для памяти таблиц. Удалите выбранный параметр из определения таблицы.|  
|Компонент|DTC|Оптимизированные для памяти таблицы и скомпилированные хранимые процедуры недоступны из распределенных транзакций. Вместо этого используйте транзакции SQL.|  
|Компонент|Режим MARS|Режим MARS не поддерживается для оптимизированных для памяти таблиц. Эта ошибка может также указывать на использование связанного сервера. Связанный сервер может использовать режим MARS. Связанные серверы не поддерживаются для оптимизированных для памяти таблиц. Вместо этого непосредственное подключайтесь к серверу и базе данных, где размещаются оптимизированные для памяти таблицы.|  
|Операция|Оптимизированные для памяти таблицы в качестве назначения MERGE|Оптимизированные для памяти таблицы не могут быть целью операции `MERGE`. Вместо этого используйте инструкции `INSERT`, `UPDATE` или `DELETE`.|  
  
## <a name="indexes-on-memory-optimized-tables"></a>Индексы для оптимизированных для памяти таблиц  
 В следующей таблице перечислены функции и ключевые слова [!INCLUDE[tsql](../../includes/tsql-md.md)] , которые могут присутствовать в тексте ошибки, связанной с индексом оптимизированной для памяти таблицы, а также действия по исправлению данной ошибки.  
  
|Тип|Имя|Решение|  
|----------|----------|----------------|  
|Компонент|Фильтруемый индекс|Отфильтрованные индексы для таблиц, оптимизированных для памяти, не поддерживаются. Пропустите предложение `WHERE` из определения индекса.|  
|Признак|UNIQUE|Уникальные индексы не поддерживаются с оптимизированными для памяти таблицами. Удалите аргумент `UNIQUE` из спецификации индекса.|  
|Компонент|Столбцы, допускающие значения null|Все столбцы в ключе индекса оптимизированной для памяти таблицы должны быть определены как `NOT NULL`. Включите ограничение `NOT NULL` для всех столбцов в ключах индекса.|  
|Компонент|параметры сортировки non-bin2|Все символьные столбцы в ключе оптимизированного для памяти индекса должны быть объявлены с параметрами сортировки BIN2. Для задания параметров сортировки в определении столбца используйте предложение `COLLATE`. Дополнительные сведения см. в разделе [Collations and Code Pages](../../database-engine/collations-and-code-pages.md).|  
|Компонент|Включенные столбцы|Указывать включенные столбцы в отношении оптимизированных для памяти таблиц не требуется. Все столбцы оптимизированной для памяти таблицы неявно включаются в каждый оптимизированный для памяти индекс.|  
|Операция|ALTER INDEX|Добавление индексов к таблицам, оптимизированным для памяти, не поддерживается. Вместо этого удалите и создайте таблицу повторно с обновленной спецификацией индекса.|  
|Операция|DROP INDEX|Удаление индексов к таблицам, оптимизированным для памяти, не поддерживается. Вместо этого удалите и создайте таблицу повторно с нужным индексом.|  
|Параметр индекса|*Параметр индекса*|Указанный параметр индекса не поддерживается для оптимизированных для памяти таблиц. Удалите параметр из спецификации индекса.|  
  
## <a name="nonclustered-hash-indexes"></a>Некластеризованные хэш-индексы  
 В следующей таблице перечислены функции и ключевые слова [!INCLUDE[tsql](../../includes/tsql-md.md)] , которые могут присутствовать в тексте ошибки, связанной с некластеризованным хэш-индексом, а также действия по исправлению данной ошибки.  
  
|Тип|Имя|Решение|  
|----------|----------|----------------|  
|Параметр|ASC/DESC|Некластеризованные хэш-индексы не упорядочиваются. Удалите ключевые слова `ASC` и `DESC` из спецификации ключа индекса.|  
  
## <a name="natively-compiled-stored-procedures"></a>скомпилированные в собственном коде хранимые процедуры  
 В следующей таблице перечислены функции и ключевые слова [!INCLUDE[tsql](../../includes/tsql-md.md)], которые могут присутствовать в тексте ошибки, связанной со скомпилированной хранимой процедурой, а также действия по исправлению данной ошибки.  
  
|Тип|Компонент|Решение|  
|----------|-------------|----------------|  
|Компонент|Встроенные табличные переменные|Табличные типы нельзя объявлять как встроенные с объявлениями переменных. Табличные типы должны быть объявлены явно с помощью инструкции `CREATE TYPE`.|  
|Компонент|Курсоры|Курсоры не поддерживаются в пределах хранимых процедур, скомпилированных в собственном коде.<br /><br /> — При выполнении процедуры с клиента используйте RPC, а не API курсора. Что касается ODBC, то избегайте инструкции [!INCLUDE[tsql](../../includes/tsql-md.md)]; вместо нее напрямую укажите имя процедуры `EXECUTE`.<br /><br /> — При выполнении процедуры из [!INCLUDE[tsql](../../includes/tsql-md.md)] пакета или другой хранимой процедуры следует избегать использования курсора с хранимой процедурой, скомпилированной в собственном файле.<br /><br /> — При создании хранимой процедуры, скомпилированной в собственном режиме, вместо использования курсора используйте логику на основе наборов или `WHILE` цикл.|  
|Компонент|Неконстантные значения по умолчанию для параметров|При использовании значений по умолчанию с параметрами для скомпилированных хранимых процедур эти значения должны быть константами. Удалите все шаблоны из определений параметров.|  
|Компонент|EXTERNAL|Хранимые процедуры CLR нельзя скомпилировать в собственном коде. Удалите предложение AS EXTERNAL или параметр NATIVE_COMPILATION в инструкции CREATE PROCEDURE.|  
|Компонент|Нумерованные хранимые процедуры|Изначально скомпилированные хранимые процедуры нельзя пронумеровать. Удалите `;` *число* из `CREATE PROCEDURE` оператора.|  
|Компонент|Многостроковые инструкции INSERT ... INSERT … VALUES|Нельзя вставить несколько строк с использованием одной и той же инструкции `INSERT` в скомпилированной хранимой процедуре. Создайте инструкции `INSERT` для каждой строки.|  
|Компонент|Обобщенные табличные выражения|Обобщенные табличные выражения (CTE) не поддерживаются в скомпилированных хранимых процедурах. Заново составить запрос.|  
|Компонент|вложенный запрос|Вложенные запросы (запросы внутри других запросов) не поддерживаются. Заново составить запрос.|  
|Компонент|COMPUTE|Предложение `COMPUTE` не поддерживается. Удалите его из запроса.|  
|Компонент|SELECT INTO|Предложение `INTO` в инструкции `SELECT` не поддерживается. Перепишите запрос как `INSERT INTO` *таблицу* `SELECT` .|  
|Признак|OUTPUT|Предложение `OUTPUT` не поддерживается. Удалите его из запроса.|  
|Компонент|неполный список вставки столбцов|В инструкциях `INSERT` необходимо указать значения для всех столбцов таблицы.|  
|Компонент|*Компонент*|Встроенная функция не поддерживается в скомпилированных хранимых процедурах. Удалите функцию из хранимой процедуры. Дополнительные сведения о поддерживаемых встроенных функциях см. в разделе [хранимые процедуры, скомпилированные в собственном](../in-memory-oltp/natively-compiled-stored-procedures.md)режиме.|  
|Компонент|CASE|Инструкция `CASE` не поддерживается в запросах внутри скомпилированных хранимых процедур. Создайте запросы для каждого случая. Дополнительные сведения см. [в разделе Реализация оператора case](implementing-a-case-expression-in-a-natively-compiled-stored-procedure.md).|  
|Компонент|определяемые пользователем функции|Нельзя использовать определяемые пользователем функции в скомпилированных хранимых процедурах. Удалите ссылку на функцию из определения процедуры.|  
|Компонент|пользовательские агрегаты|Определяемые пользователем агрегатные функции нельзя использовать в скомпилированных хранимых процедурах. Удалите ссылку на функцию из процедуры.|  
|Компонент|режим просмотра метаданных|Скомпилированные хранимые процедуры не поддерживают режима обзора метаданных. Убедитесь, что параметр сеанса `NO_BROWSETABLE` установлен в значение OFF.|  
|Компонент|Инструкции DELETE с предложением FROM|В хранимых процедурах, скомпилированных в собственном коде, предложение `FROM` в инструкциях `DELETE` с таблицей-источником не поддерживается.<br /><br /> `DELETE` с предложением `FROM` поддерживается только в том случае, если она используется для указания таблицы, из которой производится удаление.|  
|Компонент|UPDATE с предложением FROM|Предложение `FROM` не поддерживается в инструкциях `UPDATE` скомпилированных хранимых процедур.|  
|Компонент|временные процедуры|Временные хранимые процедуры нельзя скомпилировать в собственном коде. Создайте долговременную скомпилированную хранимую процедуру или временную интерпретируемую хранимую процедуру [!INCLUDE[tsql](../../includes/tsql-md.md)] .|  
|Уровень изоляции|READ UNCOMMITTED|Уровень изоляции READ UNCOMMITTED не поддерживается для скомпилированных хранимых процедур. Используйте поддерживаемый уровень изоляции, например SNAPSHOT.|  
|Уровень изоляции|READ COMMITTED|Уровень изоляции READ UNCOMMITTED не поддерживается для скомпилированных хранимых процедур. Используйте поддерживаемый уровень изоляции, например SNAPSHOT.|  
|Компонент|временные таблицы|Таблицы в базе данных tempdb нельзя использовать в скомпилированных хранимых процедурах. Вместо этого используйте табличную переменную или оптимизированную для памяти таблицу с DURABILITY=SCHEMA_ONLY.|  
|Компонент|MARS|Режим MARS не поддерживается со скомпилированными хранимыми процедурами. Эта ошибка может также указывать на использование связанного сервера. Связанный сервер может использовать режим MARS. Связанные серверы не поддерживаются для скомпилированных хранимых процедур. Вместо этого непосредственно подключитесь к серверу и базе данных, где размещаются скомпилированные хранимые процедуры.|  
|Компонент|DTC|Оптимизированные для памяти таблицы и скомпилированные хранимые процедуры недоступны из распределенных транзакций. Вместо этого используйте транзакции SQL.|  
|Компонент|параметры сортировки non-bin2|Сравнение, сортировка и другие операции на символьных строках в скомпилированных хранимых процедурах требуют использования параметров сортировки BIN2. Используйте предложение COLLATE или столбцы и переменные с соответствующими параметрами сортировки. Дополнительные сведения см. в разделе [Collations and Code Pages](../../database-engine/collations-and-code-pages.md).|  
|Признак|Усечение символьных строк с параметрами сортировки SC.|Символьные строки с параметрами сортировки `_SC` используют кодировку UTF-16. Преобразование значения n(var)char в значение n(var)char с меньшей длиной приведет к усечению данных. Это не поддерживается для значений UTF-16 в скомпилированных хранимых процедурах. Избегайте усечения строк UTF-16.|  
|Компонент|EXECUTE WITH RECOMPILE|Параметр `WITH RECOMPILE` не поддерживается для скомпилированных хранимых процедур.|  
|Признак|LEN и SUBSTRING с аргументом в параметрах сортировки SC|Символьные строки с параметрами сортировки _SC используют кодировку UTF-16. Встроенные функции LEN и SUBSTRING, при использовании внутри скомпилированных в собственном коде хранимых процедур, не поддерживают кодировку UTF-16. Используйте другие параметры сортировки или избегайте использования этих функций.|  
|Компонент|Выполнение из выделенного административного соединения.|Скомпилированные хранимые процедуры не могут быть выполнены из выделенного административного соединения (DAC). Вместо этого используйте обычное соединение.|  
|Операция|ALTER PROCEDURE|Скомпилированные хранимые процедуры нельзя изменить. Чтобы изменить определение процедуры, удалите и заново создайте хранимую процедуру.|  
|Операция|точка сохранения|Скомпилированные хранимые процедуры не могут быть вызваны из транзакции с активной точкой сохранения. Удалите точку сохранения из транзакции.|  
|Операция|ALTER AUTHORIZATION|Изменение владельца существующей оптимизированной для памяти таблицы или скомпилированной хранимой процедуры не поддерживается. Для изменения владельца удалите и заново создайте таблицу или процедуру.|  
|Оператор|OPENROWSET|Данный оператор не поддерживается. Удалите `OPENROWSET` из скомпилированной хранимой процедуры.|  
|Оператор|OPENQUERY|Данный оператор не поддерживается. Удалите `OPENQUERY` из скомпилированной хранимой процедуры.|  
|Оператор|OPENDATASOURCE|Данный оператор не поддерживается. Удалите `OPENDATASOURCE` из скомпилированной хранимой процедуры.|  
|Оператор|OPENXML|Данный оператор не поддерживается. Удалите `OPENXML` из скомпилированной хранимой процедуры.|  
|Оператор|CONTAINSTABLE|Данный оператор не поддерживается. Удалите `CONTAINSTABLE` из скомпилированной хранимой процедуры.|  
|Оператор|FREETEXTTABLE|Данный оператор не поддерживается. Удалите `FREETEXTTABLE` из скомпилированной хранимой процедуры.|  
|Компонент|функции с табличным значением|К функциям с табличным значением не может производиться обращение из скомпилированных хранимых процедур. Одно возможное решение для этого ограничения — добавление логики для функций с табличным значением в текст процедуры.|  
|Оператор|CHANGETABLE|Данный оператор не поддерживается. Удалите `CHANGETABLE` из скомпилированной хранимой процедуры.|  
|Оператор|GOTO|Данный оператор не поддерживается. Используйте другие конструкции, такие как WHILE.|  
|Оператор|EXECUTE, INSERT EXEC|Вложение скомпилированных хранимых процедур не поддерживается. Необходимые операции можно указать как встроенные в определение хранимой процедуры.|  
|Оператор|OFFSET|Данный оператор не поддерживается. Удалите `OFFSET` из скомпилированной хранимой процедуры.|  
|Оператор|UNION|Данный оператор не поддерживается. Удалите `UNION` из скомпилированной хранимой процедуры. Объединение нескольких результирующих наборов в единый набор можно сделать с помощью табличной переменной.|  
|Оператор|INTERSECT|Данный оператор не поддерживается. Удалите `INTERSECT` из скомпилированной хранимой процедуры. В некоторых случаях можно использовать INNER JOIN, чтобы получить тот же результат.|  
|Оператор|EXCEPT|Данный оператор не поддерживается. Удалите `EXCEPT` из скомпилированной хранимой процедуры.|  
|Оператор|OUTER JOIN|Данный оператор не поддерживается. Удалите `OUTER JOIN` из скомпилированной хранимой процедуры. Дополнительные сведения см. в разделе [реализация внешнего объединения](implementing-an-outer-join.md).|  
|Оператор|APPLY|Данный оператор не поддерживается. Удалите `APPLY` из скомпилированной хранимой процедуры.|  
|Оператор|PIVOT|Данный оператор не поддерживается. Удалите `PIVOT` из скомпилированной хранимой процедуры.|  
|Оператор|UNPIVOT|Данный оператор не поддерживается. Удалите `UNPIVOT` из скомпилированной хранимой процедуры.|  
|Оператор|OR, IN|Дизъюнкция (OR, IN) не поддерживается в предложении WHERE запросов в скомпилированных в собственном коде хранимых процедурах. Создайте запросы для каждого из случаев.|  
|Оператор|CONTAINS|Данный оператор не поддерживается. Удалите `CONTAINS` из скомпилированной хранимой процедуры.|  
|Оператор|FREETEXT|Данный оператор не поддерживается. Удалите `FREETEXT` из скомпилированной хранимой процедуры.|  
|Оператор|NOT|Данный оператор не поддерживается. Удалите `NOT` из скомпилированной хранимой процедуры. В некоторых случаях `NOT` можно заменить неравенством. Например, `NOT a=b` можно заменить на `a!=b`.|  
|Оператор|TSEQUAL|Данный оператор не поддерживается. Удалите `TSEQUAL` из скомпилированной хранимой процедуры.|  
|Оператор|LIKE|Данный оператор не поддерживается. Удалите `LIKE` из скомпилированной хранимой процедуры.|  
|Оператор|NEXT VALUE FOR|Из скомпилированных хранимых процедур нельзя обращаться к последовательностям. Получите значение, используя интерпретируемый код [!INCLUDE[tsql](../../includes/tsql-md.md)], а затем передайте его в скомпилированную хранимую процедуру. Дополнительные сведения см. в статье [Реализация IDENTITY в таблице, оптимизированной для памяти](implementing-identity-in-a-memory-optimized-table.md).|  
|Параметр SET|*Параметр*|Параметры SET нельзя изменить внутри скомпилированных хранимых процедур. Некоторые параметры можно задать с помощью инструкции BEGIN ATOMIC. Дополнительные сведения см. в разделе об атомарных блоках в статье [Natively Compiled Stored Procedures](../in-memory-oltp/natively-compiled-stored-procedures.md).|  
|Операнд|TABLESAMPLE|Данный оператор не поддерживается. Удалите `TABLESAMPLE` из скомпилированной хранимой процедуры.|  
|Параметр|RECOMPILE|Компилируемые хранимые процедуры компилируются во время создания. Чтобы перекомпилировать подобную хранимую процедуру, удалите и создайте ее повторно. Удалите `RECOMPILE` из определения процедуры.|  
|Параметр|ENCRYPTION|Этот параметр не поддерживается. Удалите `ENCRYPTION` из определения процедуры.|  
|Параметр|FOR REPLICATION|Скомпилированные хранимые процедуры не могут быть созданы во время репликации. Удалите `FOR REPLICATION` из определения процедуры.|  
|Параметр|FOR XML|Этот параметр не поддерживается. Удалите `FOR XML` из скомпилированной хранимой процедуры.|  
|Параметр|FOR BROWSE|Этот параметр не поддерживается. Удалите `FOR BROWSE` из скомпилированной хранимой процедуры.|  
|Указание соединения|HASH, MERGE|Скомпилированные хранимые процедуры поддерживают только соединения во вложенных циклах. Соединения слиянием и хэша не поддерживаются. Удалите указание соединения.|  
|Указание запроса|*Указание запроса*|Данное указание запроса не находится внутри скомпилированных хранимых процедур. Поддерживаемые указания запросов см. в статье [Указания запросов (Transact-SQL)](/sql/t-sql/queries/hints-transact-sql-query).|  
|Параметр|DISTINCT|Этот параметр не поддерживается. Удалите `DISTINCT` из запроса в скомпилированной хранимой процедуре.|  
|Параметр|PERCENT|Этот параметр не поддерживается с предложениями `TOP`. Удалите `PERCENT` из запроса в скомпилированной хранимой процедуре.|  
|Параметр|WITH TIES|Этот параметр не поддерживается с предложениями `TOP`. Удалите `WITH TIES` из запроса в скомпилированной хранимой процедуре.|  
|Агрегатная функция|*Агрегатная функция*|Данное предложение не поддерживается. Дополнительные сведения об агрегатных функциях в скомпилированных хранимых процедурах см. в разделе [Natively Compiled Stored Procedures](../in-memory-oltp/natively-compiled-stored-procedures.md).|  
|Ранжирующая функция|*Ранжирующая функция*|Ранжирующие функции не поддерживаются в скомпилированных хранимых процедурах. Удалите их из определения процедуры.|  
|Компонент|*Компонент*|Эта функция не поддерживается. Удалите ее из скомпилированной в собственном коде хранимой процедуры.|  
|.|*Инструкция*|Данная инструкция не поддерживается. Удалите ее из скомпилированной в собственном коде хранимой процедуры.|  
|Компонент|Значения MIN и MAX, используемые с двоичными и символьными строками|Агрегатные функции `MIN` и `MAX` нельзя использовать для символьных и двоичных строковых значений в скомпилированных хранимых процедурах.|  
|Признак|GROUP BY без агрегатной функции|В скомпилированных в собственном коде хранимых процедурах, если запрос содержит предложение `GROUP BY`, то должен также использовать агрегатную функцию в предложении SELECT или HAVING. Добавьте агрегатную функцию в запрос.|  
|Компонент|GROUP BY ALL|ALL нельзя использовать с предложениями GROUP BY в скомпилированных в собственном коде хранимых процедурах. Удалите ALL из предложения GROUP BY.|  
|Компонент|GROUP BY ()|Группирование по пустому списку не поддерживается. Либо удалите предложение GROUP BY, либо включите столбцы в список группирования.|  
|Компонент|ROLLUP|`ROLLUP` нельзя использовать с предложениями `GROUP BY` в скомпилированных в собственном коде хранимых процедурах. Удалите `ROLLUP` из определения процедуры.|  
|Компонент|CUBE|`CUBE` нельзя использовать с предложениями `GROUP BY` в скомпилированных в собственном коде хранимых процедурах. Удалите `CUBE` из определения процедуры.|  
|Компонент|GROUPING SETS|`GROUPING SETS` нельзя использовать с предложениями `GROUP BY` в скомпилированных в собственном коде хранимых процедурах. Удалите `GROUPING SETS` из определения процедуры.|  
|Компонент|BEGIN TRANSACTION, COMMIT TRANSACTION и ROLLBACK TRANSACTION|Используйте блоки ATOMIC для управления транзакциями и обработки ошибок. Дополнительные сведения см. в статье [Atomic Blocks](atomic-blocks-in-native-procedures.md).|  
|Компонент|Встроенные объявления табличной переменной.|Табличные переменные должны ссылаться на явно определенные табличные типы с оптимизацией для памяти. Необходимо создать тип оптимизированной для памяти таблицы и использовать этот тип для объявления переменной вместо указания встроенного типа.|  
|Компонент|sp_recompile|Перекомпиляция скомпилированных в собственном коде хранимых процедур не поддерживается. Удалите и создайте повторно процедуру.|  
|Признак|EXECUTE AS CALLER|Предложение `EXECUTE AS` является обязательным. Но `EXECUTE AS CALLER` не поддерживается. Используйте `EXECUTE AS OWNER` , `EXECUTE AS` *User*или `EXECUTE AS SELF` .|  
|Компонент|Таблицы на диске|Доступ к таблицам на диске нельзя осуществлять из скомпилированных в собственном коде хранимых процедур. Удаляйте ссылки на таблицы на диске из скомпилированных в собственном коде хранимых процедур. Либо выполните миграцию таблиц на диске в таблицы, оптимизированные для памяти.|  
|Компонент|Представления|Доступ к представлениям нельзя осуществлять из скомпилированных в собственном коде хранимых процедур. Вместо представлений ссылайтесь на базовые таблицы.|  
|Компонент|Функции с табличным значением|К функциям с табличным значением не может производиться обращение из скомпилированных хранимых процедур. Удаляйте ссылки на функции с табличным значением из скомпилированной в собственном коде хранимой процедуры.|  
  
## <a name="transactions-that-access-memory-optimized-tables"></a>Транзакции, обращающиеся к оптимизированным для памяти таблицам  
 В следующей таблице перечислены функции и ключевые слова [!INCLUDE[tsql](../../includes/tsql-md.md)] , которые могут присутствовать в тексте ошибки, связанной с транзакциями, которые обращаются к оптимизированным для памяти таблицам, а также действия по исправлению данной ошибки.  
  
|Тип|Имя|Решение|  
|----------|----------|----------------|  
|Компонент|точка сохранения|Создание явных точек сохранения в транзакциях, которых обращаются к оптимизированным для памяти таблицам, не поддерживается.|  
|Компонент|привязанная транзакция|Связанные сеансы не могут участвовать в транзакциях, которые обращаются к оптимизированным для памяти таблицам. Не привязывайте сеанс до выполнения процедуры.|  
|Компонент|DTC|Транзакции, осуществляющие доступ к оптимизированным для памяти таблицам, не могут быть распределенными транзакциями.|  
  
## <a name="see-also"></a>См. также:  
 [Миграция в In-Memory OLTP](migrating-to-in-memory-oltp.md)  
  
  

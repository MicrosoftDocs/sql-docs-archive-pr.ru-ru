---
title: Секционированные таблицы и индексы | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
helpviewer_keywords:
- partitioned tables [SQL Server], about partitioned tables
- partitioned indexes [SQL Server], architecture
- partitioned tables [SQL Server], architecture
- partitioned indexes [SQL Server], about partitioned indexes
ms.assetid: cc5bf181-18a0-44d5-8bd7-8060d227c927
author: MikeRayMSFT
ms.author: mikeray
ms.openlocfilehash: e8d041abcfe491f311e38bc8dab4be4ea253e37c
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87739764"
---
# <a name="partitioned-tables-and-indexes"></a><span data-ttu-id="8b463-102">Partitioned Tables and Indexes</span><span class="sxs-lookup"><span data-stu-id="8b463-102">Partitioned Tables and Indexes</span></span>
  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="8b463-103">поддерживает секционирование таблиц и индексов.</span><span class="sxs-lookup"><span data-stu-id="8b463-103">supports table and index partitioning.</span></span> <span data-ttu-id="8b463-104">Данные секционированных таблиц и индексов подразделяются на блоки, которые могут быть распределены по нескольким файловым группам в базе данных.</span><span class="sxs-lookup"><span data-stu-id="8b463-104">The data of partitioned tables and indexes is divided into units that can be spread across more than one filegroup in a database.</span></span> <span data-ttu-id="8b463-105">Данные секционируются горизонтально, поэтому группы строк сопоставляются с отдельными секциями.</span><span class="sxs-lookup"><span data-stu-id="8b463-105">The data is partitioned horizontally, so that groups of rows are mapped into individual partitions.</span></span> <span data-ttu-id="8b463-106">Все секции одного индекса или таблицы должны находиться в одной и той же базе данных.</span><span class="sxs-lookup"><span data-stu-id="8b463-106">All partitions of a single index or table must reside in the same database.</span></span> <span data-ttu-id="8b463-107">Таблица или индекс рассматриваются как единая логическая сущность при выполнении над данными запросов или обновлений.</span><span class="sxs-lookup"><span data-stu-id="8b463-107">The table or index is treated as a single logical entity when queries or updates are performed on the data.</span></span> <span data-ttu-id="8b463-108">Секционированные таблицы и индексы доступны не в каждом выпуске [!INCLUDE[msCoName](../../includes/msconame-md.md)][!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="8b463-108">Partitioned tables and indexes are not available in every edition of [!INCLUDE[msCoName](../../includes/msconame-md.md)][!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="8b463-109">Перечень функций, поддерживаемых в разных выпусках [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], см. в разделе [Features Supported by the Editions of SQL Server 2014](../../getting-started/features-supported-by-the-editions-of-sql-server-2014.md).</span><span class="sxs-lookup"><span data-stu-id="8b463-109">For a list of features that are supported by the editions of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], see [Features Supported by the Editions of SQL Server 2014](../../getting-started/features-supported-by-the-editions-of-sql-server-2014.md).</span></span>  
  
> [!IMPORTANT]  
>  [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] <span data-ttu-id="8b463-110">поддерживает по умолчанию до 15 000 секций.</span><span class="sxs-lookup"><span data-stu-id="8b463-110">supports up to 15,000 partitions by default.</span></span> <span data-ttu-id="8b463-111">В версиях, предшествующих [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], количество секций ограничивалось 1000 по умолчанию. В системах x86 создание таблицы или индекса с числом секций более 1000 возможно, но не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="8b463-111">In versions earlier than [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], the number of partitions was limited to 1,000 by default.On x86-based systems, creating a table or index with more than 1000 partitions is possible, but is not supported.</span></span>  
  
## <a name="benefits-of-partitioning"></a><span data-ttu-id="8b463-112">Преимущества секционирования</span><span class="sxs-lookup"><span data-stu-id="8b463-112">Benefits of Partitioning</span></span>  
 <span data-ttu-id="8b463-113">Секционирование больших таблиц или индексов может дать следующие преимущества в управляемости и производительности.</span><span class="sxs-lookup"><span data-stu-id="8b463-113">Partitioning large tables or indexes can have the following manageability and performance benefits.</span></span>  
  
-   <span data-ttu-id="8b463-114">Это позволяет быстро и эффективно переносить подмножества данных и обращаться к ним, сохраняя при этом целостность набора данных.</span><span class="sxs-lookup"><span data-stu-id="8b463-114">You can transfer or access subsets of data quickly and efficiently, while maintaining the integrity of a data collection.</span></span> <span data-ttu-id="8b463-115">Например, такая операция, как загрузка данных из OLTP в систему OLAP, выполняется за секунды, а не за минуты и часы, как в случае несекционированных данных.</span><span class="sxs-lookup"><span data-stu-id="8b463-115">For example, an operation such as loading data from an OLTP to an OLAP system takes only seconds, instead of the minutes and hours the operation takes when the data is not partitioned.</span></span>  
  
-   <span data-ttu-id="8b463-116">Операции обслуживания можно выполнять быстрее с одной или несколькими секциями.</span><span class="sxs-lookup"><span data-stu-id="8b463-116">You can perform maintenance operations on one or more partitions more quickly.</span></span> <span data-ttu-id="8b463-117">Операции более эффективны, так как выполняются только с поднаборами данных, а не со всей таблицей.</span><span class="sxs-lookup"><span data-stu-id="8b463-117">The operations are more efficient because they target only these data subsets, instead of the whole table.</span></span> <span data-ttu-id="8b463-118">Например, можно сжать данные в одну или несколько секций или перестроить одну или несколько секций индекса.</span><span class="sxs-lookup"><span data-stu-id="8b463-118">For example, you can choose to compress data in one or more partitions or rebuild one or more partitions of an index.</span></span>  
  
-   <span data-ttu-id="8b463-119">Можно повысить скорость выполнения запросов в зависимости от запросов, которые часто выполняются в вашей конфигурации оборудования.</span><span class="sxs-lookup"><span data-stu-id="8b463-119">You may improve query performance, based on the types of queries you frequently run and on your hardware configuration.</span></span> <span data-ttu-id="8b463-120">Например, оптимизатор запросов может быстрее выполнять запросы на эквисоединение двух и более секционированных таблиц, если в этих таблицах одни и те же столбцы секционирования, потому что можно соединить сами секции.</span><span class="sxs-lookup"><span data-stu-id="8b463-120">For example, the query optimizer can process equi-join queries between two or more partitioned tables faster when the partitioning columns in the tables are the same, because the partitions themselves can be joined.</span></span>  
  
     <span data-ttu-id="8b463-121">В процессе сортировки данных для операций ввода-вывода в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] сначала проводится сортировка данных по секциям.</span><span class="sxs-lookup"><span data-stu-id="8b463-121">When [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] performs data sorting for I/O operations, it sorts the data first by partition.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="8b463-122">может одновременно обращаться только к одному диску, что может снизить производительность.</span><span class="sxs-lookup"><span data-stu-id="8b463-122">accesses one drive at a time, and this might reduce performance.</span></span> <span data-ttu-id="8b463-123">Для ускорения сортировки данных рекомендуется распределить файлы данных в секциях по нескольким жестким дискам, создав RAID.</span><span class="sxs-lookup"><span data-stu-id="8b463-123">To improve data sorting performance, stripe the data files of your partitions across more than one disk by setting up a RAID.</span></span> <span data-ttu-id="8b463-124">Таким образом, несмотря на сортировку данных по секциям, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] сможет одновременно осуществлять доступ ко всем жестким дискам каждой секции.</span><span class="sxs-lookup"><span data-stu-id="8b463-124">In this way, although [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] still sorts data by partition, it can access all the drives of each partition at the same time.</span></span>  
  
     <span data-ttu-id="8b463-125">Кроме того, можно повысить производительность, применяя блокировки на уровне секций, а не всей таблицы.</span><span class="sxs-lookup"><span data-stu-id="8b463-125">In addition, you can improve performance by enabling lock escalation at the partition level instead of a whole table.</span></span> <span data-ttu-id="8b463-126">Это может уменьшить количество конфликтов блокировок для таблицы.</span><span class="sxs-lookup"><span data-stu-id="8b463-126">This can reduce lock contention on the table.</span></span>  
  
## <a name="components-and-concepts"></a><span data-ttu-id="8b463-127">Компоненты и основные понятия</span><span class="sxs-lookup"><span data-stu-id="8b463-127">Components and Concepts</span></span>  
 <span data-ttu-id="8b463-128">Следующие термины относятся к секционированию таблиц и индексов.</span><span class="sxs-lookup"><span data-stu-id="8b463-128">The following terms are applicable to table and index partitioning.</span></span>  
  
 <span data-ttu-id="8b463-129">Функция секционирования</span><span class="sxs-lookup"><span data-stu-id="8b463-129">Partition function</span></span>  
 <span data-ttu-id="8b463-130">Объект базы данных, который определяет распределение строк таблицы или индекса по секциям на основе значений определенных столбцов, называемых столбцами секционирования.</span><span class="sxs-lookup"><span data-stu-id="8b463-130">A database object that defines how the rows of a table or index are mapped to a set of partitions based on the values of certain column, called a partitioning column.</span></span> <span data-ttu-id="8b463-131">То есть функция секционирования определяет количество разделов в таблице и как будут определены границы разделов.</span><span class="sxs-lookup"><span data-stu-id="8b463-131">That is, the partition function defines the number of partitions that the table will have and how the boundaries of the partitions are defined.</span></span> <span data-ttu-id="8b463-132">Например, таблицу, содержащую данные заказов на продажу, может потребоваться разделить таблицу на 12 месячных секций по значениям столбца `datetime`, например по дате продаж.</span><span class="sxs-lookup"><span data-stu-id="8b463-132">For example, given a table that contains sales order data, you may want to partition the table into twelve (monthly) partitions based on a `datetime` column such as a sales date.</span></span>  
  
 <span data-ttu-id="8b463-133">Схема секционирования</span><span class="sxs-lookup"><span data-stu-id="8b463-133">Partition scheme</span></span>  
 <span data-ttu-id="8b463-134">Объект базы данных, который сопоставляет секции функции секционирования набору файловых групп.</span><span class="sxs-lookup"><span data-stu-id="8b463-134">A database object that maps the partitions of a partition function to a set of filegroups.</span></span> <span data-ttu-id="8b463-135">Главная причина, по которой секции разделяются по разным файловым группам, заключается в необходимости независимого резервного копирования этих секций,</span><span class="sxs-lookup"><span data-stu-id="8b463-135">The primary reason for placing your partitions on separate filegroups is to make sure that you can independently perform backup operations on partitions.</span></span> <span data-ttu-id="8b463-136">поскольку оно всегда выполняется отдельно для каждой из файловых групп.</span><span class="sxs-lookup"><span data-stu-id="8b463-136">This is because you can perform backups on individual filegroups.</span></span>  
  
 <span data-ttu-id="8b463-137">Столбец секционирования</span><span class="sxs-lookup"><span data-stu-id="8b463-137">Partitioning column</span></span>  
 <span data-ttu-id="8b463-138">Столбец таблицы или индекса, используемый функцией секционирования для секционирования таблицы или индекса.</span><span class="sxs-lookup"><span data-stu-id="8b463-138">The column of a table or index that a partition function uses to partition the table or index.</span></span> <span data-ttu-id="8b463-139">Вычисляемые столбцы, участвующие в функции секционирования, должны быть явно помечены как PERSISTED.</span><span class="sxs-lookup"><span data-stu-id="8b463-139">Computed columns that participate in a partition function must be explicitly marked PERSISTED.</span></span> <span data-ttu-id="8b463-140">Все типы данных, допустимые для использования в качестве индексных столбцов, могут использоваться как столбцы секционирования, за исключением `timestamp`.</span><span class="sxs-lookup"><span data-stu-id="8b463-140">All data types that are valid for use as index columns can be used as a partitioning column, except `timestamp`.</span></span> <span data-ttu-id="8b463-141">Не могут быть указаны типы данных `ntext`, `text`, `image`, `xml`, `varchar(max)`, `nvarchar(max)` и `varbinary(max)`.</span><span class="sxs-lookup"><span data-stu-id="8b463-141">The `ntext`, `text`, `image`, `xml`, `varchar(max)`, `nvarchar(max)`, or `varbinary(max)` data types cannot be specified.</span></span> <span data-ttu-id="8b463-142">Также нельзя указать определяемый пользователем тип данных среды Microsoft .NET Framework CLR и столбцы типа данных псевдонима.</span><span class="sxs-lookup"><span data-stu-id="8b463-142">Also, Microsoft .NET Framework common language runtime (CLR) user-defined type and alias data type columns cannot be specified.</span></span>  
  
 <span data-ttu-id="8b463-143">Выровненный индекс</span><span class="sxs-lookup"><span data-stu-id="8b463-143">Aligned index</span></span>  
 <span data-ttu-id="8b463-144">Индекс, созданный на основе той же схемы секционирования, что и соответствующая таблица.</span><span class="sxs-lookup"><span data-stu-id="8b463-144">An index that is built on the same partition scheme as its corresponding table.</span></span> <span data-ttu-id="8b463-145">Если таблица и ее индексы выровнены, SQL Server может быстро переключаться с секции на секцию, сохраняя при этом структуру секций как таблицы, так и ее индексов.</span><span class="sxs-lookup"><span data-stu-id="8b463-145">When a table and its indexes are in alignment, SQL Server can switch partitions quickly and efficiently while maintaining the partition structure of both the table and its indexes.</span></span> <span data-ttu-id="8b463-146">Для выравнивания с базовой таблицей индексу необязательно использовать функцию секционирования с тем же именем.</span><span class="sxs-lookup"><span data-stu-id="8b463-146">An index does not have to participate in the same named partition function to be aligned with its base table.</span></span> <span data-ttu-id="8b463-147">Однако функции секционирования индекса и базовой таблицы не должны существенно различаться, то есть: 1) аргументы функции секционирования должны иметь один и тот же тип данных, 2) функции должны определять одинаковое количество секций и 3) функции должны определять для секций одинаковые граничные значения.</span><span class="sxs-lookup"><span data-stu-id="8b463-147">However, the partition function of the index and the base table must be essentially the same, in that 1) the arguments of the partition functions have the same data type, 2) they define the same number of partitions, and 3) they define the same boundary values for partitions.</span></span>  
  
 <span data-ttu-id="8b463-148">Невыровненный индекс</span><span class="sxs-lookup"><span data-stu-id="8b463-148">Nonaligned index</span></span>  
 <span data-ttu-id="8b463-149">Индекс, секционированный независимо от соответствующей таблицы.</span><span class="sxs-lookup"><span data-stu-id="8b463-149">An index partitioned independently from its corresponding table.</span></span> <span data-ttu-id="8b463-150">Т. е. индекс имеет другую схему секционирования или находится не в той файловой группе, где находится базовая таблица.</span><span class="sxs-lookup"><span data-stu-id="8b463-150">That is, the index has a different partition scheme or is placed on a separate filegroup from the base table.</span></span> <span data-ttu-id="8b463-151">Создание невыровненного секционированного индекса может быть полезно в следующих случаях:</span><span class="sxs-lookup"><span data-stu-id="8b463-151">Designing an nonaligned partitioned index can be useful in the following cases:</span></span>  
  
-   <span data-ttu-id="8b463-152">Базовая таблица не секционирована.</span><span class="sxs-lookup"><span data-stu-id="8b463-152">The base table has not been partitioned.</span></span>  
  
-   <span data-ttu-id="8b463-153">Ключ индекса является уникальным и не содержит столбца секционирования таблицы.</span><span class="sxs-lookup"><span data-stu-id="8b463-153">The index key is unique and it does not contain the partitioning column of the table.</span></span>  
  
-   <span data-ttu-id="8b463-154">Требуется участие базовой таблицы в выровненных соединениях с таблицами, использующими другие столбцы соединения.</span><span class="sxs-lookup"><span data-stu-id="8b463-154">You want the base table to participate in collocated joins with more tables using different join columns.</span></span>  
  
 <span data-ttu-id="8b463-155">Устранение секций</span><span class="sxs-lookup"><span data-stu-id="8b463-155">Partition elimination</span></span>  
 <span data-ttu-id="8b463-156">Процесс, в ходе которого оптимизатор запросов обращается только к определенным секциям в соответствии с фильтром запроса.</span><span class="sxs-lookup"><span data-stu-id="8b463-156">The process by which the query optimizer accesses only the relevant partitions to satisfy the filter criteria of the query.</span></span>  
  
## <a name="performance-guidelines"></a><span data-ttu-id="8b463-157">Рекомендации по производительности</span><span class="sxs-lookup"><span data-stu-id="8b463-157">Performance Guidelines</span></span>  
 <span data-ttu-id="8b463-158">Более высокое новое максимальное количество секций (15 000) влияет на память, операции с секционированными индексами, команды DBCC и запросы.</span><span class="sxs-lookup"><span data-stu-id="8b463-158">The new, higher limit of 15,000 partitions affects memory, partitioned index operations, DBCC commands, and queries.</span></span> <span data-ttu-id="8b463-159">В этом разделе показано, как влияет на производительность создание более 1 000 секций и как обойти проблемы.</span><span class="sxs-lookup"><span data-stu-id="8b463-159">This section describes the performance implications of increasing the number of partitions above 1,000 and provides workarounds as needed.</span></span> <span data-ttu-id="8b463-160">Увеличение максимального количества секций до 15 000 позволяет дольше хранить данные.</span><span class="sxs-lookup"><span data-stu-id="8b463-160">With the limit on the maximum number of partitions being increased to 15,000, you can store data for a longer time.</span></span> <span data-ttu-id="8b463-161">Однако рекомендуется хранить данные ровно столько времени, сколько требуется, и поддерживать баланс между производительностью и количеством секций.</span><span class="sxs-lookup"><span data-stu-id="8b463-161">However, you should retain data only for as long as it is needed and maintain a balance between performance and number of partitions.</span></span>  
  
### <a name="memory-usage-and-guidelines"></a><span data-ttu-id="8b463-162">Использование памяти и рекомендации</span><span class="sxs-lookup"><span data-stu-id="8b463-162">Memory Usage and Guidelines</span></span>  
 <span data-ttu-id="8b463-163">При большом количестве используемых секций рекомендуется использовать ОЗУ не менее 16 ГБ.</span><span class="sxs-lookup"><span data-stu-id="8b463-163">We recommend that you use at least 16 GB of RAM if a large number of partitions are in use.</span></span> <span data-ttu-id="8b463-164">Если у системы недостаточно памяти, возможен сбой инструкций языка обработки данных (DML), инструкций языка описания данных (DDL) и других операций из-за нехватки памяти.</span><span class="sxs-lookup"><span data-stu-id="8b463-164">If the system does not have enough memory, Data Manipulation Language (DML) statements, Data Definition Language (DDL) statements and other operations can fail due to insufficient memory.</span></span> <span data-ttu-id="8b463-165">В системах с ОЗУ 16 ГБ и большим количеством процессов, интенсивно использующих память, возможны сбои операций, работающих на большом количестве секций, из-за нехватки памяти.</span><span class="sxs-lookup"><span data-stu-id="8b463-165">Systems with 16 GB of RAM that run many memory-intensive processes may run out of memory on operations that run on a large number of partitions.</span></span> <span data-ttu-id="8b463-166">Поэтому чем больше у вас памяти сверх 16 МБ, тем меньше вероятность проблем с производительностью и памятью.</span><span class="sxs-lookup"><span data-stu-id="8b463-166">Therefore, the more memory you have over 16 GB, the less likely you are to encounter performance and memory issues.</span></span>  
  
 <span data-ttu-id="8b463-167">Ограничения оперативной памяти могут повлиять на производительность или возможность создания секционированного индекса.</span><span class="sxs-lookup"><span data-stu-id="8b463-167">Memory limitations can affect the performance or ability of SQL Server to build a partitioned index.</span></span> <span data-ttu-id="8b463-168">Такое случается, например, когда индекс не выровнен со своей базовой таблицей или со своим кластеризованным индексом, если такой существует в таблице.</span><span class="sxs-lookup"><span data-stu-id="8b463-168">This is especially the case when the index is not aligned with its base table or is not aligned with its clustered index, if the table already has a clustered index applied to it.</span></span>  
  
### <a name="partitioned-index-operations"></a><span data-ttu-id="8b463-169">Операции с секционированными индексами</span><span class="sxs-lookup"><span data-stu-id="8b463-169">Partitioned Index Operations</span></span>  
 <span data-ttu-id="8b463-170">Ограничения оперативной памяти могут повлиять на производительность или возможность создания секционированного индекса.</span><span class="sxs-lookup"><span data-stu-id="8b463-170">Memory limitations can affect the performance or ability of SQL Server to build a partitioned index.</span></span> <span data-ttu-id="8b463-171">Это особенно относится к невыровненным индексам.</span><span class="sxs-lookup"><span data-stu-id="8b463-171">This is especially the case with nonaligned indexes.</span></span> <span data-ttu-id="8b463-172">Создание и перестройка невыровненных индексов для таблицы, количество секций в которой превышает 1000, возможны, но не поддерживаются.</span><span class="sxs-lookup"><span data-stu-id="8b463-172">Creating and rebuilding nonaligned indexes on a table with more than 1,000 partitions is possible, but is not supported.</span></span> <span data-ttu-id="8b463-173">Это может привести к снижению производительности или чрезмерному потреблению памяти во время таких операций.</span><span class="sxs-lookup"><span data-stu-id="8b463-173">Doing so may cause degraded performance or excessive memory consumption during these operations.</span></span>  
  
 <span data-ttu-id="8b463-174">Создание и перестройка выровненных индексов может занимать больше времени по мере увеличения количества секций.</span><span class="sxs-lookup"><span data-stu-id="8b463-174">Creating and rebuilding aligned indexes could take longer to execute as the number of partitions increases.</span></span> <span data-ttu-id="8b463-175">Не рекомендуется выполнять одновременно несколько команд создания и перестройки индекса, так как возможны проблемы с производительностью и памятью.</span><span class="sxs-lookup"><span data-stu-id="8b463-175">We recommend that you do not run multiple create and rebuild index commands at the same time as you may run into performance and memory issues.</span></span>  
  
 <span data-ttu-id="8b463-176">Когда компонент SQL Server выполняет сортировку для создания секционированных индексов, сначала он создает по одной таблице сортировки для каждой секции.</span><span class="sxs-lookup"><span data-stu-id="8b463-176">When SQL Server performs sorting to build partitioned indexes, it first builds one sort table for each partition.</span></span> <span data-ttu-id="8b463-177">Затем он создает таблицы сортировки в соответствующей файловой группе каждой секции или в `tempdb`, если задан параметр SORT_IN_TEMPDB.</span><span class="sxs-lookup"><span data-stu-id="8b463-177">It then builds the sort tables either in the respective filegroup of each partition or in `tempdb`, if the SORT_IN_TEMPDB index option is specified.</span></span> <span data-ttu-id="8b463-178">Для всех таблиц сортировки требуется минимальный объем оперативной памяти.</span><span class="sxs-lookup"><span data-stu-id="8b463-178">Each sort table requires a minimum amount of memory to build.</span></span> <span data-ttu-id="8b463-179">При построении секционированного индекса, выровненного со своей базовой таблицей, таблицы сортировки создаются по одной за раз, экономно расходуя оперативную память.</span><span class="sxs-lookup"><span data-stu-id="8b463-179">When you are building a partitioned index that is aligned with its base table, sort tables are built one at a time, using less memory.</span></span> <span data-ttu-id="8b463-180">Однако при построении невыровненного секционированного индекса таблицы сортировки создаются одновременно.</span><span class="sxs-lookup"><span data-stu-id="8b463-180">However, when you are building a nonaligned partitioned index, the sort tables are built at the same time.</span></span> <span data-ttu-id="8b463-181">В результате необходим достаточный объем оперативной памяти, чтобы параллельно их обрабатывать.</span><span class="sxs-lookup"><span data-stu-id="8b463-181">As a result, there must be sufficient memory to handle these concurrent sorts.</span></span> <span data-ttu-id="8b463-182">Чем больше число секций, тем больше требуется оперативной памяти.</span><span class="sxs-lookup"><span data-stu-id="8b463-182">The larger the number of partitions, the more memory required.</span></span> <span data-ttu-id="8b463-183">Для каждой из секций размер таблицы сортировки составляет не менее 40 страниц, по 8 килобайт каждая.</span><span class="sxs-lookup"><span data-stu-id="8b463-183">The minimum size for each sort table, for each partition, is 40 pages, with 8 kilobytes per page.</span></span> <span data-ttu-id="8b463-184">Например, для невыровненного секционированного индекса, разбитого на 100 секций, потребуется объем оперативной памяти для одновременной сортировки 4 000 страниц (40\*100).</span><span class="sxs-lookup"><span data-stu-id="8b463-184">For example, a nonaligned partitioned index with 100 partitions requires sufficient memory to serially sort 4,000 (40 \* 100) pages at the same time.</span></span> <span data-ttu-id="8b463-185">Если такой объем памяти доступен, операция создания будет выполнена успешно, но может пострадать производительность.</span><span class="sxs-lookup"><span data-stu-id="8b463-185">If this memory is available, the build operation will succeed, but performance may suffer.</span></span> <span data-ttu-id="8b463-186">Если же такой объем памяти недоступен, операция построения завершится ошибкой.</span><span class="sxs-lookup"><span data-stu-id="8b463-186">If this memory is not available, the build operation will fail.</span></span> <span data-ttu-id="8b463-187">Для выровненного секционированного индекса, разбитого на 100 секций, для сортировки потребуется всего 40 страниц, поскольку сортировки осуществляются не одновременно.</span><span class="sxs-lookup"><span data-stu-id="8b463-187">Alternatively, an aligned partitioned index with 100 partitions requires only sufficient memory to sort 40 pages, because the sorts are not performed at the same time.</span></span>  
  
 <span data-ttu-id="8b463-188">Как для выровненных, так и для невыровненных индексов может потребоваться больше оперативной памяти, если SQL Server применяет степени параллелизма для операции создания на многопроцессорном компьютере.</span><span class="sxs-lookup"><span data-stu-id="8b463-188">For both aligned and nonaligned indexes, the memory requirement can be greater if SQL Server is applying degrees of parallelism to the build operation on a multiprocessor computer.</span></span> <span data-ttu-id="8b463-189">Чем больше степень параллелизма, тем больше требуется оперативной памяти.</span><span class="sxs-lookup"><span data-stu-id="8b463-189">This is because the greater the degrees of parallelism, the greater the memory requirement.</span></span> <span data-ttu-id="8b463-190">Например, если SQL Server задает степень параллелизма 4, то невыровненному секционированному индексу со 100 секциями потребуется такой объем памяти, чтобы четыре процессора могли одновременно отсортировать по 4 000 страниц, то есть 16 000 страниц.</span><span class="sxs-lookup"><span data-stu-id="8b463-190">For example, if SQL Server sets degrees of parallelism to 4, a nonaligned partitioned index with 100 partitions requires sufficient memory for four processors to sort 4,000 pages at the same time, or 16,000 pages.</span></span> <span data-ttu-id="8b463-191">Если секционированный индекс выровнен, требования оперативной памяти снижаются до 40 страниц для каждого из четырех процессоров, то есть 160 страниц (4\*40).</span><span class="sxs-lookup"><span data-stu-id="8b463-191">If the partitioned index is aligned, the memory requirement is reduced to four processors sorting 40 pages, or 160 (4 \* 40) pages.</span></span> <span data-ttu-id="8b463-192">С помощью параметра индекса MAXDOP можно вручную снизить степень параллелизма.</span><span class="sxs-lookup"><span data-stu-id="8b463-192">You can use the MAXDOP index option to manually reduce the degrees of parallelism.</span></span>  
  
### <a name="dbcc-commands"></a><span data-ttu-id="8b463-193">Команды DBCC</span><span class="sxs-lookup"><span data-stu-id="8b463-193">DBCC Commands</span></span>  
 <span data-ttu-id="8b463-194">При большем количестве секций выполнение команд DBCC может занимать больше времени по мере увеличения количества секций.</span><span class="sxs-lookup"><span data-stu-id="8b463-194">With a larger number of partitions, DBCC commands could take longer to execute as the number of partitions increases.</span></span>  
  
### <a name="queries"></a><span data-ttu-id="8b463-195">Запросы</span><span class="sxs-lookup"><span data-stu-id="8b463-195">Queries</span></span>  
 <span data-ttu-id="8b463-196">Запросы, использующие функцию устранения секций, могут иметь сопоставимую или более высокую производительность с большим числом секций.</span><span class="sxs-lookup"><span data-stu-id="8b463-196">Queries that use partition elimination could have comparable or improved performance with larger number of partitions.</span></span> <span data-ttu-id="8b463-197">Запросы, не использующие функцию устранения секций, могут занимать больше времени по мере увеличения количества секций.</span><span class="sxs-lookup"><span data-stu-id="8b463-197">Queries that do not use partition elimination could take longer to execute as the number of partitions increases.</span></span>  
  
 <span data-ttu-id="8b463-198">Предположим, таблица имеет 100 миллионов строк и столбцов `A`, `B`и `C`.</span><span class="sxs-lookup"><span data-stu-id="8b463-198">For example, assume a table has 100 million rows and columns `A`, `B`, and `C`.</span></span> <span data-ttu-id="8b463-199">В примере 1 таблица делится на 1000 секций по столбцу `A`.</span><span class="sxs-lookup"><span data-stu-id="8b463-199">In scenario 1, the table is divided into 1000 partitions on column `A`.</span></span> <span data-ttu-id="8b463-200">В примере 2 таблица делится на 10,000 секций по столбцу `A`.</span><span class="sxs-lookup"><span data-stu-id="8b463-200">In scenario 2, the table is divided into 10,000 partitions on column `A`.</span></span> <span data-ttu-id="8b463-201">Запрос к таблице, включающий предложение WHERE с фильтром по столбцу `A` , выполнит функцию устранения секций и просканирует одну секцию.</span><span class="sxs-lookup"><span data-stu-id="8b463-201">A query on the table that has a WHERE clause filtering on column `A` will perform partition elimination and scan one partition.</span></span> <span data-ttu-id="8b463-202">Тот же самый запрос может быть выполнен быстрее в примере 2, так как в секции меньше строк для сканирования.</span><span class="sxs-lookup"><span data-stu-id="8b463-202">That same query may run faster in scenario 2 as there are fewer rows to scan in a partition.</span></span> <span data-ttu-id="8b463-203">Запрос, включающий предложение WHERE с фильтром по столбцу B, будет сканировать все секции.</span><span class="sxs-lookup"><span data-stu-id="8b463-203">A query that has a WHERE clause filtering on column B will scan all partitions.</span></span> <span data-ttu-id="8b463-204">В примере 1 этот запрос может быть выполнен быстрее, чем в примере 2, так как в этом случае меньше секций для сканирования.</span><span class="sxs-lookup"><span data-stu-id="8b463-204">The query may run faster in scenario 1 than in scenario 2 as there are fewer partitions to scan.</span></span>  
  
 <span data-ttu-id="8b463-205">Запросы, в которых используются такие операторы, как TOP или MAX/MIN, в столбцах, отличных от столбца секционирования, могут столкнуться со снижением производительности при секционировании, поскольку вычисляться должны все секции.</span><span class="sxs-lookup"><span data-stu-id="8b463-205">Queries that use operators such as TOP or MAX/MIN on columns other than the partitioning column may experience reduced performance with partitioning because all partitions must be evaluated.</span></span>  
  
## <a name="behavior-changes-in-statistics-computation-during-partitioned-index-operations"></a><span data-ttu-id="8b463-206">Изменения в поведении при статистических вычислениях во время операций с секционированным индексом</span><span class="sxs-lookup"><span data-stu-id="8b463-206">Behavior Changes in Statistics Computation During Partitioned Index Operations</span></span>  
 <span data-ttu-id="8b463-207">Начиная с [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], статистические данные не создаются путем сканирования всех строк таблицы при создании или перестроении секционированного индекса.</span><span class="sxs-lookup"><span data-stu-id="8b463-207">Beginning with [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], statistics are not created by scanning all the rows in the table when a partitioned index is created or rebuilt.</span></span> <span data-ttu-id="8b463-208">Вместо этого оптимизатор запросов использует для создания статистики алгоритм выборки по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="8b463-208">Instead, the query optimizer uses the default sampling algorithm to generate statistics.</span></span> <span data-ttu-id="8b463-209">После обновления базы данных с секционированными индексами можно заметить разницу в гистограммах для этих индексов.</span><span class="sxs-lookup"><span data-stu-id="8b463-209">After upgrading a database with partitioned indexes, you may notice a difference in the histogram data for these indexes.</span></span> <span data-ttu-id="8b463-210">Это изменение в поведении может не влиять на время выполнения запросов.</span><span class="sxs-lookup"><span data-stu-id="8b463-210">This change in behavior may not affect query performance.</span></span> <span data-ttu-id="8b463-211">Для получения статистики по секционированным индексам путем сканирования всех строк таблицы используйте инструкции CREATE STATISTICS или UPDATE STATISTICS с предложением FULLSCAN.</span><span class="sxs-lookup"><span data-stu-id="8b463-211">To obtain statistics on partitioned indexes by scanning all the rows in the table, use CREATE STATISTICS or UPDATE STATISTICS with the FULLSCAN clause.</span></span>  
  
## <a name="related-tasks"></a><span data-ttu-id="8b463-212">Связанные задачи</span><span class="sxs-lookup"><span data-stu-id="8b463-212">Related Tasks</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="8b463-213">**Задачи**</span><span class="sxs-lookup"><span data-stu-id="8b463-213">**Tasks**</span></span>|<span data-ttu-id="8b463-214">**Раздел**</span><span class="sxs-lookup"><span data-stu-id="8b463-214">**Topic**</span></span>|  
|<span data-ttu-id="8b463-215">Описано, как создать функции секционирования и схемы секционирования и применить их к таблице или индексу.</span><span class="sxs-lookup"><span data-stu-id="8b463-215">Describes how to create partition functions and partition schemes and then apply these to a table and index.</span></span>|[<span data-ttu-id="8b463-216">Создание секционированных таблиц и индексов</span><span class="sxs-lookup"><span data-stu-id="8b463-216">Create Partitioned Tables and Indexes</span></span>](create-partitioned-tables-and-indexes.md)|  
|||  
  
## <a name="related-content"></a><span data-ttu-id="8b463-217">См. также</span><span class="sxs-lookup"><span data-stu-id="8b463-217">Related Content</span></span>  
 <span data-ttu-id="8b463-218">Следующие публикации по стратегиям секционированных таблиц и индексов и примеры внедрения могут оказаться полезными.</span><span class="sxs-lookup"><span data-stu-id="8b463-218">You may find the following white papers on partitioned table and index strategies and implementations useful.</span></span>  
  
-   <span data-ttu-id="8b463-219">[Partitioned Table and Index Strategies Using SQL Server 2008](https://msdn.microsoft.com/library/dd578580\(SQL.100\).aspx)</span><span class="sxs-lookup"><span data-stu-id="8b463-219">[Partitioned Table and Index Strategies Using SQL Server 2008](https://msdn.microsoft.com/library/dd578580\(SQL.100\).aspx)</span></span>  
  
-   <span data-ttu-id="8b463-220">[How to Implement an Automatic Sliding Window in a Partitioned Table on SQL Server 2005](https://msdn.microsoft.com/library/aa964122\(SQL.90\).aspx)</span><span class="sxs-lookup"><span data-stu-id="8b463-220">[How to Implement an Automatic Sliding Window](https://msdn.microsoft.com/library/aa964122\(SQL.90\).aspx)</span></span>  
  
-   [<span data-ttu-id="8b463-221">Массовая загрузка в секционированную таблицу</span><span class="sxs-lookup"><span data-stu-id="8b463-221">Bulk Loading into a Partitioned Table</span></span>](https://msdn.microsoft.com/library/cc966380.aspx)  
  
-   [<span data-ttu-id="8b463-222">Улучшенные возможности обработки запросов для секционированных таблиц и индексов</span><span class="sxs-lookup"><span data-stu-id="8b463-222">Query Processing Enhancements on Partitioned Tables and Indexes</span></span>](https://msdn.microsoft.com/library/ms345599.aspx)  
  
-   [<span data-ttu-id="8b463-223">10 лучших методов для построения реляционного хранилища данных в больших масштабах</span><span class="sxs-lookup"><span data-stu-id="8b463-223">Top 10 Best Practices for Building a Large Scale Relational Data Warehouse</span></span>](http://sqlcat.com/top10lists/archive/2008/02/06/top-10-best-practices-for-building-a-large-scale-relational-data-warehouse.aspx)  
  
  

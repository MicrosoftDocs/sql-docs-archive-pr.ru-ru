---
title: Регистрация определяемых пользователем типов в SQL Server | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: clr
ms.topic: reference
dev_langs:
- TSQL
helpviewer_keywords:
- UDTs [CLR integration], maintaining
- user-defined types [CLR integration], maintaining
- dependencies [CLR integration]
- deploying user-defined types [CLR integration]
- CurrencyConversion function
- user-defined types [CLR integration], deploying
- Transact-SQL deploying UDTs
- assemblies [CLR integration], user-defined types
- cross-database UDT support
- CREATE ASSEMBLY statement
- DROP TYPE statement
- Currency UDT
- CREATE TYPE statement
- registering user-defined types
- UDTs [CLR integration], deploying
- removing user-defined types
- user-defined types [CLR integration], registering
- ALTER ASSEMBLY statement
- UDTs [CLR integration], registering
- ADD FILE clause
ms.assetid: f7da3e92-e407-4f0b-b3a3-f214e442b37d
author: rothja
ms.author: jroth
ms.openlocfilehash: 7d24f7948e093335eff708f3c4a8a7361cfc156f
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87656426"
---
# <a name="registering-user-defined-types-in-sql-server"></a>Регистрация определяемых пользователем типов в SQL Server
  Чтобы использовать определяемый пользователем тип (UDT) в [!INCLUDE[msCoName](../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] , его необходимо зарегистрировать. Регистрация определяемого пользователем типа включает регистрацию сборки и создание типа в базе данных, в которой его нужно использовать. Определяемые пользователем типы находятся в одной базе данных и не могут использоваться в нескольких базах данных, пока идентичная сборка и определяемый пользователем тип не будут зарегистрированы в каждой базе данных. После регистрации сборки определяемого пользователем типа и создания типа этот тип можно использовать в [!INCLUDE[tsql](../../includes/tsql-md.md)] и клиентском коде. Дополнительные сведения об определяемых пользователем типах данных CLR см. в разделе [Определяемые пользователем типы данных CLR](clr-user-defined-types.md).  
  
## <a name="using-visual-studio-to-deploy-udts"></a>Использование среды Visual Studio для развертывания определяемых пользователем типов  
 Самым простым способом развертывания определяемого пользователем типа является использование среды [!INCLUDE[msCoName](../../includes/msconame-md.md)] Visual Studio. Однако для более сложных сценариев развертывания и большей гибкости используется язык [!INCLUDE[tsql](../../includes/tsql-md.md)], как описано далее в этом разделе.  
  
 Для создания и развертывания определяемых пользователем типов с помощью среды Visual Studio выполните следующие шаги.  
  
1.  Создайте новый проект **базы данных** на узлах языка **Visual Basic** или **Visual C#** .  
  
2.  Добавьте ссылку на базу данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], содержащую определяемый пользователем тип.  
  
3.  Добавьте класс **определяемого пользователем типа** .  
  
4.  Напишите код для реализации определяемого пользователем типа.  
  
5.  В меню **Сборка** выберите пункт **развернуть**. Эта команда регистрирует сборку и создает тип в базе данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].  
  
## <a name="using-transact-sql-to-deploy-udts"></a>Использование Transact-SQL для развертывания определяемых пользователем типов  
 Синтаксис CREATE ASSEMBLY языка [!INCLUDE[tsql](../../includes/tsql-md.md)] используется для регистрации сборки в базе данных, в которой требуется использование определяемого пользователем типа. Он хранится внутри системных таблиц базы данных, а во внешней файловой системе. Если определяемый пользователем тип зависит от внешних сборок, их тоже необходимо загрузить в базу данных. Инструкция CREATE TYPE используется для создания определяемого пользователем типа в базе данных, в которой он будет использоваться. Дополнительные сведения см. в статьях [Создание сборки &#40;&#41;Transact-SQL](/sql/t-sql/statements/create-assembly-transact-sql) и [Создание типа &#40;transact-SQL&#41;](/sql/t-sql/statements/create-type-transact-sql).  
  
### <a name="using-create-assembly"></a>Использование инструкции CREATE ASSEMBLY  
 Инструкция CREATE ASSEMBLY регистрирует сборку в базе данных, в которой требуется использование определяемого пользователем типа. После регистрации сборки она не имеет зависимостей.  
  
 Создание нескольких версий одной сборки в одной базе данных не допускается. Однако возможно создание нескольких версий одной сборки, зависящих от культуры данной базы данных. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] разделяет несколько культурных версий сборки по разным именам, зарегистрированным в экземпляре [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Дополнительные сведения см. в разделе «Создание и использование сборок со строгими именами» пакета .NET Framework SDK.  
  
 Если инструкция CREATE ASSEMBLY выполняется с наборами разрешений SAFE или EXTERNAL_ACCESS, сборка проверяется на совместимость и безопасность типа. Если набор разрешений не указан, предполагается набор разрешений SAFE. Код с набором разрешений UNSAFE не проверяется. Дополнительные сведения о наборах разрешений сборки см. в разделе [Проектирование сборок](../../relational-databases/clr-integration/assemblies-designing.md).  
  
#### <a name="example"></a>Пример  
 Следующая [!INCLUDE[tsql](../../includes/tsql-md.md)] инструкция регистрирует сборку Point в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] базе данных **AdventureWorks** с набором разрешений Сейф. Если предложение WITH PERMISSION_SET не указано, сборка регистрируется с набором разрешений SAFE.  
  
```  
USE AdventureWorks;  
CREATE ASSEMBLY Point  
FROM '\\ShareName\Projects\Point\bin\Point.dll'   
WITH PERMISSION_SET = SAFE;  
```  
  
 Следующая [!INCLUDE[tsql](../../includes/tsql-md.md)] инструкция регистрирует сборку с помощью *<assembly_bits>* аргумент в предложении FROM. Данное значение типа `varbinary` представляет файл в виде потока байтов.  
  
```  
USE AdventureWorks;  
CREATE ASSEMBLY Point  
FROM 0xfeac4 ... 21ac78  
```  
  
### <a name="using-create-type"></a>Использование инструкции CREATE TYPE  
 После загрузки сборки в базу данных можно создать тип с помощью инструкции CREATE TYPE языка [!INCLUDE[tsql](../../includes/tsql-md.md)]. Она добавляет тип в список доступных типов для этой базы данных. Тип имеет область базы данных и может использоваться только в той базе данных, в которой он был создан. Если определяемый пользователем тип уже существует в базе данных, то инструкция CREATE TYPE завершится с ошибкой.  
  
> [!NOTE]  
>  Синтаксис CREATE TYPE также используется для создания собственных псевдонимов типов данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] и предназначен для замены процедуры `sp_addtype` при создании псевдонимов типов данных. Некоторые из дополнительных аргументов в синтаксисе CREATE TYPE служат для создания определяемых пользователем типов и неприменимы для создания псевдонимов типов данных (например базового типа).  
  
 Дополнительные сведения см. в разделе [CREATE TYPE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-type-transact-sql).  
  
#### <a name="example"></a>Пример  
 Следующая инструкция [!INCLUDE[tsql](../../includes/tsql-md.md)] создает тип `Point`. ВНЕШНее имя задается с помощью синтаксиса имен *AssemblyName*, состоящие из двух частей. *Удтнаме*.  
  
```  
CREATE TYPE dbo.Point   
EXTERNAL NAME Point.[Point];  
```  
  
## <a name="removing-a-udt-from-the-database"></a>Удаление определяемого пользователем типа из базы данных  
 Инструкция DROP TYPE удаляет определяемый пользователем тип из текущей базы данных. После удаления определяемого пользователем типа можно инструкцией DROP ASSEMBLY удалить сборку из базы данных.  
  
 Инструкция DROP TYPE не выполняется в следующих ситуациях.  
  
-   Таблицы в базе данных, которые содержат столбцы, определенные с помощью определяемого пользователем типа.  
  
-   Функции, хранимые процедуры или триггеры, которые используют переменные или параметры определяемого пользователем типа и созданы в базе данных с помощью предложения WITH SCHEMABINDING.  
  
### <a name="example"></a>Пример  
 Следующая инструкция [!INCLUDE[tsql](../../includes/tsql-md.md)] должна выполняться в следующем порядке. Сначала необходимо удалить таблицу, которая обращается к определяемому пользователем типу `Point`, затем тип, и, наконец, сборку.  
  
```  
DROP TABLE dbo.Points;  
DROP TYPE dbo.Point;  
DROP ASSEMBLY Point;  
```  
  
### <a name="finding-udt-dependencies"></a>Поиск зависимостей определяемого пользователем типа  
 Если есть зависимые объекты, например таблицы с определениями столбцов определяемых пользователем типов, то инструкция DROP TYPE завершится с ошибкой. Также она завершится с ошибкой, если есть функции, хранимые процедуры или триггеры, созданные в базе данных с помощью предложения WITH SCHEMABINDING, или эти процедуры используют переменные и параметры определяемого пользователем типа. Сначала необходимо удалить все зависимые объекты, а затем выполнить инструкцию DROP TYPE.  
  
 Следующий [!INCLUDE[tsql](../../includes/tsql-md.md)] запрос находит все столбцы и параметры, которые используют определяемый пользователем тип в базе данных **AdventureWorks** .  
  
```  
USE Adventureworks;  
SELECT o.name AS major_name, o.type_desc AS major_type_desc  
     , c.name AS minor_name, c.type_desc AS minor_type_desc  
     , at.assembly_class  
  FROM (  
        SELECT object_id, name, user_type_id, 'SQL_COLUMN' AS type_desc  
          FROM sys.columns  
     UNION ALL  
        SELECT object_id, name, user_type_id, 'SQL_PROCEDURE_PARAMETER'  
          FROM sys.parameters  
     ) AS c  
  JOIN sys.objects AS o  
    ON o.object_id = c.object_id  
  JOIN sys.assembly_types AS at  
    ON at.user_type_id = c.user_type_id;  
```  
  
## <a name="maintaining-udts"></a>Обслуживание определяемых пользователем типов  
 После создания определяемого пользователем типа в базе данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] вы не можете его изменить, хотя можно изменить сборку, на которой основан этот тип. В большинстве случаев необходимо удалить из базы данных определяемый пользователем тип с помощью инструкции DROP TYPE языка [!INCLUDE[tsql](../../includes/tsql-md.md)], внести изменения в базовую сборку и загрузить ее повторно с помощью инструкции ALTER ASSEMBLY. Затем необходимо повторно создать определяемый пользователем тип и зависимые объекты.  
  
### <a name="example"></a>Пример  
 Инструкция ALTER ASSEMBLY используется после внесения изменений в исходный код сборки определяемого пользователем типа и ее повторной компиляции. Она копирует DLL-файл на сервер и выполняет повторную привязку к новой сборке. Полный синтаксис см. в разделе [ALTER ASSEMBLY &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-assembly-transact-sql).  
  
 Следующая инструкция ALTER ASSEMBLY языка [!INCLUDE[tsql](../../includes/tsql-md.md)] повторно загружает сборку Point.dll из указанного места на диске.  
  
```  
ALTER ASSEMBLY Point  
FROM '\\Projects\Point\bin\Point.dll'  
```  
  
### <a name="using-alter-assembly-to-add-source-code"></a>Использование инструкции ALTER ASSEMBLY для добавления исходного кода  
 Предложение ADD FILE в синтаксисе инструкции ALTER ASSEMBLY отсутствует в инструкции CREATE ASSEMBLY. Оно обеспечивает возможность добавления исходного кода или любых других файлов, связанных со сборкой. Файлы копируются из исходных расположений и сохраняются в системных таблицах базы данных. Это обеспечивает постоянную доступность исходного кода или других файлов на тот случай, если возникнет необходимость повторного создания или документирования текущей версии определяемого пользователем типа.  
  
 Следующая [!INCLUDE[tsql](../../includes/tsql-md.md)] инструкция ALTER ASSEMBLY добавляет исходный код класса Point.cs для `Point` определяемого пользователем типа. В результате этого текст, содержащийся в файле Point.cs, будет скопирован и сохранен в базе данных с именем PointSource.  
  
```  
ALTER ASSEMBLY Point  
ADD FILE FROM '\\Projects\Point\Point.cs' AS PointSource;  
```  
  
 Сведения о сборке хранятся в таблице **sys. assembly_files** в базе данных, в которой установлена сборка. Таблица **sys. assembly_files** содержит следующие столбцы.  
  
 **assembly_id**  
 Идентификатор, определенный для сборки. Это число назначается всем объектам, относящимся к одной сборке.  
  
 **name**  
 Имя объекта.  
  
 **file_id**  
 Число, идентифицирующее каждый объект, с первым объектом, связанным с заданным **assembly_id** , которому присваивается значение 1. При наличии нескольких объектов, связанных с одним и тем же **assembly_id**, каждое последующее **file_id** значение увеличивается на 1.  
  
 **content**  
 Шестнадцатеричное представление сборки или файла.  
  
 Для преобразования содержимого столбца **содержимого** в читаемый текст можно использовать функцию CAST или Convert. Следующий запрос преобразует содержимое файла Point.cs в доступный для чтения текст, используя для ограничения результирующего набора до одной строки имя в предложении WHERE.  
  
```  
SELECT CAST(content AS varchar(8000))   
  FROM sys.assembly_files   
  WHERE name='PointSource';  
```  
  
 При копировании и вставке результатов в текстовый редактор видно, что разделители строк и пробелы, существовавшие в исходном тексте, сохранились.  
  
## <a name="managing-udts-and-assemblies"></a>Управление определяемыми пользователем типами и сборками  
 При планировании реализации определяемых пользователем типов обдумайте, какие методы нужны в самой сборке определяемого пользователем типа, а какие нужно создать в отдельных сборках и реализовать в виде определяемых пользователем функций или хранимых процедур. Выделение методов в отдельные сборки позволяет обновлять код, не затрагивая данные, которые могут храниться в столбце определяемого пользователем типа таблицы. Сборки определяемого пользователем типа можно изменять без удаления столбцов и других зависимых объектов только в случае, если новое определение может считывать предыдущие значения, а подпись типа не изменена.  
  
 Выделение процедурного кода, который может отличаться от кода, требуемого для реализации определяемого пользователем типа, значительно упрощает обслуживание. Включение кода, необходимого для функционирования определяемого пользователем типа, и максимально возможное упрощение определений определяемого пользователем типа снижает риск необходимости удаления этого типа из базы данных для изменения кода или исправления ошибок.  
  
### <a name="the-currency-udt-and-currency-conversion-function"></a>Определяемый пользователем тип Currency и функция конвертации валюты  
 Определяемый пользователем тип **Currency** в образце базы данных **AdventureWorks** предоставляет полезный пример рекомендуемого способа структурирования определяемого пользователем типа и связанных с ним функций. Определяемый пользователем тип **Currency** используется для обработки денег на основе денежной системы определенного языка и региональных параметров, а также для хранения различных типов валют, таких как доллары, евро и т. д. Класс определяемого пользователем типа содержит культуру в виде строки, а количество денег — в виде типа данных `decimal`. Все необходимые методы сериализации содержатся внутри сборки, определяющей класс. Функция, реализующая преобразование валюты из одного языка и региональных параметров в другую, реализуется как внешняя функция с именем **ConvertCurrency**, а эта функция находится в отдельной сборке. Функция **ConvertCurrency** выполняет свою работу, получая скорость преобразования из таблицы в базе данных **AdventureWorks** . Если источник коэффициентов преобразования изменяется или в существующем коде должны быть внесены какие-либо другие изменения, сборку можно легко изменить, не влияя на определяемый пользователем тип **Currency** .  
  
 Листинг кода для определяемых пользователем типов **Currency** и **ConvertCurrency** можно найти, установив примеры среды CLR.  
  
### <a name="using-udts-across-databases"></a>Использование определяемых пользователем типов в нескольких базах данных  
 Определяемые пользователем типы по определению находятся в одной базе данных. Таким образом, определяемый пользователем тип, созданный в одной базе данных, нельзя использовать в определении столбца другой базы данных. Чтобы использовать определяемые пользователем типы в нескольких базах данных, в каждой базе данных необходимо выполнить инструкции CREATE ASSEMBLY и CREATE TYPE для тех же сборок. Сборки считаются одинаковыми, если имеют одинаковое имя, строгое имя, культуру, версию, набор разрешений и двоичное содержимое.  
  
 После того как определяемый пользователем тип зарегистрирован и доступен в обеих базах данных, можно преобразовать значение данного типа из одной базы данных для использования в другой. Одинаковые определяемые пользователем типы могут использоваться в нескольких базах данных в следующих сценариях.  
  
-   Вызываемые хранимые процедуры определены в различных базах данных.  
  
-   Запрашиваемые таблицы определены в различных базах данных.  
  
-   Выбор данных определяемого пользователем типа из столбца одной базы данных и вставка в столбец такого же типа другой базы данных.  
  
 В этих ситуациях любое преобразование, требуемое сервером, происходит автоматически. Эти преобразования нельзя выполнить явным образом с помощью функций CAST или CONVERT языка [!INCLUDE[tsql](../../includes/tsql-md.md)].  
  
 Обратите внимание, что при [!INCLUDE[ssDEnoversion](../../includes/ssdenoversion-md.md)] создании рабочих таблиц в системной базе данных **tempdb** не нужно предпринимать никаких действий с использованием определяемых пользователем типов. Это включает в себя обработку курсоров, табличных переменных и определяемых пользователем функций с табличным значением, которые включают пользовательские типы и прозрачно используют **базу данных tempdb**. Однако при явном создании временной таблицы в базе данных **tempdb** , определяющей столбец ОПРЕДЕЛЯЕМОГО пользователем типа, определяемый пользователем тип должен быть зарегистрирован в базе данных **tempdb** так же, как и для пользовательской.  
  
## <a name="see-also"></a>См. также:  
 [Определяемые пользователем типы CLR](clr-user-defined-types.md)  
  
  

---
title: Регистрация определяемых пользователем типов в SQL Server | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: clr
ms.topic: reference
dev_langs:
- TSQL
helpviewer_keywords:
- UDTs [CLR integration], maintaining
- user-defined types [CLR integration], maintaining
- dependencies [CLR integration]
- deploying user-defined types [CLR integration]
- CurrencyConversion function
- user-defined types [CLR integration], deploying
- Transact-SQL deploying UDTs
- assemblies [CLR integration], user-defined types
- cross-database UDT support
- CREATE ASSEMBLY statement
- DROP TYPE statement
- Currency UDT
- CREATE TYPE statement
- registering user-defined types
- UDTs [CLR integration], deploying
- removing user-defined types
- user-defined types [CLR integration], registering
- ALTER ASSEMBLY statement
- UDTs [CLR integration], registering
- ADD FILE clause
ms.assetid: f7da3e92-e407-4f0b-b3a3-f214e442b37d
author: rothja
ms.author: jroth
ms.openlocfilehash: 7d24f7948e093335eff708f3c4a8a7361cfc156f
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87656426"
---
# <a name="registering-user-defined-types-in-sql-server"></a><span data-ttu-id="1c9df-102">Регистрация определяемых пользователем типов в SQL Server</span><span class="sxs-lookup"><span data-stu-id="1c9df-102">Registering User-Defined Types in SQL Server</span></span>
  <span data-ttu-id="1c9df-103">Чтобы использовать определяемый пользователем тип (UDT) в [!INCLUDE[msCoName](../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] , его необходимо зарегистрировать.</span><span class="sxs-lookup"><span data-stu-id="1c9df-103">In order to use a user-defined type (UDT) in [!INCLUDE[msCoName](../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], you must register it.</span></span> <span data-ttu-id="1c9df-104">Регистрация определяемого пользователем типа включает регистрацию сборки и создание типа в базе данных, в которой его нужно использовать.</span><span class="sxs-lookup"><span data-stu-id="1c9df-104">Registering a UDT involves registering the assembly and creating the type in the database in which you wish to use it.</span></span> <span data-ttu-id="1c9df-105">Определяемые пользователем типы находятся в одной базе данных и не могут использоваться в нескольких базах данных, пока идентичная сборка и определяемый пользователем тип не будут зарегистрированы в каждой базе данных.</span><span class="sxs-lookup"><span data-stu-id="1c9df-105">UDTs are scoped to a single database, and cannot be used in multiple databases unless the identical assembly and UDT are registered with each database.</span></span> <span data-ttu-id="1c9df-106">После регистрации сборки определяемого пользователем типа и создания типа этот тип можно использовать в [!INCLUDE[tsql](../../includes/tsql-md.md)] и клиентском коде.</span><span class="sxs-lookup"><span data-stu-id="1c9df-106">Once the UDT assembly is registered and the type created, you can use the UDT in [!INCLUDE[tsql](../../includes/tsql-md.md)] and in client code.</span></span> <span data-ttu-id="1c9df-107">Дополнительные сведения об определяемых пользователем типах данных CLR см. в разделе [Определяемые пользователем типы данных CLR](clr-user-defined-types.md).</span><span class="sxs-lookup"><span data-stu-id="1c9df-107">For more information, see [CLR User-Defined Types](clr-user-defined-types.md).</span></span>  
  
## <a name="using-visual-studio-to-deploy-udts"></a><span data-ttu-id="1c9df-108">Использование среды Visual Studio для развертывания определяемых пользователем типов</span><span class="sxs-lookup"><span data-stu-id="1c9df-108">Using Visual Studio to Deploy UDTs</span></span>  
 <span data-ttu-id="1c9df-109">Самым простым способом развертывания определяемого пользователем типа является использование среды [!INCLUDE[msCoName](../../includes/msconame-md.md)] Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="1c9df-109">The easiest way to deploy your UDT is by using [!INCLUDE[msCoName](../../includes/msconame-md.md)] Visual Studio.</span></span> <span data-ttu-id="1c9df-110">Однако для более сложных сценариев развертывания и большей гибкости используется язык [!INCLUDE[tsql](../../includes/tsql-md.md)], как описано далее в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="1c9df-110">For more complex deployment scenarios and the greatest flexibility, however, use [!INCLUDE[tsql](../../includes/tsql-md.md)] as discussed later in this topic.</span></span>  
  
 <span data-ttu-id="1c9df-111">Для создания и развертывания определяемых пользователем типов с помощью среды Visual Studio выполните следующие шаги.</span><span class="sxs-lookup"><span data-stu-id="1c9df-111">Follow these steps to create and deploy a UDT using Visual Studio:</span></span>  
  
1.  <span data-ttu-id="1c9df-112">Создайте новый проект **базы данных** на узлах языка **Visual Basic** или **Visual C#** .</span><span class="sxs-lookup"><span data-stu-id="1c9df-112">Create a new **Database** project in the **Visual Basic** or **Visual C#** language nodes.</span></span>  
  
2.  <span data-ttu-id="1c9df-113">Добавьте ссылку на базу данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], содержащую определяемый пользователем тип.</span><span class="sxs-lookup"><span data-stu-id="1c9df-113">Add a reference to the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] database that will contain the UDT.</span></span>  
  
3.  <span data-ttu-id="1c9df-114">Добавьте класс **определяемого пользователем типа** .</span><span class="sxs-lookup"><span data-stu-id="1c9df-114">Add a **User-Defined Type** class.</span></span>  
  
4.  <span data-ttu-id="1c9df-115">Напишите код для реализации определяемого пользователем типа.</span><span class="sxs-lookup"><span data-stu-id="1c9df-115">Write code to implement the UDT.</span></span>  
  
5.  <span data-ttu-id="1c9df-116">В меню **Сборка** выберите пункт **развернуть**.</span><span class="sxs-lookup"><span data-stu-id="1c9df-116">From the **Build** menu, select **Deploy**.</span></span> <span data-ttu-id="1c9df-117">Эта команда регистрирует сборку и создает тип в базе данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1c9df-117">This registers the assembly and creates the type in the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] database.</span></span>  
  
## <a name="using-transact-sql-to-deploy-udts"></a><span data-ttu-id="1c9df-118">Использование Transact-SQL для развертывания определяемых пользователем типов</span><span class="sxs-lookup"><span data-stu-id="1c9df-118">Using Transact-SQL to Deploy UDTs</span></span>  
 <span data-ttu-id="1c9df-119">Синтаксис CREATE ASSEMBLY языка [!INCLUDE[tsql](../../includes/tsql-md.md)] используется для регистрации сборки в базе данных, в которой требуется использование определяемого пользователем типа.</span><span class="sxs-lookup"><span data-stu-id="1c9df-119">The [!INCLUDE[tsql](../../includes/tsql-md.md)] CREATE ASSEMBLY syntax is used to register the assembly in the database in which you wish to use the UDT.</span></span> <span data-ttu-id="1c9df-120">Он хранится внутри системных таблиц базы данных, а во внешней файловой системе.</span><span class="sxs-lookup"><span data-stu-id="1c9df-120">It is stored internally in database system tables, not externally in the file system.</span></span> <span data-ttu-id="1c9df-121">Если определяемый пользователем тип зависит от внешних сборок, их тоже необходимо загрузить в базу данных.</span><span class="sxs-lookup"><span data-stu-id="1c9df-121">If the UDT is dependent on external assemblies, they too must be loaded into the database.</span></span> <span data-ttu-id="1c9df-122">Инструкция CREATE TYPE используется для создания определяемого пользователем типа в базе данных, в которой он будет использоваться.</span><span class="sxs-lookup"><span data-stu-id="1c9df-122">The CREATE TYPE statement is used to create the UDT in the database in which it is to be used.</span></span> <span data-ttu-id="1c9df-123">Дополнительные сведения см. в статьях [Создание сборки &#40;&#41;Transact-SQL](/sql/t-sql/statements/create-assembly-transact-sql) и [Создание типа &#40;transact-SQL&#41;](/sql/t-sql/statements/create-type-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="1c9df-123">For more information, see [CREATE ASSEMBLY &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-assembly-transact-sql) and [CREATE TYPE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-type-transact-sql).</span></span>  
  
### <a name="using-create-assembly"></a><span data-ttu-id="1c9df-124">Использование инструкции CREATE ASSEMBLY</span><span class="sxs-lookup"><span data-stu-id="1c9df-124">Using CREATE ASSEMBLY</span></span>  
 <span data-ttu-id="1c9df-125">Инструкция CREATE ASSEMBLY регистрирует сборку в базе данных, в которой требуется использование определяемого пользователем типа.</span><span class="sxs-lookup"><span data-stu-id="1c9df-125">The CREATE ASSEMBLY syntax registers the assembly in the database in which you wish to use the UDT.</span></span> <span data-ttu-id="1c9df-126">После регистрации сборки она не имеет зависимостей.</span><span class="sxs-lookup"><span data-stu-id="1c9df-126">Once the assembly is registered, it has no dependencies.</span></span>  
  
 <span data-ttu-id="1c9df-127">Создание нескольких версий одной сборки в одной базе данных не допускается.</span><span class="sxs-lookup"><span data-stu-id="1c9df-127">Creating multiple versions of the same assembly in a given database is not allowed.</span></span> <span data-ttu-id="1c9df-128">Однако возможно создание нескольких версий одной сборки, зависящих от культуры данной базы данных.</span><span class="sxs-lookup"><span data-stu-id="1c9df-128">However, it is possible to create multiple versions of the same assembly based on culture in a given database.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="1c9df-129">разделяет несколько культурных версий сборки по разным именам, зарегистрированным в экземпляре [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1c9df-129">distinguishes multiple culture versions of an assembly by different names as registered in the instance of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="1c9df-130">Дополнительные сведения см. в разделе «Создание и использование сборок со строгими именами» пакета .NET Framework SDK.</span><span class="sxs-lookup"><span data-stu-id="1c9df-130">For more information, see "Creating and Using Strong-Named Assemblies" in the .NET Framework SDK.</span></span>  
  
 <span data-ttu-id="1c9df-131">Если инструкция CREATE ASSEMBLY выполняется с наборами разрешений SAFE или EXTERNAL_ACCESS, сборка проверяется на совместимость и безопасность типа.</span><span class="sxs-lookup"><span data-stu-id="1c9df-131">When CREATE ASSEMBLY is executed with the SAFE or EXTERNAL_ACCESS permission sets, the assembly is checked to make sure that it is verifiable and type safe.</span></span> <span data-ttu-id="1c9df-132">Если набор разрешений не указан, предполагается набор разрешений SAFE.</span><span class="sxs-lookup"><span data-stu-id="1c9df-132">If you omit specifying a permission set, SAFE is assumed.</span></span> <span data-ttu-id="1c9df-133">Код с набором разрешений UNSAFE не проверяется.</span><span class="sxs-lookup"><span data-stu-id="1c9df-133">Code with the UNSAFE permission set is not checked.</span></span> <span data-ttu-id="1c9df-134">Дополнительные сведения о наборах разрешений сборки см. в разделе [Проектирование сборок](../../relational-databases/clr-integration/assemblies-designing.md).</span><span class="sxs-lookup"><span data-stu-id="1c9df-134">For more information about assembly permission sets, see [Designing Assemblies](../../relational-databases/clr-integration/assemblies-designing.md).</span></span>  
  
#### <a name="example"></a><span data-ttu-id="1c9df-135">Пример</span><span class="sxs-lookup"><span data-stu-id="1c9df-135">Example</span></span>  
 <span data-ttu-id="1c9df-136">Следующая [!INCLUDE[tsql](../../includes/tsql-md.md)] инструкция регистрирует сборку Point в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] базе данных **AdventureWorks** с набором разрешений Сейф.</span><span class="sxs-lookup"><span data-stu-id="1c9df-136">The following [!INCLUDE[tsql](../../includes/tsql-md.md)] statement registers the Point assembly in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] in the **AdventureWorks** database, with the SAFE permission set.</span></span> <span data-ttu-id="1c9df-137">Если предложение WITH PERMISSION_SET не указано, сборка регистрируется с набором разрешений SAFE.</span><span class="sxs-lookup"><span data-stu-id="1c9df-137">If the WITH PERMISSION_SET clause is omitted, the assembly is registered with the SAFE permission set.</span></span>  
  
```  
USE AdventureWorks;  
CREATE ASSEMBLY Point  
FROM '\\ShareName\Projects\Point\bin\Point.dll'   
WITH PERMISSION_SET = SAFE;  
```  
  
 <span data-ttu-id="1c9df-138">Следующая [!INCLUDE[tsql](../../includes/tsql-md.md)] инструкция регистрирует сборку с помощью *<assembly_bits>* аргумент в предложении FROM.</span><span class="sxs-lookup"><span data-stu-id="1c9df-138">The following [!INCLUDE[tsql](../../includes/tsql-md.md)] statement registers the assembly using *<assembly_bits>* argument in the FROM clause.</span></span> <span data-ttu-id="1c9df-139">Данное значение типа `varbinary` представляет файл в виде потока байтов.</span><span class="sxs-lookup"><span data-stu-id="1c9df-139">This `varbinary` value represents the file as a stream of bytes.</span></span>  
  
```  
USE AdventureWorks;  
CREATE ASSEMBLY Point  
FROM 0xfeac4 ... 21ac78  
```  
  
### <a name="using-create-type"></a><span data-ttu-id="1c9df-140">Использование инструкции CREATE TYPE</span><span class="sxs-lookup"><span data-stu-id="1c9df-140">Using CREATE TYPE</span></span>  
 <span data-ttu-id="1c9df-141">После загрузки сборки в базу данных можно создать тип с помощью инструкции CREATE TYPE языка [!INCLUDE[tsql](../../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1c9df-141">Once the assembly is loaded into the database, you can then create the type using the [!INCLUDE[tsql](../../includes/tsql-md.md)] CREATE TYPE statement.</span></span> <span data-ttu-id="1c9df-142">Она добавляет тип в список доступных типов для этой базы данных.</span><span class="sxs-lookup"><span data-stu-id="1c9df-142">This adds the type to the list of available types for that database.</span></span> <span data-ttu-id="1c9df-143">Тип имеет область базы данных и может использоваться только в той базе данных, в которой он был создан.</span><span class="sxs-lookup"><span data-stu-id="1c9df-143">The type has database scope and the type can only be used in the database in which it was created.</span></span> <span data-ttu-id="1c9df-144">Если определяемый пользователем тип уже существует в базе данных, то инструкция CREATE TYPE завершится с ошибкой.</span><span class="sxs-lookup"><span data-stu-id="1c9df-144">If the UDT already exists in the database, the CREATE TYPE statement fails with an error.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="1c9df-145">Синтаксис CREATE TYPE также используется для создания собственных псевдонимов типов данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] и предназначен для замены процедуры `sp_addtype` при создании псевдонимов типов данных.</span><span class="sxs-lookup"><span data-stu-id="1c9df-145">The CREATE TYPE syntax is also used for creating native [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] alias data types, and is intended to replace `sp_addtype` as a means of creating alias data types.</span></span> <span data-ttu-id="1c9df-146">Некоторые из дополнительных аргументов в синтаксисе CREATE TYPE служат для создания определяемых пользователем типов и неприменимы для создания псевдонимов типов данных (например базового типа).</span><span class="sxs-lookup"><span data-stu-id="1c9df-146">Some of the optional arguments in the CREATE TYPE syntax refer to creating UDTs, and are not applicable to creating alias data types (such as base type).</span></span>  
  
 <span data-ttu-id="1c9df-147">Дополнительные сведения см. в разделе [CREATE TYPE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-type-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="1c9df-147">For more information, see [CREATE TYPE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-type-transact-sql).</span></span>  
  
#### <a name="example"></a><span data-ttu-id="1c9df-148">Пример</span><span class="sxs-lookup"><span data-stu-id="1c9df-148">Example</span></span>  
 <span data-ttu-id="1c9df-149">Следующая инструкция [!INCLUDE[tsql](../../includes/tsql-md.md)] создает тип `Point`.</span><span class="sxs-lookup"><span data-stu-id="1c9df-149">The following [!INCLUDE[tsql](../../includes/tsql-md.md)] statement creates the `Point` type.</span></span> <span data-ttu-id="1c9df-150">ВНЕШНее имя задается с помощью синтаксиса имен *AssemblyName*, состоящие из двух частей. *Удтнаме*.</span><span class="sxs-lookup"><span data-stu-id="1c9df-150">The EXTERNAL NAME is specified using the two-part naming syntax of *AssemblyName*.*UDTName*.</span></span>  
  
```  
CREATE TYPE dbo.Point   
EXTERNAL NAME Point.[Point];  
```  
  
## <a name="removing-a-udt-from-the-database"></a><span data-ttu-id="1c9df-151">Удаление определяемого пользователем типа из базы данных</span><span class="sxs-lookup"><span data-stu-id="1c9df-151">Removing a UDT from the Database</span></span>  
 <span data-ttu-id="1c9df-152">Инструкция DROP TYPE удаляет определяемый пользователем тип из текущей базы данных.</span><span class="sxs-lookup"><span data-stu-id="1c9df-152">The DROP TYPE statement removes a UDT from the current database.</span></span> <span data-ttu-id="1c9df-153">После удаления определяемого пользователем типа можно инструкцией DROP ASSEMBLY удалить сборку из базы данных.</span><span class="sxs-lookup"><span data-stu-id="1c9df-153">Once a UDT is dropped, you can use the DROP ASSEMBLY statement to drop the assembly from the database.</span></span>  
  
 <span data-ttu-id="1c9df-154">Инструкция DROP TYPE не выполняется в следующих ситуациях.</span><span class="sxs-lookup"><span data-stu-id="1c9df-154">The DROP TYPE statement does not execute in the following situations:</span></span>  
  
-   <span data-ttu-id="1c9df-155">Таблицы в базе данных, которые содержат столбцы, определенные с помощью определяемого пользователем типа.</span><span class="sxs-lookup"><span data-stu-id="1c9df-155">Tables in the database that contain columns defined using the UDT.</span></span>  
  
-   <span data-ttu-id="1c9df-156">Функции, хранимые процедуры или триггеры, которые используют переменные или параметры определяемого пользователем типа и созданы в базе данных с помощью предложения WITH SCHEMABINDING.</span><span class="sxs-lookup"><span data-stu-id="1c9df-156">Functions, stored procedures, or triggers that use variables or parameters of the UDT, created in the database with the WITH SCHEMABINDING clause.</span></span>  
  
### <a name="example"></a><span data-ttu-id="1c9df-157">Пример</span><span class="sxs-lookup"><span data-stu-id="1c9df-157">Example</span></span>  
 <span data-ttu-id="1c9df-158">Следующая инструкция [!INCLUDE[tsql](../../includes/tsql-md.md)] должна выполняться в следующем порядке.</span><span class="sxs-lookup"><span data-stu-id="1c9df-158">The following [!INCLUDE[tsql](../../includes/tsql-md.md)] must execute in the following order.</span></span> <span data-ttu-id="1c9df-159">Сначала необходимо удалить таблицу, которая обращается к определяемому пользователем типу `Point`, затем тип, и, наконец, сборку.</span><span class="sxs-lookup"><span data-stu-id="1c9df-159">First the table which references the `Point` UDT must be dropped, then the type, and finally the assembly.</span></span>  
  
```  
DROP TABLE dbo.Points;  
DROP TYPE dbo.Point;  
DROP ASSEMBLY Point;  
```  
  
### <a name="finding-udt-dependencies"></a><span data-ttu-id="1c9df-160">Поиск зависимостей определяемого пользователем типа</span><span class="sxs-lookup"><span data-stu-id="1c9df-160">Finding UDT Dependencies</span></span>  
 <span data-ttu-id="1c9df-161">Если есть зависимые объекты, например таблицы с определениями столбцов определяемых пользователем типов, то инструкция DROP TYPE завершится с ошибкой.</span><span class="sxs-lookup"><span data-stu-id="1c9df-161">If there are dependent objects, such as tables with UDT column definitions, the DROP TYPE statement fails.</span></span> <span data-ttu-id="1c9df-162">Также она завершится с ошибкой, если есть функции, хранимые процедуры или триггеры, созданные в базе данных с помощью предложения WITH SCHEMABINDING, или эти процедуры используют переменные и параметры определяемого пользователем типа.</span><span class="sxs-lookup"><span data-stu-id="1c9df-162">It also fails if there are functions, stored procedures, or triggers created in the database using the WITH SCHEMABINDING clause, if these routines use variables or parameters of the user-defined type.</span></span> <span data-ttu-id="1c9df-163">Сначала необходимо удалить все зависимые объекты, а затем выполнить инструкцию DROP TYPE.</span><span class="sxs-lookup"><span data-stu-id="1c9df-163">You must first drop all dependent objects, and then execute the DROP TYPE statement.</span></span>  
  
 <span data-ttu-id="1c9df-164">Следующий [!INCLUDE[tsql](../../includes/tsql-md.md)] запрос находит все столбцы и параметры, которые используют определяемый пользователем тип в базе данных **AdventureWorks** .</span><span class="sxs-lookup"><span data-stu-id="1c9df-164">The following [!INCLUDE[tsql](../../includes/tsql-md.md)] query locates all of the columns and parameters that use a UDT in the **AdventureWorks** database.</span></span>  
  
```  
USE Adventureworks;  
SELECT o.name AS major_name, o.type_desc AS major_type_desc  
     , c.name AS minor_name, c.type_desc AS minor_type_desc  
     , at.assembly_class  
  FROM (  
        SELECT object_id, name, user_type_id, 'SQL_COLUMN' AS type_desc  
          FROM sys.columns  
     UNION ALL  
        SELECT object_id, name, user_type_id, 'SQL_PROCEDURE_PARAMETER'  
          FROM sys.parameters  
     ) AS c  
  JOIN sys.objects AS o  
    ON o.object_id = c.object_id  
  JOIN sys.assembly_types AS at  
    ON at.user_type_id = c.user_type_id;  
```  
  
## <a name="maintaining-udts"></a><span data-ttu-id="1c9df-165">Обслуживание определяемых пользователем типов</span><span class="sxs-lookup"><span data-stu-id="1c9df-165">Maintaining UDTs</span></span>  
 <span data-ttu-id="1c9df-166">После создания определяемого пользователем типа в базе данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] вы не можете его изменить, хотя можно изменить сборку, на которой основан этот тип.</span><span class="sxs-lookup"><span data-stu-id="1c9df-166">You cannot modify a UDT once it is created in a [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] database, although you can alter the assembly on which the type is based.</span></span> <span data-ttu-id="1c9df-167">В большинстве случаев необходимо удалить из базы данных определяемый пользователем тип с помощью инструкции DROP TYPE языка [!INCLUDE[tsql](../../includes/tsql-md.md)], внести изменения в базовую сборку и загрузить ее повторно с помощью инструкции ALTER ASSEMBLY.</span><span class="sxs-lookup"><span data-stu-id="1c9df-167">In most cases, you must remove the UDT from the database with the [!INCLUDE[tsql](../../includes/tsql-md.md)] DROP TYPE statement, make changes to the underlying assembly, and reload it using the ALTER ASSEMBLY statement.</span></span> <span data-ttu-id="1c9df-168">Затем необходимо повторно создать определяемый пользователем тип и зависимые объекты.</span><span class="sxs-lookup"><span data-stu-id="1c9df-168">You then need to re-create the UDT and any dependent objects.</span></span>  
  
### <a name="example"></a><span data-ttu-id="1c9df-169">Пример</span><span class="sxs-lookup"><span data-stu-id="1c9df-169">Example</span></span>  
 <span data-ttu-id="1c9df-170">Инструкция ALTER ASSEMBLY используется после внесения изменений в исходный код сборки определяемого пользователем типа и ее повторной компиляции.</span><span class="sxs-lookup"><span data-stu-id="1c9df-170">The ALTER ASSEMBLY statement is used after you have made changes to the source code in your UDT assembly and recompiled it.</span></span> <span data-ttu-id="1c9df-171">Она копирует DLL-файл на сервер и выполняет повторную привязку к новой сборке.</span><span class="sxs-lookup"><span data-stu-id="1c9df-171">It copies the .dll file to the server and rebinds to the new assembly.</span></span> <span data-ttu-id="1c9df-172">Полный синтаксис см. в разделе [ALTER ASSEMBLY &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-assembly-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="1c9df-172">For the complete syntax, see [ALTER ASSEMBLY &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-assembly-transact-sql).</span></span>  
  
 <span data-ttu-id="1c9df-173">Следующая инструкция ALTER ASSEMBLY языка [!INCLUDE[tsql](../../includes/tsql-md.md)] повторно загружает сборку Point.dll из указанного места на диске.</span><span class="sxs-lookup"><span data-stu-id="1c9df-173">The following [!INCLUDE[tsql](../../includes/tsql-md.md)] ALTER ASSEMBLY statement reloads the Point.dll assembly from the specified location on disk.</span></span>  
  
```  
ALTER ASSEMBLY Point  
FROM '\\Projects\Point\bin\Point.dll'  
```  
  
### <a name="using-alter-assembly-to-add-source-code"></a><span data-ttu-id="1c9df-174">Использование инструкции ALTER ASSEMBLY для добавления исходного кода</span><span class="sxs-lookup"><span data-stu-id="1c9df-174">Using ALTER ASSEMBLY to Add Source Code</span></span>  
 <span data-ttu-id="1c9df-175">Предложение ADD FILE в синтаксисе инструкции ALTER ASSEMBLY отсутствует в инструкции CREATE ASSEMBLY.</span><span class="sxs-lookup"><span data-stu-id="1c9df-175">The ADD FILE clause in the ALTER ASSEMBLY syntax is not present in CREATE ASSEMBLY.</span></span> <span data-ttu-id="1c9df-176">Оно обеспечивает возможность добавления исходного кода или любых других файлов, связанных со сборкой.</span><span class="sxs-lookup"><span data-stu-id="1c9df-176">You can use it to add source code or any other files associated with an assembly.</span></span> <span data-ttu-id="1c9df-177">Файлы копируются из исходных расположений и сохраняются в системных таблицах базы данных.</span><span class="sxs-lookup"><span data-stu-id="1c9df-177">The files are copied from their original locations and stored in system tables in the database.</span></span> <span data-ttu-id="1c9df-178">Это обеспечивает постоянную доступность исходного кода или других файлов на тот случай, если возникнет необходимость повторного создания или документирования текущей версии определяемого пользователем типа.</span><span class="sxs-lookup"><span data-stu-id="1c9df-178">This ensures that you always have source code or other files on hand should you ever need to re-create or document the current version of the UDT.</span></span>  
  
 <span data-ttu-id="1c9df-179">Следующая [!INCLUDE[tsql](../../includes/tsql-md.md)] инструкция ALTER ASSEMBLY добавляет исходный код класса Point.cs для `Point` определяемого пользователем типа.</span><span class="sxs-lookup"><span data-stu-id="1c9df-179">The following [!INCLUDE[tsql](../../includes/tsql-md.md)] ALTER ASSEMBLY statement adds the Point.cs class source code for the `Point` UDT.</span></span> <span data-ttu-id="1c9df-180">В результате этого текст, содержащийся в файле Point.cs, будет скопирован и сохранен в базе данных с именем PointSource.</span><span class="sxs-lookup"><span data-stu-id="1c9df-180">This copies the text contained in the Point.cs file and stores it in the database under the name "PointSource".</span></span>  
  
```  
ALTER ASSEMBLY Point  
ADD FILE FROM '\\Projects\Point\Point.cs' AS PointSource;  
```  
  
 <span data-ttu-id="1c9df-181">Сведения о сборке хранятся в таблице **sys. assembly_files** в базе данных, в которой установлена сборка.</span><span class="sxs-lookup"><span data-stu-id="1c9df-181">Assembly information is stored in the **sys.assembly_files** table in the database where the assembly has been installed.</span></span> <span data-ttu-id="1c9df-182">Таблица **sys. assembly_files** содержит следующие столбцы.</span><span class="sxs-lookup"><span data-stu-id="1c9df-182">The **sys.assembly_files** table contains the following columns.</span></span>  
  
 <span data-ttu-id="1c9df-183">**assembly_id**</span><span class="sxs-lookup"><span data-stu-id="1c9df-183">**assembly_id**</span></span>  
 <span data-ttu-id="1c9df-184">Идентификатор, определенный для сборки.</span><span class="sxs-lookup"><span data-stu-id="1c9df-184">The identifier defined for the assembly.</span></span> <span data-ttu-id="1c9df-185">Это число назначается всем объектам, относящимся к одной сборке.</span><span class="sxs-lookup"><span data-stu-id="1c9df-185">This number is assigned to all objects relating to the same assembly.</span></span>  
  
 <span data-ttu-id="1c9df-186">**name**</span><span class="sxs-lookup"><span data-stu-id="1c9df-186">**name**</span></span>  
 <span data-ttu-id="1c9df-187">Имя объекта.</span><span class="sxs-lookup"><span data-stu-id="1c9df-187">The name of the object.</span></span>  
  
 <span data-ttu-id="1c9df-188">**file_id**</span><span class="sxs-lookup"><span data-stu-id="1c9df-188">**file_id**</span></span>  
 <span data-ttu-id="1c9df-189">Число, идентифицирующее каждый объект, с первым объектом, связанным с заданным **assembly_id** , которому присваивается значение 1.</span><span class="sxs-lookup"><span data-stu-id="1c9df-189">A number identifying each object, with the first object associated with a given **assembly_id** being given the value of 1.</span></span> <span data-ttu-id="1c9df-190">При наличии нескольких объектов, связанных с одним и тем же **assembly_id**, каждое последующее **file_id** значение увеличивается на 1.</span><span class="sxs-lookup"><span data-stu-id="1c9df-190">If there are multiple objects associated with the same **assembly_id**, then each subsequent **file_id** value is incremented by 1.</span></span>  
  
 <span data-ttu-id="1c9df-191">**content**</span><span class="sxs-lookup"><span data-stu-id="1c9df-191">**content**</span></span>  
 <span data-ttu-id="1c9df-192">Шестнадцатеричное представление сборки или файла.</span><span class="sxs-lookup"><span data-stu-id="1c9df-192">The hexadecimal representation of the assembly or file.</span></span>  
  
 <span data-ttu-id="1c9df-193">Для преобразования содержимого столбца **содержимого** в читаемый текст можно использовать функцию CAST или Convert.</span><span class="sxs-lookup"><span data-stu-id="1c9df-193">You can use the CAST or CONVERT function to convert the contents of the **content** column to readable text.</span></span> <span data-ttu-id="1c9df-194">Следующий запрос преобразует содержимое файла Point.cs в доступный для чтения текст, используя для ограничения результирующего набора до одной строки имя в предложении WHERE.</span><span class="sxs-lookup"><span data-stu-id="1c9df-194">The following query converts the contents of the Point.cs file to readable text, using the name in the WHERE clause to restrict the result set to a single row.</span></span>  
  
```  
SELECT CAST(content AS varchar(8000))   
  FROM sys.assembly_files   
  WHERE name='PointSource';  
```  
  
 <span data-ttu-id="1c9df-195">При копировании и вставке результатов в текстовый редактор видно, что разделители строк и пробелы, существовавшие в исходном тексте, сохранились.</span><span class="sxs-lookup"><span data-stu-id="1c9df-195">If you copy and paste the results in to a text editor, you will see that the line breaks and spaces that existed in the original have been preserved.</span></span>  
  
## <a name="managing-udts-and-assemblies"></a><span data-ttu-id="1c9df-196">Управление определяемыми пользователем типами и сборками</span><span class="sxs-lookup"><span data-stu-id="1c9df-196">Managing UDTs and Assemblies</span></span>  
 <span data-ttu-id="1c9df-197">При планировании реализации определяемых пользователем типов обдумайте, какие методы нужны в самой сборке определяемого пользователем типа, а какие нужно создать в отдельных сборках и реализовать в виде определяемых пользователем функций или хранимых процедур.</span><span class="sxs-lookup"><span data-stu-id="1c9df-197">When planning your implementation of UDTs, consider which methods are needed in the UDT assembly itself, and which methods should be created in separate assemblies and implemented as user-defined functions or stored procedures.</span></span> <span data-ttu-id="1c9df-198">Выделение методов в отдельные сборки позволяет обновлять код, не затрагивая данные, которые могут храниться в столбце определяемого пользователем типа таблицы.</span><span class="sxs-lookup"><span data-stu-id="1c9df-198">Separating methods into separate assemblies allows you to update code without affecting data that may be stored in a UDT column in a table.</span></span> <span data-ttu-id="1c9df-199">Сборки определяемого пользователем типа можно изменять без удаления столбцов и других зависимых объектов только в случае, если новое определение может считывать предыдущие значения, а подпись типа не изменена.</span><span class="sxs-lookup"><span data-stu-id="1c9df-199">You can modify UDT assemblies without dropping UDT columns and other dependent objects only when the new definition can read the former values and the signature of the type does not change.</span></span>  
  
 <span data-ttu-id="1c9df-200">Выделение процедурного кода, который может отличаться от кода, требуемого для реализации определяемого пользователем типа, значительно упрощает обслуживание.</span><span class="sxs-lookup"><span data-stu-id="1c9df-200">Separating procedural code that may change from the code required to implement the UDT greatly simplifies maintenance.</span></span> <span data-ttu-id="1c9df-201">Включение кода, необходимого для функционирования определяемого пользователем типа, и максимально возможное упрощение определений определяемого пользователем типа снижает риск необходимости удаления этого типа из базы данных для изменения кода или исправления ошибок.</span><span class="sxs-lookup"><span data-stu-id="1c9df-201">Including only code that is necessary for the UDT to function, and keeping your UDT definitions as simple as possible, reduces the risk that the UDT itself may need to be dropped from the database for code revisions or bug fixes.</span></span>  
  
### <a name="the-currency-udt-and-currency-conversion-function"></a><span data-ttu-id="1c9df-202">Определяемый пользователем тип Currency и функция конвертации валюты</span><span class="sxs-lookup"><span data-stu-id="1c9df-202">The Currency UDT and Currency Conversion Function</span></span>  
 <span data-ttu-id="1c9df-203">Определяемый пользователем тип **Currency** в образце базы данных **AdventureWorks** предоставляет полезный пример рекомендуемого способа структурирования определяемого пользователем типа и связанных с ним функций.</span><span class="sxs-lookup"><span data-stu-id="1c9df-203">The **Currency** UDT in the **AdventureWorks** sample database provides a useful example of the recommended way to structure a UDT and its associated functions.</span></span> <span data-ttu-id="1c9df-204">Определяемый пользователем тип **Currency** используется для обработки денег на основе денежной системы определенного языка и региональных параметров, а также для хранения различных типов валют, таких как доллары, евро и т. д.</span><span class="sxs-lookup"><span data-stu-id="1c9df-204">The **Currency** UDT is used for handling money based on the monetary system of a particular culture, and allows for storage of different currency types, such as dollars, euros, and so forth.</span></span> <span data-ttu-id="1c9df-205">Класс определяемого пользователем типа содержит культуру в виде строки, а количество денег — в виде типа данных `decimal`.</span><span class="sxs-lookup"><span data-stu-id="1c9df-205">The UDT class exposes a culture name as a string, and an amount of money as a `decimal` data type.</span></span> <span data-ttu-id="1c9df-206">Все необходимые методы сериализации содержатся внутри сборки, определяющей класс.</span><span class="sxs-lookup"><span data-stu-id="1c9df-206">All of the necessary serialization methods are contained within the assembly defining the class.</span></span> <span data-ttu-id="1c9df-207">Функция, реализующая преобразование валюты из одного языка и региональных параметров в другую, реализуется как внешняя функция с именем **ConvertCurrency**, а эта функция находится в отдельной сборке.</span><span class="sxs-lookup"><span data-stu-id="1c9df-207">The function that implements currency conversion from one culture to another is implemented as an external function named **ConvertCurrency**, and this function is located in a separate assembly.</span></span> <span data-ttu-id="1c9df-208">Функция **ConvertCurrency** выполняет свою работу, получая скорость преобразования из таблицы в базе данных **AdventureWorks** .</span><span class="sxs-lookup"><span data-stu-id="1c9df-208">The **ConvertCurrency** function does its work by retrieving the conversion rate from a table in the **AdventureWorks** database.</span></span> <span data-ttu-id="1c9df-209">Если источник коэффициентов преобразования изменяется или в существующем коде должны быть внесены какие-либо другие изменения, сборку можно легко изменить, не влияя на определяемый пользователем тип **Currency** .</span><span class="sxs-lookup"><span data-stu-id="1c9df-209">If the source of the conversion rates should ever change, or if there should be any other changes to the existing code, the assembly can be easily modified without affecting the **Currency** UDT.</span></span>  
  
 <span data-ttu-id="1c9df-210">Листинг кода для определяемых пользователем типов **Currency** и **ConvertCurrency** можно найти, установив примеры среды CLR.</span><span class="sxs-lookup"><span data-stu-id="1c9df-210">The code listing for the **Currency** UDT and **ConvertCurrency** functions can be found by installing the common language runtime (CLR) samples.</span></span>  
  
### <a name="using-udts-across-databases"></a><span data-ttu-id="1c9df-211">Использование определяемых пользователем типов в нескольких базах данных</span><span class="sxs-lookup"><span data-stu-id="1c9df-211">Using UDTs Across Databases</span></span>  
 <span data-ttu-id="1c9df-212">Определяемые пользователем типы по определению находятся в одной базе данных.</span><span class="sxs-lookup"><span data-stu-id="1c9df-212">UDTs are by definition scoped to a single database.</span></span> <span data-ttu-id="1c9df-213">Таким образом, определяемый пользователем тип, созданный в одной базе данных, нельзя использовать в определении столбца другой базы данных.</span><span class="sxs-lookup"><span data-stu-id="1c9df-213">Therefore, a UDT defined in one database cannot be used in a column definition in another database.</span></span> <span data-ttu-id="1c9df-214">Чтобы использовать определяемые пользователем типы в нескольких базах данных, в каждой базе данных необходимо выполнить инструкции CREATE ASSEMBLY и CREATE TYPE для тех же сборок.</span><span class="sxs-lookup"><span data-stu-id="1c9df-214">In order to use UDTs in multiple databases, you must execute the CREATE ASSEMBLY and CREATE TYPE statements in each database on identical assemblies.</span></span> <span data-ttu-id="1c9df-215">Сборки считаются одинаковыми, если имеют одинаковое имя, строгое имя, культуру, версию, набор разрешений и двоичное содержимое.</span><span class="sxs-lookup"><span data-stu-id="1c9df-215">Assemblies are considered identical if they have the same name, strong name, culture, version, permission set, and binary contents.</span></span>  
  
 <span data-ttu-id="1c9df-216">После того как определяемый пользователем тип зарегистрирован и доступен в обеих базах данных, можно преобразовать значение данного типа из одной базы данных для использования в другой.</span><span class="sxs-lookup"><span data-stu-id="1c9df-216">Once the UDT is registered and accessible in both databases, you can convert a UDT value from one database for use in another.</span></span> <span data-ttu-id="1c9df-217">Одинаковые определяемые пользователем типы могут использоваться в нескольких базах данных в следующих сценариях.</span><span class="sxs-lookup"><span data-stu-id="1c9df-217">Identical UDTs can be used across databases in the following scenarios:</span></span>  
  
-   <span data-ttu-id="1c9df-218">Вызываемые хранимые процедуры определены в различных базах данных.</span><span class="sxs-lookup"><span data-stu-id="1c9df-218">Calling stored procedure defined in different databases.</span></span>  
  
-   <span data-ttu-id="1c9df-219">Запрашиваемые таблицы определены в различных базах данных.</span><span class="sxs-lookup"><span data-stu-id="1c9df-219">Querying tables defined in different databases.</span></span>  
  
-   <span data-ttu-id="1c9df-220">Выбор данных определяемого пользователем типа из столбца одной базы данных и вставка в столбец такого же типа другой базы данных.</span><span class="sxs-lookup"><span data-stu-id="1c9df-220">Selecting UDT data from one database table UDT column and inserting it into a second database with an identical UDT column.</span></span>  
  
 <span data-ttu-id="1c9df-221">В этих ситуациях любое преобразование, требуемое сервером, происходит автоматически.</span><span class="sxs-lookup"><span data-stu-id="1c9df-221">In these situations, any conversion required by the server occurs automatically.</span></span> <span data-ttu-id="1c9df-222">Эти преобразования нельзя выполнить явным образом с помощью функций CAST или CONVERT языка [!INCLUDE[tsql](../../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="1c9df-222">You are not able to perform the conversions explicitly using the [!INCLUDE[tsql](../../includes/tsql-md.md)] CAST or CONVERT functions.</span></span>  
  
 <span data-ttu-id="1c9df-223">Обратите внимание, что при [!INCLUDE[ssDEnoversion](../../includes/ssdenoversion-md.md)] создании рабочих таблиц в системной базе данных **tempdb** не нужно предпринимать никаких действий с использованием определяемых пользователем типов.</span><span class="sxs-lookup"><span data-stu-id="1c9df-223">Note that you do not need to take any action for using UDTs when [!INCLUDE[ssDEnoversion](../../includes/ssdenoversion-md.md)] creates work tables in the **tempdb** system database.</span></span> <span data-ttu-id="1c9df-224">Это включает в себя обработку курсоров, табличных переменных и определяемых пользователем функций с табличным значением, которые включают пользовательские типы и прозрачно используют **базу данных tempdb**.</span><span class="sxs-lookup"><span data-stu-id="1c9df-224">This includes the handling of cursors, table variables, and user-defined table-valued functions that include UDTs and that transparently make use of **tempdb**.</span></span> <span data-ttu-id="1c9df-225">Однако при явном создании временной таблицы в базе данных **tempdb** , определяющей столбец ОПРЕДЕЛЯЕМОГО пользователем типа, определяемый пользователем тип должен быть зарегистрирован в базе данных **tempdb** так же, как и для пользовательской.</span><span class="sxs-lookup"><span data-stu-id="1c9df-225">However, if you explicitly create a temporary table in **tempdb** that defines a UDT column, then the UDT must be registered in **tempdb** the same way as for a user database.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1c9df-226">См. также:</span><span class="sxs-lookup"><span data-stu-id="1c9df-226">See Also</span></span>  
 [<span data-ttu-id="1c9df-227">Определяемые пользователем типы CLR</span><span class="sxs-lookup"><span data-stu-id="1c9df-227">CLR User-Defined Types</span></span>](clr-user-defined-types.md)  
  
  

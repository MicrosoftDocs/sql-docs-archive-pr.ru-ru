---
title: Требования к определяемому пользователем типу | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: clr
ms.topic: reference
helpviewer_keywords:
- UDTs [CLR integration], requirements
- serialization
- Native serialization format [CLR integration]
- attributes [CLR integration]
- XML serialization [CLR integration]
- user-defined types [CLR integration], requirements
- user-defined serialization [CLR integration]
- user-defined types [CLR integration], Native serialization
- UDTs [CLR integration], Native serialization
ms.assetid: bedc3372-50eb-40f2-bcf2-d6db6a63b7e6
author: rothja
ms.author: jroth
ms.openlocfilehash: d4e692a4523829713cd95daf62374f84a74b6584
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87656430"
---
# <a name="user-defined-type-requirements"></a><span data-ttu-id="ccd5f-102">Требования определяемого пользователем типа данных</span><span class="sxs-lookup"><span data-stu-id="ccd5f-102">User-Defined Type Requirements</span></span>
  <span data-ttu-id="ccd5f-103">При создании определяемого пользователем типа (UDT) для установки в необходимо принять несколько важных решений по проектированию [!INCLUDE[msCoName](../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="ccd5f-103">You must make several important design decisions when creating a user-defined type (UDT) to be installed in [!INCLUDE[msCoName](../../includes/msconame-md.md)][!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="ccd5f-104">В большинстве случаев рекомендуется создавать определяемый пользователем тип как структуру, хотя можно создавать его и в виде класса.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-104">For most UDTs, creating the UDT as a structure is recommended, although creating it as a class is also an option.</span></span> <span data-ttu-id="ccd5f-105">Чтобы определяемый пользователем тип можно было зарегистрировать в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], его определение должно соответствовать спецификациям на создание определяемого пользователем типа.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-105">The UDT definition must conform to the specifications for creating UDTs in order for it to be registered with [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span>  
  
## <a name="requirements-for-implementing-udts"></a><span data-ttu-id="ccd5f-106">Требования к реализации определяемого пользователем типа</span><span class="sxs-lookup"><span data-stu-id="ccd5f-106">Requirements for Implementing UDTs</span></span>  
 <span data-ttu-id="ccd5f-107">Чтобы определяемый пользователем тип работал в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], его определение должно удовлетворять следующим условиям.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-107">To run in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], your UDT must implement the following requirements in the UDT definition:</span></span>  
  
 <span data-ttu-id="ccd5f-108">Определяемый пользователем тип должен задавать атрибут `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute`.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-108">The UDT must specify the `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute`.</span></span> <span data-ttu-id="ccd5f-109">Использование `System.SerializableAttribute` необязательно, но рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-109">The use of the `System.SerializableAttribute` is optional, but recommended.</span></span>  
  
-   <span data-ttu-id="ccd5f-110">Структура или класс определяемого пользователем типа должны реализовать интерфейс `System.Data.SqlTypes.INullable` посредством создания метода `static` типа `Shared` (`Null` в [!INCLUDE[msCoName](../../includes/msconame-md.md)] Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="ccd5f-110">The UDT must implement the `System.Data.SqlTypes.INullable` interface in the class or structure by creating a public `static` (`Shared` in [!INCLUDE[msCoName](../../includes/msconame-md.md)] Visual Basic) `Null` method.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="ccd5f-111">по умолчанию может работать со значениями NULL.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-111">is null-aware by default.</span></span> <span data-ttu-id="ccd5f-112">Это необходимо, чтобы программный код, принадлежащий определяемому пользователем типу, умел распознавать значения NULL.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-112">This is necessary for code executing in the UDT to be able to recognize a null value.</span></span>  
  
-   <span data-ttu-id="ccd5f-113">Определяемый пользователем тип должен содержать общедоступный метод типа `static` (или `Shared`) `Parse`, поддерживающий создание объекта из строки с помощью синтаксического анализа, и общедоступный метод `ToString` для преобразования объекта в строку.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-113">The UDT must contain a public `static` (or `Shared`) `Parse` method that supports parsing from, and a public `ToString` method for converting to a string representation of the object.</span></span>  
  
-   <span data-ttu-id="ccd5f-114">Определяемый пользователем тип, имеющий заданный пользователем формат сериализации, должен реализовать интерфейс `System.Data.IBinarySerialize` и предоставлять методы `Read` и `Write`.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-114">A UDT with a user-defined serialization format must implement the `System.Data.IBinarySerialize` interface and provide a `Read` and a `Write` method.</span></span>  
  
-   <span data-ttu-id="ccd5f-115">Определяемый пользователем тип должен реализовать интерфейс `System.Xml.Serialization.IXmlSerializable`, либо все его общедоступные поля и свойства должны быть XML-сериализуемы или содержать атрибут `XmlIgnore`, если требуется переопределить стандартную сериализацию.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-115">The UDT must implement `System.Xml.Serialization.IXmlSerializable`, or all public fields and properties must be of types that are XML serializable or decorated with the `XmlIgnore` attribute if overriding standard serialization is required.</span></span>  
  
-   <span data-ttu-id="ccd5f-116">У объекта определяемого пользователем типа может быть только одна сериализация.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-116">There must be only one serialization of a UDT object.</span></span> <span data-ttu-id="ccd5f-117">Если программы сериализации или десериализации обнаружат несколько различных представлений конкретного объекта, проверка закончится ошибкой.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-117">Validation fails if the serialize or deserialize routines recognize more than one representation of a particular object.</span></span>  
  
-   <span data-ttu-id="ccd5f-118">Для сравнения данных по порядку байтов атрибут `SqlUserDefinedTypeAttribute.IsByteOrdered` должен иметь значение `true`.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-118">`SqlUserDefinedTypeAttribute.IsByteOrdered` must be `true` to compare data in byte order.</span></span> <span data-ttu-id="ccd5f-119">Если интерфейс IComparable не реализован, а атрибут `SqlUserDefinedTypeAttribute.IsByteOrdered` имеет значение `false`, сравнение по порядку байтов будут завершаться неудачей.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-119">If the IComparable interface is not implemented and `SqlUserDefinedTypeAttribute.IsByteOrdered` is `false`, byte order comparisons will fail.</span></span>  
  
-   <span data-ttu-id="ccd5f-120">Определяемый пользователем тип, заданный в виде класса, должен иметь общедоступный конструктор без аргументов.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-120">A UDT defined in a class must have a public constructor that takes no arguments.</span></span> <span data-ttu-id="ccd5f-121">Дополнительно можно создать перегруженные конструкторы класса.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-121">You can optionally create additional overloaded class constructors.</span></span>  
  
-   <span data-ttu-id="ccd5f-122">Определяемый пользователем тип должен предоставлять доступ к элементам данных как к общедоступным полям или процедурам свойств.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-122">The UDT must expose data elements as public fields or property procedures.</span></span>  
  
-   <span data-ttu-id="ccd5f-123">Общедоступные имена не могут быть длиннее 128 символов и должны соответствовать [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] правилам именования идентификаторов, определенным в [идентификаторах баз данных](../databases/database-identifiers.md).</span><span class="sxs-lookup"><span data-stu-id="ccd5f-123">Public names cannot be longer than 128 characters, and must conform to the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] naming rules for identifiers as defined in [Database Identifiers](../databases/database-identifiers.md).</span></span>  
  
-   <span data-ttu-id="ccd5f-124">Столбцы `sql_variant` не могут содержать экземпляры определяемого пользователем типа.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-124">`sql_variant` columns cannot contain instances of a UDT.</span></span>  
  
-   <span data-ttu-id="ccd5f-125">Унаследованные элементы недоступны из [!INCLUDE[tsql](../../includes/tsql-md.md)], потому что система типов [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] ничего не знает об иерархии наследования среди определяемых пользователем типов.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-125">Inherited members are not accessible from [!INCLUDE[tsql](../../includes/tsql-md.md)] because the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] type system is not aware of the inheritance hierarchy among UDTs.</span></span> <span data-ttu-id="ccd5f-126">Однако можно использовать наследование при определении структуры классов и можно вызывать такие методы в реализации этих типов с помощью управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-126">However, you can use inheritance when you structure your classes and you can call such methods in the managed code implementation of the type.</span></span>  
  
-   <span data-ttu-id="ccd5f-127">Элементы структуры или класса нельзя перегружать, кроме конструктора класса.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-127">Members cannot be overloaded, except for the class constructor.</span></span> <span data-ttu-id="ccd5f-128">Если создан перегруженный метод, при регистрации сборки или создании типа в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] ошибка не возникает.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-128">If you do create an overloaded method, no error is raised when you register the assembly or create the type in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="ccd5f-129">Определение наличия перегруженного метода происходит во время выполнения, а не при создании типа.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-129">Detection of the overloaded method occurs at run time, not when the type is created.</span></span> <span data-ttu-id="ccd5f-130">Класс может иметь перегруженные методы при условии, что они не вызываются.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-130">Overloaded methods can exist in the class as long as they are never invoked.</span></span> <span data-ttu-id="ccd5f-131">При вызове перегруженного метода возникает ошибка.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-131">Once you invoke the overloaded method, an error is raised.</span></span>  
  
-   <span data-ttu-id="ccd5f-132">Любые элементы, объявленные как `static` (или `Shared`) должны быть объявлены константами или данными только для чтения.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-132">Any `static` (or `Shared`) members must be declared as constants or as read-only.</span></span> <span data-ttu-id="ccd5f-133">Элементы, объявленные как статические, нельзя изменять.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-133">Static members cannot be mutable.</span></span>  
  
-   <span data-ttu-id="ccd5f-134">Если для поля `SqlUserDefinedTypeAttribute.MaxByteSize` задано значение -1, ограничение на размер сериализованного определяемого пользователем типа такое же, как и для объектов LOB (в настоящее время — 2 ГБ).</span><span class="sxs-lookup"><span data-stu-id="ccd5f-134">If the `SqlUserDefinedTypeAttribute.MaxByteSize` field is set to -1, the serialized UDT can be as large as the large object (LOB) size limit (currently 2 GB).</span></span> <span data-ttu-id="ccd5f-135">Размер определяемого пользователем типа не может превышать величины, заданной в поле `MaxByteSized`.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-135">The size of the UDT cannot exceed the value specified in the `MaxByteSized` field.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="ccd5f-136">По желанию можно реализовать интерфейс `System.IComparable`, предоставляющий единственный метод `CompareTo`, хотя сервер не использует этот метод для сравнения.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-136">Although it is not used by the server for performing comparisons, you can optionally implement the `System.IComparable` interface, which exposes a single method, `CompareTo`.</span></span> <span data-ttu-id="ccd5f-137">Он используется на клиенте в ситуациях, когда нужно провести точное сравнение или сортировку значений определяемого пользователем типа.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-137">This is used on the client side in situations in which it is desirable to accurately compare or order UDT values.</span></span>  
  
## <a name="native-serialization"></a><span data-ttu-id="ccd5f-138">Собственная сериализация</span><span class="sxs-lookup"><span data-stu-id="ccd5f-138">Native Serialization</span></span>  
 <span data-ttu-id="ccd5f-139">Выбор атрибутов сериализации при создании определяемого пользователем типа зависит от его типа.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-139">Choosing the right serialization attributes for your UDT depends on the type of UDT you are trying to create.</span></span> <span data-ttu-id="ccd5f-140">Формат сериализации `Native` использует очень простую структуру, позволяющую [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] хранить определяемый пользователем тип на диске в эффективном собственном формате.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-140">The `Native` serialization format utilizes a very simple structure that enables [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] to store an efficient native representation of the UDT on disk.</span></span> <span data-ttu-id="ccd5f-141">Формат `Native` рекомендуется для простых определяемых пользователем типов, содержащих только поля следующих типов:</span><span class="sxs-lookup"><span data-stu-id="ccd5f-141">The `Native` format is recommended if the UDT is simple and only contains fields of the following types:</span></span>  
  
 <span data-ttu-id="ccd5f-142">**bool**, **Byte**, **SByte**, **Short**, **UShort**, **int**, **uint**, **Long**, **ulong**, **float**, **Double**, **склбите**, **SqlInt16**, **SqlInt32**, **SqlInt64**, **SqlDateTime**, **склсингле**, **SqlDouble**, **SqlMoney**, **SqlBoolean**</span><span class="sxs-lookup"><span data-stu-id="ccd5f-142">**bool**, **byte**, **sbyte**, **short**, **ushort**, **int**, **uint**, **long**, **ulong**, **float**, **double**, **SqlByte**, **SqlInt16**, **SqlInt32**, **SqlInt64**, **SqlDateTime**, **SqlSingle**, **SqlDouble**, **SqlMoney**, **SqlBoolean**</span></span>  
  
 <span data-ttu-id="ccd5f-143">Типы значений, состоящие из полей приведенных выше типов, являются хорошим кандидатом для `Native` формата, например `structs` в Visual C# (или в том случае, если `Structures` они известны в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="ccd5f-143">Value types that are composed of fields of the above types are good candidates for `Native` format, such as `structs` in Visual C#, (or `Structures` as they are known in Visual Basic).</span></span> <span data-ttu-id="ccd5f-144">Например, определяемый пользователем тип, для которого указан формат сериализации `Native`, может содержать в качестве поля другой определяемый пользователем тип, для которого также указан формат сериализации `Native`.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-144">For example, a UDT specified with the `Native` serialization format may contain a field of another UDT that was also specified with the `Native` format.</span></span> <span data-ttu-id="ccd5f-145">Для более сложных определяемых пользователем типов, содержащих типы данных, которые не вошли в приведенный список, нужно вместо этого задать формат сериализации `UserDefined`.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-145">If the UDT definition is more complex and contains data types not on the above list, you must specify the `UserDefined` serialization format instead.</span></span>  
  
 <span data-ttu-id="ccd5f-146">Формат `Native` накладывает следующие ограничения.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-146">The `Native` format has the following requirements:</span></span>  
  
-   <span data-ttu-id="ccd5f-147">Параметру `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute.MaxByteSize` не должно быть задано значение.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-147">The type must not specify a value for `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute.MaxByteSize`.</span></span>  
  
-   <span data-ttu-id="ccd5f-148">Все поля должны быть сериализуемыми.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-148">All fields must be serializable.</span></span>  
  
-   <span data-ttu-id="ccd5f-149">Если определяемый пользователем тип задан в виде класса, а не структуры, нужно задать для атрибута `System.Runtime.InteropServices.StructLayoutAttribute` значение `StructLayout.LayoutKindSequential`.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-149">The `System.Runtime.InteropServices.StructLayoutAttribute` must be specified as `StructLayout.LayoutKindSequential` if the UDT is defined in a class and not a structure.</span></span> <span data-ttu-id="ccd5f-150">Этот атрибут управляет физической компоновкой полей данных. Он заставляет члены структуры располагаться в памяти в том порядке, в каком они описаны.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-150">This attribute controls the physical layout of the data fields and is used to force the members to be laid out in the order in which they appear.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="ccd5f-151">использует этот атрибут для задания порядка полей в определяемых пользователем типах с несколькими значениями.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-151">uses this attribute to determine the field order for UDTs with multiple values.</span></span>  
  
 <span data-ttu-id="ccd5f-152">Пример определяемого пользователем типа, определяемого с помощью `Native` сериализации, см. в разделе [определение определяемых пользователем типов](creating-user-defined-types-coding.md)данных.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-152">For an example of a UDT defined with `Native` serialization, see the Point UDT in [Coding User-Defined Types](creating-user-defined-types-coding.md).</span></span>  
  
## <a name="userdefined-serialization"></a><span data-ttu-id="ccd5f-153">Сериализация, заданная пользователем</span><span class="sxs-lookup"><span data-stu-id="ccd5f-153">UserDefined Serialization</span></span>  
 <span data-ttu-id="ccd5f-154">Настройка формата `UserDefined` у атрибута `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute` предоставляет разработчику полный доступ к двоичным форматам.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-154">The `UserDefined` format setting for the `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute` attribute gives the developer full control over the binary format.</span></span> <span data-ttu-id="ccd5f-155">При задании для свойства атрибута `Format` значения `UserDefined` нужно проделать с программным кодом следующее.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-155">When specifying the `Format` attribute property as `UserDefined`, you must do the following in your code:</span></span>  
  
-   <span data-ttu-id="ccd5f-156">Указать необязательное свойство атрибута `IsByteOrdered`.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-156">Specify the optional `IsByteOrdered` attribute property.</span></span> <span data-ttu-id="ccd5f-157">Значение по умолчанию — `false`.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-157">The default value is `false`.</span></span>  
  
-   <span data-ttu-id="ccd5f-158">Задать свойство `MaxByteSize` атрибута `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute`.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-158">Specify the `MaxByteSize` property of the `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute`.</span></span>  
  
-   <span data-ttu-id="ccd5f-159">Написать программный код, реализующий методы `Read` и `Write` данного определяемого пользователем типа, реализовав интерфейс `System.Data.Sql.IBinarySerialize`.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-159">Write code to implement `Read` and `Write` methods for the UDT by implementing the `System.Data.Sql.IBinarySerialize` interface.</span></span>  
  
 <span data-ttu-id="ccd5f-160">Пример определяемого пользователем типа, определяемого с помощью `UserDefined` сериализации, см. в разделе Определение типа валюты в [коде определяемых пользователем типов](creating-user-defined-types-coding.md).</span><span class="sxs-lookup"><span data-stu-id="ccd5f-160">For an example of a UDT defined with `UserDefined` serialization, see the Currency UDT in [Coding User-Defined Types](creating-user-defined-types-coding.md).</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="ccd5f-161">Чтобы поля определяемого пользователем типа можно было использовать в индексе, они должны иметь собственную сериализацию или быть сохраняемыми.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-161">UDT fields must use native serialization or be persisted in order to be indexed.</span></span>  
  
## <a name="serialization-attributes"></a><span data-ttu-id="ccd5f-162">Атрибуты сериализации</span><span class="sxs-lookup"><span data-stu-id="ccd5f-162">Serialization Attributes</span></span>  
 <span data-ttu-id="ccd5f-163">Атрибуты определяют, каким образом сериализация используется для создания хранимых представлений определяемых пользователем типов, а также для передачи таких типов клиенту по значению.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-163">Attributes determine how serialization is used to construct the storage representation of UDTs and to transmit UDTs by value to the client.</span></span> <span data-ttu-id="ccd5f-164">Задание атрибута `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute` обязательно при создании определяемого пользователем типа.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-164">You are required to specify the `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute` when creating the UDT.</span></span> <span data-ttu-id="ccd5f-165">Атрибут `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute` указывает, что класс является определяемым пользователем типом, и задает тип хранения для определяемого пользователем типа.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-165">The `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute` attribute indicates that the class is a UDT and specifies the storage for the UDT.</span></span> <span data-ttu-id="ccd5f-166">По желанию можно задать атрибут `Serializable`, хотя [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] этого не требует.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-166">You can optionally specify the `Serializable` attribute, although [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] does not require this.</span></span>  
  
 <span data-ttu-id="ccd5f-167">Атрибут `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute` имеет следующие свойства.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-167">The `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute` has the following properties.</span></span>  
  
 `Format`  
 <span data-ttu-id="ccd5f-168">Задает формат сериализации — `Native` или `UserDefined`, в зависимости от типов данных, содержащихся в определяемом пользователем типе.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-168">Specifies the serialization format, which can be `Native` or `UserDefined`, depending on the data types of the UDT.</span></span>  
  
 `IsByteOrdered`  
 <span data-ttu-id="ccd5f-169">Значение типа `Boolean`, определяющее, как [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] проводит двоичные сравнения значений данного типа.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-169">A `Boolean` value that determines how [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] performs binary comparisons on the UDT.</span></span>  
  
 `IsFixedLength`  
 <span data-ttu-id="ccd5f-170">Указывает, имеют ли все экземпляры данного определяемого пользователем типа одинаковую длину.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-170">Indicates whether all instances of this UDT are the same length.</span></span>  
  
 `MaxByteSize`  
 <span data-ttu-id="ccd5f-171">Максимальный размер экземпляра в байтах.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-171">The maximum size of the instance, in bytes.</span></span> <span data-ttu-id="ccd5f-172">Необходимо указать `MaxByteSize` с форматом сериализации `UserDefined`.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-172">You must specify `MaxByteSize` with the `UserDefined` serialization format.</span></span> <span data-ttu-id="ccd5f-173">Для определяемого пользователем типа, для которого задана определяемая пользователем сериализация, `MaxByteSize` означает общий размер этого определяемого пользователем типа в сериализованном виде, как указано пользователем.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-173">For a UDT with user-defined serialization specified, `MaxByteSize` refers to the total size of the UDT in its serialized form as defined by the user.</span></span> <span data-ttu-id="ccd5f-174">Значение `MaxByteSize` должно лежать в диапазоне от 1 до 8000; можно установить для него значение -1, чтобы указать, что размер определяемого пользователем типа больше 8000 байтов (общий размер не может превышать максимального размера LOB).</span><span class="sxs-lookup"><span data-stu-id="ccd5f-174">The value of `MaxByteSize` must be in the range of 1 to 8000, or set to -1 to indicate that the UDT is greater than 8000 bytes (the total size cannot exceed the maximum LOB size).</span></span> <span data-ttu-id="ccd5f-175">Рассмотрим определяемый пользователем тип со свойством строкового типа длиной 10 символов (`System.Char`).</span><span class="sxs-lookup"><span data-stu-id="ccd5f-175">Consider a UDT with a property of a string of 10 characters (`System.Char`).</span></span> <span data-ttu-id="ccd5f-176">Когда определяемый пользователем тип сериализуется с помощью BinaryWriter, общий размер сериализованной строки составляет 22 байта: 2 байта на символ Юникода UTF-16, умноженный на максимальное число символов, плюс 2 контрольные байта, вызванные сериализацией двоичного потока.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-176">When the UDT is serialized by using a BinaryWriter, the total size of the serialized string is 22 bytes: 2 bytes per Unicode UTF-16 character, multiplied by the maximum number of characters, plus 2 control bytes of overhead incurred from serializing a binary stream.</span></span> <span data-ttu-id="ccd5f-177">Поэтому при определении значения параметра `MaxByteSize` следует учитывать общий размер сериализованного, определяемого пользователем типа: размер данных, сериализованных в двоичной форме, плюс издержки от сериализации.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-177">Therefore, when determining the value of `MaxByteSize`, the total size of the serialized UDT must be considered: the size of the data serialized in binary form plus the overhead incurred by serialization.</span></span>  
  
 `ValidationMethodName`  
 <span data-ttu-id="ccd5f-178">Имя метода, используемого для проверки экземпляров определяемого пользователем типа.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-178">The name of the method used to validate instances of the UDT.</span></span>  
  
### <a name="setting-isbyteordered"></a><span data-ttu-id="ccd5f-179">Свойство IsByteOrdered</span><span class="sxs-lookup"><span data-stu-id="ccd5f-179">Setting IsByteOrdered</span></span>  
 <span data-ttu-id="ccd5f-180">Когда свойство `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute.IsByteOrdered` имеет значение `true`, это дает гарантию, что сериализованные двоичные данные можно использовать для семантического упорядочивания информации.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-180">When the `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute.IsByteOrdered` property is set to `true`, you are in effect guaranteeing that the serialized binary data can be used for semantic ordering of the information.</span></span> <span data-ttu-id="ccd5f-181">Таким образом, каждый экземпляр объекта побайтно упорядоченного определяемого пользователем типа может иметь лишь одно сериализованное представление.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-181">Thus, each instance of a byte-ordered UDT object can only have one serialized representation.</span></span> <span data-ttu-id="ccd5f-182">Когда [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] проводит операцию сравнения на сериализованных байтах, ее результаты должны быть такими же, как если бы та же операция сравнения проводилась в управляемом коде.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-182">When a comparison operation is performed in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] on the serialized bytes, its results should be the same as if the same comparison operation had taken place in managed code.</span></span> <span data-ttu-id="ccd5f-183">Если параметру `IsByteOrdered` присвоено значение `true`, поддерживаются также следующие функции.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-183">The following features are also supported when `IsByteOrdered` is set to `true`:</span></span>  
  
-   <span data-ttu-id="ccd5f-184">Создание индексов для столбцов этого типа.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-184">The ability to create indexes on columns of this type.</span></span>  
  
-   <span data-ttu-id="ccd5f-185">Создание первичных и внешних ключей, а также ограничений CHECK и UNIQUE для столбцов этого типа.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-185">The ability to create primary and foreign keys as well as CHECK and UNIQUE constraints on columns of this type.</span></span>  
  
-   <span data-ttu-id="ccd5f-186">Использование предложений [!INCLUDE[tsql](../../includes/tsql-md.md)] ORDER BY, GROUP BY и PARTITION BY.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-186">The ability to use [!INCLUDE[tsql](../../includes/tsql-md.md)] ORDER BY, GROUP BY, and PARTITION BY clauses.</span></span> <span data-ttu-id="ccd5f-187">В этих случаях для определения порядка используется двоичное представление типа.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-187">In these cases, the binary representation of the type is used to determine the order.</span></span>  
  
-   <span data-ttu-id="ccd5f-188">Использование операторов сравнения в инструкциях [!INCLUDE[tsql](../../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="ccd5f-188">The ability to use comparison operators in [!INCLUDE[tsql](../../includes/tsql-md.md)] statements.</span></span>  
  
-   <span data-ttu-id="ccd5f-189">Сохранение вычисляемых столбцов этого типа.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-189">The ability to persist computed columns of this type.</span></span>  
  
 <span data-ttu-id="ccd5f-190">Следует заметить, что, когда для свойства `Native` задано значение `UserDefined`, форматы сериализации `IsByteOrdered` и `true` поддерживают следующие операции сравнения:</span><span class="sxs-lookup"><span data-stu-id="ccd5f-190">Note that both the `Native` and `UserDefined` serialization formats support the following comparison operators when `IsByteOrdered` is set to `true`:</span></span>  
  
-   <span data-ttu-id="ccd5f-191">Равно (=)</span><span class="sxs-lookup"><span data-stu-id="ccd5f-191">Equal to (=)</span></span>  
  
-   <span data-ttu-id="ccd5f-192">Не равно (!=)</span><span class="sxs-lookup"><span data-stu-id="ccd5f-192">Not equal to (!=)</span></span>  
  
-   <span data-ttu-id="ccd5f-193">Знак «больше» >)</span><span class="sxs-lookup"><span data-stu-id="ccd5f-193">Greater than (>)</span></span>  
  
-   <span data-ttu-id="ccd5f-194">Знак "меньше" (\<)</span><span class="sxs-lookup"><span data-stu-id="ccd5f-194">Less than (\<)</span></span>  
  
-   <span data-ttu-id="ccd5f-195">Больше или равно (>=)</span><span class="sxs-lookup"><span data-stu-id="ccd5f-195">Greater than or equal to (>=)</span></span>  
  
-   <span data-ttu-id="ccd5f-196">Оператор «Меньше или равно» (<=)</span><span class="sxs-lookup"><span data-stu-id="ccd5f-196">Less than or equal to (<=)</span></span>  
  
### <a name="implementing-nullability"></a><span data-ttu-id="ccd5f-197">Реализация допустимости значений NULL</span><span class="sxs-lookup"><span data-stu-id="ccd5f-197">Implementing Nullability</span></span>  
 <span data-ttu-id="ccd5f-198">Помимо задания нужных атрибутов для сборок, создаваемый класс должен также поддерживать допустимость значений NULL.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-198">In addition to specifying the attributes for your assemblies correctly, your class must also support nullability.</span></span> <span data-ttu-id="ccd5f-199">Определяемые пользователем типы, загружаемые в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], могут работать со значениями NULL, но, чтобы определяемый пользователем тип узнавал значение NULL, класс должен реализовать интерфейс `INullable`.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-199">UDTs loaded into [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] are null-aware, but in order for the UDT to recognize a null value, the class must implement the `INullable` interface.</span></span> <span data-ttu-id="ccd5f-200">Дополнительные сведения и пример реализации допустимости значений NULL в определяемом пользователем типе см. в разделе [написание определяемых пользователем типов](creating-user-defined-types-coding.md).</span><span class="sxs-lookup"><span data-stu-id="ccd5f-200">For more information and an example of how to implement nullability in a UDT, see [Coding User-Defined Types](creating-user-defined-types-coding.md).</span></span>  
  
### <a name="string-conversions"></a><span data-ttu-id="ccd5f-201">Преобразование строк</span><span class="sxs-lookup"><span data-stu-id="ccd5f-201">String Conversions</span></span>  
 <span data-ttu-id="ccd5f-202">Для поддержки преобразования определяемого пользователем типа в строку и восстановления из строки нужно реализовать в классе методы `Parse` и `ToString`.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-202">To support string conversion to and from the UDT, you must provide a `Parse` method and a `ToString` method in your class.</span></span> <span data-ttu-id="ccd5f-203">Метод `Parse` позволяет преобразовывать строку в определяемый пользователем тип.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-203">The `Parse` method allows a string to be converted into a UDT.</span></span> <span data-ttu-id="ccd5f-204">Он должен быть объявлен как `static` (или `Shared` в Visual Basic) и принимать параметр типа `System.Data.SqlTypes.SqlString`.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-204">It must be declared as `static` (or `Shared` in Visual Basic), and take a parameter of type `System.Data.SqlTypes.SqlString`.</span></span> <span data-ttu-id="ccd5f-205">Дополнительные сведения и пример реализации `Parse` `ToString` методов и см. в разделе [кодирование определяемых пользователем типов](creating-user-defined-types-coding.md).</span><span class="sxs-lookup"><span data-stu-id="ccd5f-205">For more information and an example of how to implement the `Parse` and `ToString` methods, see [Coding User-Defined Types](creating-user-defined-types-coding.md).</span></span>  
  
## <a name="xml-serialization"></a><span data-ttu-id="ccd5f-206">XML-сериализация</span><span class="sxs-lookup"><span data-stu-id="ccd5f-206">XML Serialization</span></span>  
 <span data-ttu-id="ccd5f-207">Определяемые пользователем типы должны поддерживать преобразование из типа данных `xml` и в этот тип данных, подчиняясь соглашению для XML-сериализации.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-207">UDTs must support conversion to and from the `xml` data type by conforming to the contract for XML serialization.</span></span> <span data-ttu-id="ccd5f-208">Пространство имен `System.Xml.Serialization` содержит классы, используемые для сериализации объектов в документы или потоки формата XML.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-208">The `System.Xml.Serialization` namespace contains classes that are used to serialize objects into XML format documents or streams.</span></span> <span data-ttu-id="ccd5f-209">По желанию можно реализовать сериализацию `xml` с помощью интерфейса `IXmlSerializable`, предоставляющего настраиваемую XML-сериализацию и десериализацию.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-209">You can choose to implement `xml` serialization by using the `IXmlSerializable` interface, which provides custom formatting for XML serialization and deserialization.</span></span>  
  
 <span data-ttu-id="ccd5f-210">Помимо явных преобразований определяемого пользователем типа в `xml`, XML-сериализация позволяет.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-210">In addition to performing explicit conversions from UDT to `xml`, XML serialization enables you to:</span></span>  
  
-   <span data-ttu-id="ccd5f-211">Применять `Xquery` к значениям экземпляров определяемого пользователем типа после преобразования в тип данных `xml`.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-211">Use `Xquery` over values of UDT instances after conversion to the `xml` data type.</span></span>  
  
-   <span data-ttu-id="ccd5f-212">Использование определяемых пользователем типов в параметризованных запросах и веб-методах с собственными XML-веб-службами в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="ccd5f-212">Use UDTs in parameterized queries and Web methods with Native XML Web Services in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span>  
  
-   <span data-ttu-id="ccd5f-213">Использовать определяемые пользователем типы для получения массовой загрузки XML-данных.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-213">Use UDTs to receive a bulk load of XML data.</span></span>  
  
-   <span data-ttu-id="ccd5f-214">Сериализовать объекты DataSets, содержащие таблицы со столбцами определяемого пользователем типа.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-214">Serialize DataSets that contain tables with UDT columns.</span></span>  
  
 <span data-ttu-id="ccd5f-215">Определяемые пользователем типы не сериализуются в запросах FOR XML.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-215">UDTs are not serialized in FOR XML queries.</span></span> <span data-ttu-id="ccd5f-216">Для выполнения запроса FOR XML, показывающего XML-сериализацию определяемого пользователем типа, нужно явно преобразовать каждый столбец определяемого пользователем типа в тип данных `xml` в предложении SELECT.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-216">To execute a FOR XML query that displays the XML serialization of UDTs, explicitly convert each UDT column to the `xml` data type in the SELECT statement.</span></span> <span data-ttu-id="ccd5f-217">Можно явно преобразовать столбцы в типы `varbinary`, `varchar` или `nvarchar`.</span><span class="sxs-lookup"><span data-stu-id="ccd5f-217">You can also explicitly convert the columns to `varbinary`, `varchar`, or `nvarchar`.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ccd5f-218">См. также:</span><span class="sxs-lookup"><span data-stu-id="ccd5f-218">See Also</span></span>  
 [<span data-ttu-id="ccd5f-219">Создание определяемого пользователем типа</span><span class="sxs-lookup"><span data-stu-id="ccd5f-219">Creating a User-Defined Type</span></span>](creating-user-defined-types.md)  
  
  

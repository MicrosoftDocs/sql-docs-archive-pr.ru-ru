---
title: Преобразования из C в SQL | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- conversions [ODBC], C to SQL
ms.assetid: 7ac098db-9147-4883-8da9-a58ab24a0d31
author: rothja
ms.author: jroth
ms.openlocfilehash: 2ec8856b9c516ff3693da2ebf1077289d414e589
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87666552"
---
# <a name="conversions-from-c-to-sql"></a>Преобразования из C в SQL
  В этом разделе перечислены проблемы, которые следует учитывать при преобразовании из типов C в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] типы даты-времени.  
  
 Преобразования, описанные в следующей таблице, относятся к преобразованиям, совершаемым на клиенте. В случае, когда клиент задает для параметра точность долей секунды, отличную от заданной на сервере, преобразование на клиенте, возможно, завершится успешно, но сервер возвратит ошибку при вызове функций `SQLExecute` или `SQLExecuteDirect`. В частности, ODBC рассматривает любое усечение долей секунды как ошибку, в то время как [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] их округляет; например, округление произойдет при переходе от `datetime2(6)` к `datetime2(2)`. Значения столбцов даты-времени округляются до 1/300 секунды, а в значениях типа smalldatetime сервер устанавливает для секунд значение, равное нулю.  
  
|||||||||  
|-|-|-|-|-|-|-|-|  
||SQL_TYPE_DATE|SQL_TYPE_TIME|SQL_SS_TIME2|SQL_TYPE_TIMESTAMP|SQL_SS_TIMSTAMPOFFSET|SQL_CHAR|SQL_WCHAR|  
|SQL_C_DATE|1|-|-|1,6|1,5,6|1,13|1,13|  
|SQL_C_TIME|-|1|1|1,7|1, 5, 7|1,13|1,13|  
|SQL_C_SS_TIME2|-|1,3|1,10|1,7|1, 5, 7|1,13|1,13|  
|SQL_C_BINARY(SQL_SS_TIME2_STRUCT)|Недоступно|Недоступно|1,10,11|Недоступно|Недоступно|Недоступно|Недоступно|  
|SQL_C_TYPE_TIMESTAMP|1,2|1,3,4|1,4,10|1,10|1,5,10|1,13|1,13|  
|SQL_C_SS_TIMESTAMPOFFSET|1,2,8|1,3,4,8|1,4,8,10|1,8,10|1,10|1,13|1,13|  
|SQL_C_BINARY(SQL_SS_TIMESTAMPOFFSET_STRUCT)|Недоступно|Недоступно|Недоступно|Недоступно|1,10,11|Недоступно|Недоступно|  
|SQL_C_CHAR/SQL_WCHAR (date)|9|9|9|9,6|9,5,6|Недоступно|Недоступно|  
|SQL_C_CHAR/SQL_WCHAR (time2)|9|9, 3|9,10|9,7,10|9,5,7,10|Недоступно|Недоступно|  
|SQL_C_CHAR/SQL_WCHAR (datetime)|9,2|9, 3, 4|9,4,10|9,10|9,5,10|Недоступно|Недоступно|  
|SQL_C_CHAR/SQL_WCHAR (datetimeoffset)|9,2,8|9, 3, 4, 8|9,4,8,10|9,8,10|9,10|Недоступно|Недоступно|  
|SQL_C_BINARY(SQL_DATE_STRUCT)|1,11|Недоступно|Недоступно|Недоступно|Недоступно|Недоступно|Недоступно|  
|SQL_C_BINARY(SQL_TIME_STRUCT)|Недоступно|Недоступно|Недоступно|Недоступно|Недоступно|Недоступно|Недоступно|  
|SQL_C_BINARY(SQL_TIMESTAMP_STRUCT)|Недоступно|Недоступно|Недоступно|Недоступно|Недоступно|Недоступно|Недоступно|  
  
## <a name="key-to-symbols"></a>Расшифровка символов  
  
|Символ|Значение|  
|------------|-------------|  
|-|Преобразование не поддерживается. Создается запись диагностики с кодом SQLSTATE 07006 и сообщением «Нарушение атрибута ограниченного типа данных».|  
|1|Если переданы недопустимые данные, то создается запись диагностики с кодом SQLSTATE 22007 и сообщением «Недопустимый формат даты и времени».|  
|2|Поля времени должны содержать нули, иначе создается запись диагностики с кодом SQLSTATE 22008 и сообщением «Частичное усечение».|  
|3|Дробная часть секунд должна быть равна нулю, в противном случае создается запись диагностики с кодом SQLSTATE 22008 и сообщением «Частичное усечение».|  
|4|Компонент даты не учитывается.|  
|5|Часовой пояс устанавливается в соответствии с часовым поясом клиента.|  
|6|Время установлено в нуль.|  
|7|Дата устанавливается в текущую дату.|  
|8|Время преобразуется из часового пояса клиента в UTC. Если во время этого преобразования возникла ошибка, создается запись диагностики с кодом SQLSTATE 22008 и сообщением «Переполнение поля datetime».|  
|9|Строка проходит синтаксический анализ и преобразуется в значение типа date, datetime, datetimeoffset или времени, в зависимости от первого встреченного знака препинания и наличия остальных компонентов. Затем строка преобразуется в целевой тип согласно правилам, описанным в приведенной выше таблице для типа исходных данных, который выясняется в процессе анализа. Если во время синтаксического анализа обнаружена ошибка, то создается диагностическая запись с кодом SQLSTATE 22018 и сообщением «Недопустимое значение символа для спецификации преобразования». Для параметров типа datetime и smalldatetime, если значение года выходит за пределы допустимого диапазона, создается диагностическая запись с кодом SQLSTATE 22007 и сообщением «Недопустимый формат даты и времени».<br /><br /> Значение datetimeoffset после преобразования во времени в формате UTC должно находиться в пределах диапазона, даже если преобразование во времени в формате UTC не требуется. Причина этого заключается в том, что поток табличных данных и сервер всегда нормализуют время в значениях datetimeoffset для времени в формате UTC, поэтому клиент должен проверять, что значение времени после преобразования во времени в формате UTC находится в пределах поддерживаемого диапазона. Если переданы недопустимые для поддерживаемого диапазона времени в формате UTC данные, то создается диагностическая запись с кодом SQLSTATE 22007 и сообщением «Недопустимый формат даты и времени».|  
|10|Если произошло усечение с потерей данных, то создается запись диагностики с кодом SQLSTATE 22008 и сообщением «Недопустимый формат времени». Эта ошибка также возникает в том случае, если значение выходит за пределы диапазона, который может быть представлен диапазоном времени в формате UTC, используемым сервером.|  
|11|Если байтовая длина данных не равна размеру структуры, нужной для данного типа SQL, то создается диагностическая запись с кодом SQLSTATE 22003 и сообщением «Значение числового параметра за пределами диапазона».|  
|12|Если байтовая длина данных равна 4 или 8, данные посылаются на сервер в необработанном формате потока табличных данных smalldatetime или datetime. Если байтовая длина данных в точности равна размеру структуры SQL_TIMESTAMP_STRUCT, данные преобразуются в формат потока табличных данных для типа datetime2.|  
|13|Если происходит усечение с потерей данных, то создается диагностическая запись с кодом SQLSTATE 22001 и сообщением «Строковые данные, усечение справа».<br /><br /> Количество долей секунды (шкала) определяется исходя из размера целевого столбца в соответствии со следующими параметрами:<br /><br /> **Тип:** SQL_C_TYPE_TIMESTAMP<br /><br /> Подразумеваемый масштаб<br /><br /> 0<br /><br /> 19<br /><br /> Подразумеваемый масштаб<br /><br /> 1.. 9<br /><br /> 21..29<br /><br /> Однако для типа SQL_C_TYPE_TIMESTAMP, если доли секунды можно представить в трех разрядах без потери данных, и размер столбца больше или равен 23, для дробной доли секунды создаются ровно три разряда. Это поведение обеспечивает обратную совместимость с приложениями, разработанными в расчете на более старые драйверы ODBC.<br /><br /> Для размеров столбцов, превышающих диапазон таблицы, подразумевается масштаб 9. Это преобразование должно учитывать доли секунд с точностью до девяти значащих цифр — максимум, поддерживаемый ODBC.<br /><br /> Если для столбца установлен размер, равный нулю, в ODBC это означает неограниченный размер для символьных типов переменной длины (9 разрядов там, где не работает правило трех разрядов для типа SQL_C_TYPE_TIMESTAMP). Задать размер столбца, равный нулю, для символьных типов фиксированной длины будет ошибкой.|  
|Недоступно|Существующий способ работы [!INCLUDE[ssVersion2005](../../includes/ssversion2005-md.md)] и более ранних версий сохранен.|  
  
## <a name="see-also"></a>См. также:  
 [Улучшения даты и времени &#40;ODBC&#41;](date-and-time-improvements-odbc.md)  
  
  

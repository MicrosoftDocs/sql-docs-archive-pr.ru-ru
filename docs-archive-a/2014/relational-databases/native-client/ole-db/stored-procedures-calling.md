---
title: Вызов хранимой процедуры (OLE DB) | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- calling stored procedures
- RPC escape sequence
- OLE DB, stored procedures
- parameters [SQL Server Native Client], OLE DB
- ODBC CALL escape sequence
- stored procedures [OLE DB], calling
- SQL Server Native Client OLE DB provider, stored procedures
ms.assetid: 8e5738e5-4bbe-4f34-bd69-0c0633290bdd
author: rothja
ms.author: jroth
ms.openlocfilehash: 695848c8633d310f5e8ee21e9e738749d1550e4a
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87738195"
---
# <a name="calling-a-stored-procedure-ole-db"></a><span data-ttu-id="0aa4a-102">Вызов хранимой процедуры (OLE DB)</span><span class="sxs-lookup"><span data-stu-id="0aa4a-102">Calling a Stored Procedure (OLE DB)</span></span>
  <span data-ttu-id="0aa4a-103">Хранимая процедура может иметь ноль и более параметров.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-103">A stored procedure can have zero or more parameters.</span></span> <span data-ttu-id="0aa4a-104">Также она может возвращать значение.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-104">It can also return a value.</span></span> <span data-ttu-id="0aa4a-105">При использовании [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] поставщика собственного клиента OLE DB параметры хранимой процедуры могут передаваться следующим образом:</span><span class="sxs-lookup"><span data-stu-id="0aa4a-105">When using the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client OLE DB provider, parameters to a stored procedure can be passed by:</span></span>  
  
-   <span data-ttu-id="0aa4a-106">Заданные в коде значения данных.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-106">Hard-coding the data value.</span></span>  
  
-   <span data-ttu-id="0aa4a-107">Указание параметров с помощью маркера параметра (?), привязка программной переменной к маркеру параметра и последующее помещение значений данных в программную переменную.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-107">Using a parameter marker (?) to specify parameters, bind a program variable to the parameter marker, and then place the data value in the program variable.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="0aa4a-108">При вызове хранимых процедур [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] с использованием именованных параметров в OLE DB имена параметров должны начинаться со знака \@.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-108">When calling [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] stored procedures using named parameters with OLE DB, the parameter names must start with the '\@' character.</span></span> <span data-ttu-id="0aa4a-109">Это ограничение, характерное для [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="0aa4a-109">This is a [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] specific restriction.</span></span> <span data-ttu-id="0aa4a-110">В поставщике OLE DB для собственного клиента [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] это ограничение соблюдается более строго, чем в компонентах MDAC.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-110">The [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client OLE DB provider enforces this restriction more strictly than MDAC.</span></span>  
  
 <span data-ttu-id="0aa4a-111">Для поддержки параметров объект команды предоставляет интерфейс **ICommandWithParameters**.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-111">To support parameters, the **ICommandWithParameters** interface is exposed on the command object.</span></span> <span data-ttu-id="0aa4a-112">Чтобы использовать параметры, потребитель сначала описывает параметры поставщика путем вызова метода **ICommandWithParameters::SetParameterInfo** (или при необходимости готовит инструкцию, вызывающую метод **GetParameterInfo**).</span><span class="sxs-lookup"><span data-stu-id="0aa4a-112">To use parameters, the consumer first describes the parameters to the provider by calling the **ICommandWithParameters::SetParameterInfo** method (or optionally prepares a calling statement that calls the **GetParameterInfo** method).</span></span> <span data-ttu-id="0aa4a-113">Затем потребитель создает метод доступа, определяющий структуру буфера и помещающий значения параметров в этот буфер.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-113">The consumer then creates an accessor that specifies the structure of a buffer and places parameter values in this buffer.</span></span> <span data-ttu-id="0aa4a-114">После этого он передает дескриптор метода доступа и указатель на буфер функции **Execute**.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-114">Finally, it passes the handle of the accessor and a pointer to the buffer to **Execute**.</span></span> <span data-ttu-id="0aa4a-115">При последующих вызовах **Execute** потребитель помещает новые значения параметров в буфер и вызывает функцию **Execute** с дескриптором метода доступа и указателем буфера.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-115">On later calls to **Execute**, the consumer places new parameter values in the buffer and calls **Execute** with the accessor handle and buffer pointer.</span></span>  
  
 <span data-ttu-id="0aa4a-116">Команда, вызывающая временную хранимую процедуру, использующую параметры, сначала должна вызвать метод **ICommandWithParameters::SetParameterInfo** для определения сведений о параметрах, чтобы команду можно было успешно подготовить.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-116">A command that calls a temporary stored procedure using parameters must first call **ICommandWithParameters::SetParameterInfo** to define the parameter information, before the command can be successfully prepared.</span></span> <span data-ttu-id="0aa4a-117">Это происходит по той причине, что внутреннее имя временной хранимой процедуры отличается от внешнего имени, используемого клиентом, а SQLOLEDB не может запрашивать системные таблицы, чтобы определить сведения о параметрах временной хранимой процедуры.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-117">This is because the internal name for a temporary stored procedure differs from the external name used by a client and SQLOLEDB cannot query the system tables to determine the parameter information for a temporary stored procedure.</span></span>  
  
 <span data-ttu-id="0aa4a-118">Далее приведены шаги процесса привязки параметров.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-118">These are the steps in the parameter binding process:</span></span>  
  
1.  <span data-ttu-id="0aa4a-119">Внесите сведения о параметре (имя параметра, специфическое для поставщика имя типа данных параметра или стандартное имя типа данных и т. д.) в массив структур DBPARAMBINDINFO.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-119">Fill in the parameter information in an array of DBPARAMBINDINFO structures; that is, parameter name, provider-specific name for the data type of the parameter or a standard data type name, and so on.</span></span> <span data-ttu-id="0aa4a-120">Каждая структура в массиве описывает один параметр.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-120">Each structure in the array describes one parameter.</span></span> <span data-ttu-id="0aa4a-121">Затем этот массив передается методу **SetParameterInfo**.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-121">This array is then passed to the **SetParameterInfo** method.</span></span>  
  
2.  <span data-ttu-id="0aa4a-122">Вызовите метод **ICommandWithParameters::SetParameterInfo**, чтобы описать параметры для поставщика.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-122">Call the **ICommandWithParameters::SetParameterInfo** method to describe parameters to the provider.</span></span> <span data-ttu-id="0aa4a-123">Метод **SetParameterInfo** определяет собственный тип данных каждого параметра.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-123">**SetParameterInfo** specifies the native data type of each parameter.</span></span> <span data-ttu-id="0aa4a-124">Метод **SetParameterInfo** использует следующие аргументы.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-124">**SetParameterInfo** arguments are:</span></span>  
  
    -   <span data-ttu-id="0aa4a-125">Количество параметров, для которых задаются сведения о типе.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-125">The number of parameters for which to set type information.</span></span>  
  
    -   <span data-ttu-id="0aa4a-126">Массив порядковых номеров параметров, для которых задаются сведения о типе.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-126">An array of parameter ordinals for which to set type information.</span></span>  
  
    -   <span data-ttu-id="0aa4a-127">Массив структур DBPARAMBINDINFO.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-127">An array of DBPARAMBINDINFO structures.</span></span>  
  
3.  <span data-ttu-id="0aa4a-128">Создайте метод доступа к параметру с помощью команды **IAccessor::CreateAccessor**.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-128">Create a parameter accessor by using the **IAccessor::CreateAccessor** command.</span></span> <span data-ttu-id="0aa4a-129">Метод доступа указывает структуру буфера и помещает в буфер значения параметров.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-129">The accessor specifies the structure of a buffer and places parameter values in the buffer.</span></span> <span data-ttu-id="0aa4a-130">Команда **CreateAccessor** создает метод доступа на основе набора привязок.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-130">The **CreateAccessor** command creates an accessor from a set of bindings.</span></span> <span data-ttu-id="0aa4a-131">Эти привязки описываются потребителем с помощью массива структур DBBINDING.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-131">These bindings are described by the consumer by using an array of DBBINDING structures.</span></span> <span data-ttu-id="0aa4a-132">Каждая привязка связывает отдельный параметр с буфером потребителя и содержит следующие сведения.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-132">Each binding associates a single parameter to the buffer of the consumer and contains information such as:</span></span>  
  
    -   <span data-ttu-id="0aa4a-133">Порядковый номер параметра, к которому применяется привязка.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-133">The ordinal of the parameter to which the binding applies.</span></span>  
  
    -   <span data-ttu-id="0aa4a-134">Что привязывается (значение данных, длина и состояние).</span><span class="sxs-lookup"><span data-stu-id="0aa4a-134">What is bound (the data value, its length, and its status).</span></span>  
  
    -   <span data-ttu-id="0aa4a-135">Смещение в буфере для каждой из этих частей.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-135">The offset in the buffer to each of these parts.</span></span>  
  
    -   <span data-ttu-id="0aa4a-136">Длина и тип значения данных в том виде, в котором оно представлено в буфере потребителя.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-136">The length and type of the data value as it exists in the buffer of the consumer.</span></span>  
  
     <span data-ttu-id="0aa4a-137">Метод доступа определяется его дескриптором типа HACCESSOR.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-137">An accessor is identified by its handle, which is of type HACCESSOR.</span></span> <span data-ttu-id="0aa4a-138">Это дескриптор возвращается методом **CreateAccessor**.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-138">This handle is returned by the **CreateAccessor** method.</span></span> <span data-ttu-id="0aa4a-139">Когда потребитель завершает использование метода доступа, он должен вызвать метод **ReleaseAccessor**, чтобы освободить занимаемую память.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-139">Whenever the consumer finishes using an accessor, the consumer must call the **ReleaseAccessor** method to release the memory it holds.</span></span>  
  
     <span data-ttu-id="0aa4a-140">Когда потребитель вызывает метод, например **ICommand::Execute**, он передает дескриптор методу доступа, а указатель непосредственно буферу.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-140">When the consumer calls a method, such as **ICommand::Execute**, it passes the handle to an accessor and a pointer to a buffer itself.</span></span> <span data-ttu-id="0aa4a-141">Поставщик использует этот метод доступа, чтобы определить способ передачи данных из буфера.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-141">The provider uses this accessor to determine how to transfer the data contained in the buffer.</span></span>  
  
4.  <span data-ttu-id="0aa4a-142">Заполните структуру DBPARAMS.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-142">Fill in the DBPARAMS structure.</span></span> <span data-ttu-id="0aa4a-143">Переменные потребителя, из которых берутся значения входных параметров и в которые записываются значения выходных параметров, передаются во время выполнения методу **ICommand::Execute** в структуре DBPARAMS.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-143">The consumer variables from which input parameter values are taken and to which output parameter values are written are passed at run time to **ICommand::Execute** in the DBPARAMS structure.</span></span> <span data-ttu-id="0aa4a-144">Структура DBPARAMS включает три следующих элемента.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-144">The DBPARAMS structure includes three elements:</span></span>  
  
    -   <span data-ttu-id="0aa4a-145">Указатель на буфер, из которого поставщик получает данные входных параметров и в который возвращает данные выходных параметров в соответствии с привязками, указанными дескриптором метода доступа.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-145">A pointer to the buffer from which the provider retrieves input parameter data and to which the provider returns output parameter data, according to the bindings specified by the accessor handle.</span></span>  
  
    -   <span data-ttu-id="0aa4a-146">Количество наборов параметров в буфере.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-146">The number of sets of parameters in the buffer.</span></span>  
  
    -   <span data-ttu-id="0aa4a-147">Дескриптор метода доступа, созданный на шаге 3 .</span><span class="sxs-lookup"><span data-stu-id="0aa4a-147">The accessor handle created in Step 3.</span></span>  
  
5.  <span data-ttu-id="0aa4a-148">Выполните команду с помощью метода **ICommand::Execute**.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-148">Execute the command by using **ICommand::Execute**.</span></span>  
  
## <a name="methods-of-calling-a-stored-procedure"></a><span data-ttu-id="0aa4a-149">Методы вызова хранимых процедур</span><span class="sxs-lookup"><span data-stu-id="0aa4a-149">Methods of Calling a Stored Procedure</span></span>  
 <span data-ttu-id="0aa4a-150">При выполнении хранимой процедуры в [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] службах поставщик OLE DB собственного клиента поддерживает:</span><span class="sxs-lookup"><span data-stu-id="0aa4a-150">When executing a stored procedure in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client OLE DB provider supports the:</span></span>  
  
-   <span data-ttu-id="0aa4a-151">Escape-последовательность ODBC CALL.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-151">ODBC CALL escape sequence.</span></span>  
  
-   <span data-ttu-id="0aa4a-152">Escape-последовательность удаленного вызова процедур (RPC).</span><span class="sxs-lookup"><span data-stu-id="0aa4a-152">Remote procedure call (RPC) escape sequence.</span></span>  
  
-   <span data-ttu-id="0aa4a-153">Инструкция [!INCLUDE[tsql](../../../includes/tsql-md.md)] EXECUTE.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-153">[!INCLUDE[tsql](../../../includes/tsql-md.md)] EXECUTE statement.</span></span>  
  
### <a name="odbc-call-escape-sequence"></a><span data-ttu-id="0aa4a-154">Escape-последовательность ODBC CALL</span><span class="sxs-lookup"><span data-stu-id="0aa4a-154">ODBC CALL Escape Sequence</span></span>  
 <span data-ttu-id="0aa4a-155">Если известны сведения о параметре, вызовите метод **ICommandWithParameters::SetParameterInfo**, чтобы описать параметры для поставщика.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-155">If you know parameter information, call **ICommandWithParameters::SetParameterInfo** method to describe the parameters to the provider.</span></span> <span data-ttu-id="0aa4a-156">В противном случае, если для вызова хранимой процедуры используется синтаксис ODBC CALL, поставщик вызывает вспомогательную функцию для поиска сведений о параметрах хранимой процедуры.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-156">Otherwise, when the ODBC CALL syntax is used in calling a stored procedure, the provider calls a helper function to find the stored procedure parameter information.</span></span>  
  
 <span data-ttu-id="0aa4a-157">Если сведения о параметрах (метаданные параметров) точно неизвестны, рекомендуется применять синтаксис ODBC CALL.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-157">If you are not sure about the parameter information (parameter metadata), ODBC CALL syntax is recommended.</span></span>  
  
 <span data-ttu-id="0aa4a-158">Общий синтаксис для вызова процедуры с помощью escape-последовательности ODBC CALL выглядит следующим образом.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-158">The general syntax for calling a procedure by using the ODBC CALL escape sequence is:</span></span>  
  
 <span data-ttu-id="0aa4a-159">{[**? =**]**вызовите**_procedure_name_[**(**[*параметр*] [**,**[*параметр*]]... **)**]}</span><span class="sxs-lookup"><span data-stu-id="0aa4a-159">{[**?=**]**call**_procedure_name_[**(**[*parameter*][**,**[*parameter*]]...**)**]}</span></span>  
  
 <span data-ttu-id="0aa4a-160">Пример:</span><span class="sxs-lookup"><span data-stu-id="0aa4a-160">For example:</span></span>  
  
```  
{call SalesByCategory('Produce', '1995')}  
```  
  
### <a name="rpc-escape-sequence"></a><span data-ttu-id="0aa4a-161">Escape-последовательность RPC</span><span class="sxs-lookup"><span data-stu-id="0aa4a-161">RPC Escape Sequence</span></span>  
 <span data-ttu-id="0aa4a-162">Escape-последовательность RPC похожа на синтаксис ODBC CALL для вызова хранимой процедуры.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-162">The RPC escape sequence is similar to the ODBC CALL syntax of calling a stored procedure.</span></span> <span data-ttu-id="0aa4a-163">Если нужно вызывать процедуру несколько раз, escape-последовательность RPC обеспечивает наиболее оптимальную производительность из всех трех методов вызова хранимой процедуры.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-163">If you will call the procedure multiple times, the RPC escape sequence provides most optimal performance among the three methods of calling a stored procedure.</span></span>  
  
 <span data-ttu-id="0aa4a-164">Если escape-последовательность RPC используется для выполнения хранимой процедуры, поставщик не вызывает вспомогательные функции для определения сведений о параметре, как в случае применения синтаксиса ODBC CALL.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-164">When the RPC escape sequence is used to execute a stored procedure, the provider does not call any helper function to determine the parameter information (as it does in the case of ODBC CALL syntax).</span></span> <span data-ttu-id="0aa4a-165">Синтаксис RPC проще синтаксиса ODBC CALL, поэтому команда анализируется быстрее, что увеличивает производительность.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-165">The RPC syntax is simpler than the ODBC CALL syntax, so the command is parsed faster, improving performance.</span></span> <span data-ttu-id="0aa4a-166">В этом случае необходимо указать сведения о параметрах путем выполнения метода **ICommandWithParameters::SetParameterInfo**.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-166">In this case, you need to provide the parameter information by executing **ICommandWithParameters::SetParameterInfo**.</span></span>  
  
 <span data-ttu-id="0aa4a-167">Escape-последовательность RPC требует наличия возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-167">The RPC escape sequence requires you to have a return value.</span></span> <span data-ttu-id="0aa4a-168">Если хранимая процедура не возвращает значение, сервер по умолчанию возвращает 0.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-168">If the stored procedure does not return a value, the server returns a 0 by default.</span></span> <span data-ttu-id="0aa4a-169">Кроме того, для хранимой процедуры нельзя открыть курсор [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="0aa4a-169">In addition, you cannot open a [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] cursor on the stored procedure.</span></span> <span data-ttu-id="0aa4a-170">Хранимая процедура подготавливается неявно, и вызов метода **ICommandPrepare::Prepare** завершится ошибкой.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-170">The stored procedure is prepared implicitly and the call to **ICommandPrepare::Prepare** will fail.</span></span> <span data-ttu-id="0aa4a-171">Запрашивать метаданные столбцов нельзя, поскольку невозможно подготовить вызов RPC. Методы IColumnsInfo::GetColumnInfo и IColumnsRowset::GetColumnsRowset будут возвращать значение DB_E_NOTPREPARED.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-171">Because of the inability to prepare an RPC call, you can not query column metadata; IColumnsInfo::GetColumnInfo and IColumnsRowset::GetColumnsRowset will return DB_E_NOTPREPARED.</span></span>  
  
 <span data-ttu-id="0aa4a-172">Если известны все метаданные параметров, для выполнения хранимых процедур рекомендуется использовать escape-последовательность RPC.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-172">If you know all the parameter metadata, RPC escape sequence is the recommended way to execute stored procedures.</span></span>  
  
 <span data-ttu-id="0aa4a-173">Далее приведен пример escape-последовательности RPC для вызова хранимой процедуры.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-173">This is an example of RPC escape sequence for calling a stored procedure:</span></span>  
  
```  
{rpc SalesByCategory}  
```  
  
 <span data-ttu-id="0aa4a-174">Пример приложения, которое демонстрирует применение escape-последовательности RPC, см. в статье [Выполнение хранимой процедуры с использованием RPC и обработка выходных данных](../../native-client-ole-db-how-to/results/execute-stored-procedure-with-rpc-and-process-output.md).</span><span class="sxs-lookup"><span data-stu-id="0aa4a-174">For a sample application that demonstrates an RPC escape sequence, see [Execute a Stored Procedure &#40;Using RPC Syntax&#41; and Process Return Codes and Output Parameters &#40;OLE DB&#41;](../../native-client-ole-db-how-to/results/execute-stored-procedure-with-rpc-and-process-output.md).</span></span>  
  
### <a name="transact-sql-execute-statement"></a><span data-ttu-id="0aa4a-175">Инструкция Transact-SQL EXECUTE</span><span class="sxs-lookup"><span data-stu-id="0aa4a-175">Transact-SQL EXECUTE Statement</span></span>  
 <span data-ttu-id="0aa4a-176">Escape-последовательность ODBC CALL и escape-последовательность RPC — это предпочтительные способы вызова хранимых процедур в отличие от инструкции [EXECUTE](/sql/t-sql/language-elements/execute-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="0aa4a-176">The ODBC CALL escape sequence and the RPC escape sequence are the preferred methods for calling a stored procedure rather than the [EXECUTE](/sql/t-sql/language-elements/execute-transact-sql) statement.</span></span> <span data-ttu-id="0aa4a-177">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]Поставщик OLE DB собственного клиента использует механизм RPC [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] для оптимизации обработки команд.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-177">The [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Native Client OLE DB provider uses the RPC mechanism of [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to optimize command processing.</span></span> <span data-ttu-id="0aa4a-178">Этот протокол RPC повышает производительность, устраняя большую часть обработки параметров и синтаксической проверки инструкций на сервере.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-178">This RPC protocol increases performance by eliminating much of the parameter processing and statement parsing done on the server.</span></span>  
  
 <span data-ttu-id="0aa4a-179">Вот пример инструкции [!INCLUDE[tsql](../../../includes/tsql-md.md)] **EXECUTE**.</span><span class="sxs-lookup"><span data-stu-id="0aa4a-179">This is an example of the [!INCLUDE[tsql](../../../includes/tsql-md.md)] **EXECUTE** statement:</span></span>  
  
```  
EXECUTE SalesByCategory 'Produce', '1995'  
```  
  
## <a name="see-also"></a><span data-ttu-id="0aa4a-180">См. также:</span><span class="sxs-lookup"><span data-stu-id="0aa4a-180">See Also</span></span>  
 [<span data-ttu-id="0aa4a-181">Хранимые процедуры</span><span class="sxs-lookup"><span data-stu-id="0aa4a-181">Stored Procedures</span></span>](stored-procedures.md)  
  
  

---
title: Использование режима EXPLICIT для FOR XML | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: conceptual
helpviewer_keywords:
- EXPLICIT FOR XML mode
- FOR XML clause, EXPLICIT mode
- FOR XML EXPLICIT mode
ms.assetid: 8b26e8ce-5465-4e7a-b237-98d0f4578ab1
author: rothja
ms.author: jroth
ms.openlocfilehash: 7e3db80333c74166301fcff7bb25edea4aca38a2
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87658672"
---
# <a name="use-explicit-mode-with-for-xml"></a><span data-ttu-id="66a0a-102">Использование режима EXPLICIT совместно с предложением FOR XML</span><span class="sxs-lookup"><span data-stu-id="66a0a-102">Use EXPLICIT Mode with FOR XML</span></span>
  <span data-ttu-id="66a0a-103">Как описано в подразделе [Конструирование XML используя FOR XML](../xml/for-xml-sql-server.md), режимы RAW и AUTO не предоставляют больших возможностей контроля формы XML, порождаемого из результата запроса.</span><span class="sxs-lookup"><span data-stu-id="66a0a-103">As described in the topic, [Constructing XML Using FOR XML](../xml/for-xml-sql-server.md), RAW and AUTO mode do not provide much control over the shape of the XML generated from a query result.</span></span> <span data-ttu-id="66a0a-104">Однако режим EXPLICIT предоставляет наибольшую гибкость при формировании желаемого XML из результатов запроса.</span><span class="sxs-lookup"><span data-stu-id="66a0a-104">However, EXPLICIT mode provides the most flexibility in generating the XML you want from a query result.</span></span>  
  
 <span data-ttu-id="66a0a-105">Запрос в режиме EXPLICIT должен быть написан особым способом, при котором в запросе явно задаются дополнительные сведения о требуемом XML, такие как ожидаемый уровень вложенности в XML.</span><span class="sxs-lookup"><span data-stu-id="66a0a-105">The EXPLICIT mode query must be written in a specific way so that the additional information about the required XML, such as expected nesting in the XML, is explicitly specified as part of the query.</span></span> <span data-ttu-id="66a0a-106">В зависимости от запрашиваемого XML написание запросов режима EXPLICIT может оказаться весьма трудоемким.</span><span class="sxs-lookup"><span data-stu-id="66a0a-106">Depending on the XML you request, writing EXPLICIT mode queries can be cumbersome.</span></span> <span data-ttu-id="66a0a-107">Может оказаться, что [использование режима PATH](../xml/use-path-mode-with-for-xml.md) с вложениями является более простой альтернативой написанию запросов в режиме EXPLICIT.</span><span class="sxs-lookup"><span data-stu-id="66a0a-107">You may find that [Using PATH Mode](../xml/use-path-mode-with-for-xml.md) with nesting is a simpler alternative to writing EXPLICIT mode queries.</span></span>  
  
 <span data-ttu-id="66a0a-108">Поскольку требуемый XML описывается в режиме EXPLICIT в самом запросе, следует убедиться в том, что порождаемый XML имеет необходимую форму и является корректным.</span><span class="sxs-lookup"><span data-stu-id="66a0a-108">Because you describe the XML you want as part of the query in EXPLICIT mode, you must ensure that the generated XML is well formed and valid.</span></span>  
  
## <a name="rowset-processing-in-explicit-mode"></a><span data-ttu-id="66a0a-109">Обработка наборов строк в режиме EXPLICIT</span><span class="sxs-lookup"><span data-stu-id="66a0a-109">Rowset Processing in EXPLICIT Mode</span></span>  
 <span data-ttu-id="66a0a-110">Режим EXPLICIT преобразует набор строк, получаемый в результате выполнения запроса, в XML-документ.</span><span class="sxs-lookup"><span data-stu-id="66a0a-110">The EXPLICIT mode transforms the rowset that results from the query execution into an XML document.</span></span> <span data-ttu-id="66a0a-111">Для того чтобы режим EXPLICIT создал XML-документ, набор строк должен иметь определенный формат.</span><span class="sxs-lookup"><span data-stu-id="66a0a-111">In order for EXPLICIT mode to produce the XML document, the rowset must have a specific format.</span></span> <span data-ttu-id="66a0a-112">То есть необходимо написать запрос SELECT для создания набора строк, **универсальной таблицы**, имеющей определенный формат, так чтобы логика обработки могла создать желаемый XML.</span><span class="sxs-lookup"><span data-stu-id="66a0a-112">This requires that you write the SELECT query to produce the rowset, the **universal table**, with a specific format so the processing logic can then produce the XML you want.</span></span>  
  
 <span data-ttu-id="66a0a-113">Во-первых, запрос должен создавать следующие два столбца метаданных:</span><span class="sxs-lookup"><span data-stu-id="66a0a-113">First, the query must produce the following two metadata columns:</span></span>  
  
-   <span data-ttu-id="66a0a-114">первый столбец должен предоставлять номер тега текущего элемента (целочисленного типа), с именем столбца **Tag**.</span><span class="sxs-lookup"><span data-stu-id="66a0a-114">The first column must provide the tag number, integer type, of the current element, and the column name must be **Tag**.</span></span> <span data-ttu-id="66a0a-115">В запросе должен быть указан уникальный номер тега для каждого элемента, который будет создан из набора строк;</span><span class="sxs-lookup"><span data-stu-id="66a0a-115">Your query must provide a unique tag number for each element that will be constructed from the rowset.</span></span>  
  
-   <span data-ttu-id="66a0a-116">второй столбец должен задавать номер тега для родительского элемента, и этот столбец должен иметь имя **Parent**.</span><span class="sxs-lookup"><span data-stu-id="66a0a-116">The second column must provide a tag number of the parent element, and this column name must be **Parent**.</span></span> <span data-ttu-id="66a0a-117">Таким образом, столбцы Tag и Parent предоставляют сведения об иерархии.</span><span class="sxs-lookup"><span data-stu-id="66a0a-117">In this way, the Tag and the Parent column provide hierarchy information.</span></span>  
  
 <span data-ttu-id="66a0a-118">Значения этих столбцов метаданных вместе со сведениями в именах столбцов используются для создания желаемого XML.</span><span class="sxs-lookup"><span data-stu-id="66a0a-118">These metadata column values, together with the information in the column names, are used to produce the XML you want.</span></span> <span data-ttu-id="66a0a-119">Обратите внимание на то, что имена столбцов в запросе должны задаваться особым образом.</span><span class="sxs-lookup"><span data-stu-id="66a0a-119">Note that your query must provide column names in a specific way.</span></span> <span data-ttu-id="66a0a-120">Также обратите внимание на то, что значение 0 или NULL в столбце **Parent** указывает на то, что у соответствующего элемента нет родителя.</span><span class="sxs-lookup"><span data-stu-id="66a0a-120">Also note that a 0 or NULL in the **Parent** column indicates that the corresponding element has no parent.</span></span> <span data-ttu-id="66a0a-121">Такой элемент добавляется в XML в качестве элемента верхнего уровня.</span><span class="sxs-lookup"><span data-stu-id="66a0a-121">The element is added to the XML as a top-level element.</span></span>  
  
 <span data-ttu-id="66a0a-122">Для понимания того, как универсальная таблица, сформированная запросом, преобразуется в результат XML, предположим, что написан запрос, который создает универсальную таблицу.</span><span class="sxs-lookup"><span data-stu-id="66a0a-122">To understand how the universal table generated by a query is processed into generating XML result, assume that you have written a query that produces this universal table:</span></span>  
  
 <span data-ttu-id="66a0a-123">![Образец универсальной таблицы](../../database-engine/media/xmlutable.gif "Образец универсальной таблицы")</span><span class="sxs-lookup"><span data-stu-id="66a0a-123">![Sample universal table](../../database-engine/media/xmlutable.gif "Sample universal table")</span></span>  
  
 <span data-ttu-id="66a0a-124">Обратите внимание на следующие особенности этой универсальной таблицы:</span><span class="sxs-lookup"><span data-stu-id="66a0a-124">Note the following about this universal table:</span></span>  
  
-   <span data-ttu-id="66a0a-125">Первые два столбца **Tag** и **Parent** являются метастолбцами.</span><span class="sxs-lookup"><span data-stu-id="66a0a-125">The first two columns are **Tag** and **Parent** and are meta columns.</span></span> <span data-ttu-id="66a0a-126">Эти значения определяют иерархию.</span><span class="sxs-lookup"><span data-stu-id="66a0a-126">These values determine the hierarchy.</span></span>  
  
-   <span data-ttu-id="66a0a-127">Имена столбцов задаются особым образом, как описано выше в данном подразделе.</span><span class="sxs-lookup"><span data-stu-id="66a0a-127">The column names are specified in a certain way, as described later in this topic.</span></span>  
  
-   <span data-ttu-id="66a0a-128">При формировании XML из этой универсальной таблицы данные таблицы секционируются вертикально на группы столбцов.</span><span class="sxs-lookup"><span data-stu-id="66a0a-128">In generating the XML from this universal table, the data in this table is partitioned vertically into column groups.</span></span> <span data-ttu-id="66a0a-129">Группировка определяется на основании значения **Tag** и имен столбцов.</span><span class="sxs-lookup"><span data-stu-id="66a0a-129">The grouping is determined based on the **Tag** value and the column names.</span></span> <span data-ttu-id="66a0a-130">При конструировании XML логика обработки выбирает одну группу столбцов для каждой строки и создает элемент.</span><span class="sxs-lookup"><span data-stu-id="66a0a-130">In constructing XML, the processing logic selects one group of columns for each row and constructs an element.</span></span> <span data-ttu-id="66a0a-131">В данном примере происходит следующее:</span><span class="sxs-lookup"><span data-stu-id="66a0a-131">The following applies in this example:</span></span>  
  
    -   <span data-ttu-id="66a0a-132">для значения столбца **Tag** , равного 1 в первой строке, столбцы, имена которых включают тот же номер тега, **Customer!1!cid** и **Customer!1!name**, образуют группу.</span><span class="sxs-lookup"><span data-stu-id="66a0a-132">For **Tag** column value 1 in the first row, the columns whose names include the same tag number, **Customer!1!cid** and **Customer!1!name**, form a group.</span></span> <span data-ttu-id="66a0a-133">Эти столбцы используются при обработке строки, и, как можно заметить, формируемый элемент приобретает вид <`Customer id=... name=...`>.</span><span class="sxs-lookup"><span data-stu-id="66a0a-133">These columns are used in processing the row, and you may have noticed that the shape of the generated element is <`Customer id=... name=...`>.</span></span> <span data-ttu-id="66a0a-134">Формат имени столбца описан ниже в этом подразделе;</span><span class="sxs-lookup"><span data-stu-id="66a0a-134">Column name format is described later in this topic.</span></span>  
  
    -   <span data-ttu-id="66a0a-135">для строк со значением столбца **Tag**, равным 2, столбцы **Order!2!id** и **Order!2!date** образуют группу, которая далее используется при конструировании элементов: <`Order id=... date=... /`>;</span><span class="sxs-lookup"><span data-stu-id="66a0a-135">For rows with **Tag** column value 2, columns **Order!2!id** and **Order!2!date** form a group that is then used in constructing elements, <`Order id=... date=... /`>.</span></span>  
  
    -   <span data-ttu-id="66a0a-136">для строк со значением столбца **Tag** , равным 3, столбцы **OrderDetail!3!id!id** и **OrderDetail!3!pid!idref** образуют группу.</span><span class="sxs-lookup"><span data-stu-id="66a0a-136">For rows with **Tag** column value 3, columns **OrderDetail!3!id!id** and **OrderDetail!3!pid!idref** form a group.</span></span> <span data-ttu-id="66a0a-137">Каждая из этих строк формирует из данных столбцов элемент <`OrderDetail id=... pid=...`>;</span><span class="sxs-lookup"><span data-stu-id="66a0a-137">Each of these rows generates an element, <`OrderDetail id=... pid=...`>, from these columns.</span></span>  
  
-   <span data-ttu-id="66a0a-138">обратите внимание на то, что при формировании иерархии XML строки обрабатываются по порядку.</span><span class="sxs-lookup"><span data-stu-id="66a0a-138">Note that in generating XML hierarchy, the rows are processed in order.</span></span> <span data-ttu-id="66a0a-139">Иерархия XML определяется так, как показано далее.</span><span class="sxs-lookup"><span data-stu-id="66a0a-139">The XML hierarchy is determined as shown in the following:</span></span>  
  
    -   <span data-ttu-id="66a0a-140">Первая строка задает значение **Tag** , равное 1, и значение **Parent** , равное NULL.</span><span class="sxs-lookup"><span data-stu-id="66a0a-140">The first row specifies **Tag** value 1 and **Parent** value NULL.</span></span> <span data-ttu-id="66a0a-141">Поэтому соответствующий элемент <`Customer`> добавляется в качестве элемента верхнего уровня XML.</span><span class="sxs-lookup"><span data-stu-id="66a0a-141">Therefore, the corresponding element, <`Customer`> element, is added as a top-level element in the XML.</span></span>  
  
        ```  
        <Customer cid="C1" name="Janine">  
        ```  
  
    -   <span data-ttu-id="66a0a-142">Вторая строка задает значение **Tag** , равное 2, и значение **Parent** , равное 1.</span><span class="sxs-lookup"><span data-stu-id="66a0a-142">The second row identifies **Tag** value 2 and **Parent** value 1.</span></span> <span data-ttu-id="66a0a-143">Поэтому элемент <`Order`> добавляется в качестве дочернего к элементу <`Customer`>.</span><span class="sxs-lookup"><span data-stu-id="66a0a-143">Therefore, the element, <`Order`> element, is added as a child of the <`Customer`> element.</span></span>  
  
        ```  
        <Customer cid="C1" name="Janine">  
           <Order id="O1" date="1/20/1996">  
        ```  
  
    -   <span data-ttu-id="66a0a-144">Следующие две строки задают значение **Tag** , равное 3, и значение **Parent** , равное 2.</span><span class="sxs-lookup"><span data-stu-id="66a0a-144">The next two rows identify **Tag** value 3 and **Parent** value 2.</span></span> <span data-ttu-id="66a0a-145">Поэтому два элемента <`OrderDetail`> добавляются в качестве дочерних к элементу <`Order`>.</span><span class="sxs-lookup"><span data-stu-id="66a0a-145">Therefore, the two elements, <`OrderDetail`> elements, are added as children of the <`Order`> element.</span></span>  
  
        ```  
        <Customer cid="C1" name="Janine">  
           <Order id="O1" date="1/20/1996">  
              <OrderDetail id="OD1" pid="P1"/>  
              <OrderDetail id="OD2" pid="P2"/>  
        ```  
  
    -   <span data-ttu-id="66a0a-146">Последняя строка задает 2 в качестве номера **Tag** и 1 в качестве номера тэга **Parent** .</span><span class="sxs-lookup"><span data-stu-id="66a0a-146">The last row identifies 2 as the **Tag** number and 1 as the **Parent** tag number.</span></span> <span data-ttu-id="66a0a-147">Поэтому другой элемент-потомок <`Order`> добавляется к родительскому элементу <`Customer`>.</span><span class="sxs-lookup"><span data-stu-id="66a0a-147">Therefore, another <`Order`> element child is added to the <`Customer`> parent element.</span></span>  
  
        ```  
        <Customer cid="C1" name="Janine">  
           <Order id="O1" date="1/20/1996">  
              <OrderDetail id="OD1" pid="P1"/>  
              <OrderDetail id="OD2" pid="P2"/>  
           </Order>  
           <Order id="O2" date="3/29/1997">  
        </Customer>  
        ```  
  
 <span data-ttu-id="66a0a-148">В итоге, значения в метастолбцах **Tag** и **Parent** , сведения, указанные в именах столбцов, и правильный порядок строк создают желаемый XML при использовании режима EXPLICIT.</span><span class="sxs-lookup"><span data-stu-id="66a0a-148">To summarize, the values in the **Tag** and **Parent** meta columns, the information provided in the column names, and the correct ordering of the rows produce the XML you want when you use EXPLICIT mode.</span></span>  
  
### <a name="universal-table-row-ordering"></a><span data-ttu-id="66a0a-149">Упорядочение строк универсальной таблицы</span><span class="sxs-lookup"><span data-stu-id="66a0a-149">Universal Table Row Ordering</span></span>  
 <span data-ttu-id="66a0a-150">При конструировании XML строки в универсальной таблице обрабатываются по порядку.</span><span class="sxs-lookup"><span data-stu-id="66a0a-150">In constructing the XML, the rows in the universal table are processed in order.</span></span> <span data-ttu-id="66a0a-151">Поэтому для получения правильных экземпляров потомков, ассоциированных с их родителями строки в наборе строк должны быть упорядочены так, чтобы за каждым родительским узлом следовали его потомки.</span><span class="sxs-lookup"><span data-stu-id="66a0a-151">Therefore, to retrieve the correct children instances associated with their parent, the rows in the rowset must be ordered so that each parent node is immediately followed by its children.</span></span>  
  
## <a name="specifying-column-names-in-a-universal-table"></a><span data-ttu-id="66a0a-152">Указание имен столбцов в универсальной таблице</span><span class="sxs-lookup"><span data-stu-id="66a0a-152">Specifying Column Names in a Universal Table</span></span>  
 <span data-ttu-id="66a0a-153">При написании запросов в режиме EXPLICIT имена столбцов в результирующем наборе строк должны быть заданы с использованием описанного далее формата.</span><span class="sxs-lookup"><span data-stu-id="66a0a-153">When writing EXPLICIT mode queries, column names in the resulting rowset must be specified by using this format.</span></span> <span data-ttu-id="66a0a-154">Они предоставляют сведения о преобразовании, включая имена элементов и атрибутов и другие дополнительные сведения, задаваемые при помощи директив.</span><span class="sxs-lookup"><span data-stu-id="66a0a-154">They provide transformation information including element and attribute names and other additional information, specified by using directives.</span></span>  
  
 <span data-ttu-id="66a0a-155">Общий формат имеет вид:</span><span class="sxs-lookup"><span data-stu-id="66a0a-155">This is the general format:</span></span>  
  
```  
  
ElementName!TagNumber!AttributeName!Directive  
```  
  
 <span data-ttu-id="66a0a-156">Далее следует описание частей формата.</span><span class="sxs-lookup"><span data-stu-id="66a0a-156">Following is the description of the parts of the format.</span></span>  
  
 <span data-ttu-id="66a0a-157">*ElementName*</span><span class="sxs-lookup"><span data-stu-id="66a0a-157">*ElementName*</span></span>  
 <span data-ttu-id="66a0a-158">Результирующий общий идентификатор элемента.</span><span class="sxs-lookup"><span data-stu-id="66a0a-158">Is the resulting generic identifier of the element.</span></span> <span data-ttu-id="66a0a-159">Например, если **Customers** задано в качестве *ElementName*, формируется элемент \<Customers>.</span><span class="sxs-lookup"><span data-stu-id="66a0a-159">For example, if **Customers** is specified as *ElementName*, the \<Customers> element is generated.</span></span>  
  
 <span data-ttu-id="66a0a-160">*TagNumber*</span><span class="sxs-lookup"><span data-stu-id="66a0a-160">*TagNumber*</span></span>  
 <span data-ttu-id="66a0a-161">Уникальное значение тега, присвоенное элементу.</span><span class="sxs-lookup"><span data-stu-id="66a0a-161">Is a unique tag value assigned to an element.</span></span> <span data-ttu-id="66a0a-162">Это значение с помощью двух метастолбцов, **Tag** и **Parent**, определяет вложенность элементов в результирующем XML.</span><span class="sxs-lookup"><span data-stu-id="66a0a-162">This value, with the help of the two metadata columns, **Tag** and **Parent**, determines the nesting of the elements in the resulting XML.</span></span>  
  
 <span data-ttu-id="66a0a-163">*AttributeName*</span><span class="sxs-lookup"><span data-stu-id="66a0a-163">*AttributeName*</span></span>  
 <span data-ttu-id="66a0a-164">Предоставляет имя создаваемого атрибута для указанного элемента *ElementName*.</span><span class="sxs-lookup"><span data-stu-id="66a0a-164">Provides the name of the attribute to construct in the specified *ElementName*.</span></span> <span data-ttu-id="66a0a-165">Это поведение используется, если не задано значение *Directive* .</span><span class="sxs-lookup"><span data-stu-id="66a0a-165">This is the behavior if *Directive* is not specified.</span></span>  
  
 <span data-ttu-id="66a0a-166">Если задано значение *Directive* , имеющее тип **xml**, **cdata**или **element**, оно используется для создания дочернего элемента *ElementName*, к которому добавляется значение столбца.</span><span class="sxs-lookup"><span data-stu-id="66a0a-166">If *Directive* is specified and it is **xml**, **cdata**, or **element**, this value is used to construct an element child of *ElementName*, and the column value is added to it.</span></span>  
  
 <span data-ttu-id="66a0a-167">При указании значения *Directive*значение *AttributeName* может быть пустым.</span><span class="sxs-lookup"><span data-stu-id="66a0a-167">If you specify the *Directive*, the *AttributeName* can be empty.</span></span> <span data-ttu-id="66a0a-168">Например: ElementName!TagNumber!!Directive.</span><span class="sxs-lookup"><span data-stu-id="66a0a-168">For example, ElementName!TagNumber!!Directive.</span></span> <span data-ttu-id="66a0a-169">В этом случае значение столбца напрямую содержится в *ElementName*.</span><span class="sxs-lookup"><span data-stu-id="66a0a-169">In this case, the column value is directly contained by the *ElementName*.</span></span>  
  
 <span data-ttu-id="66a0a-170">*Directive*</span><span class="sxs-lookup"><span data-stu-id="66a0a-170">*Directive*</span></span>  
 <span data-ttu-id="66a0a-171">Значение*Directive* является необязательным и может использоваться с целью предоставления дополнительных сведений для создания XML.</span><span class="sxs-lookup"><span data-stu-id="66a0a-171">*Directive* is optional and you can use it to provide additional information for construction of the XML.</span></span> <span data-ttu-id="66a0a-172">Значение*Directive* служит двум целям.</span><span class="sxs-lookup"><span data-stu-id="66a0a-172">*Directive* has two purposes.</span></span>  
  
 <span data-ttu-id="66a0a-173">Одной из целей является кодирование значений в виде ID, IDREF и IDREFS.</span><span class="sxs-lookup"><span data-stu-id="66a0a-173">One of the purposes is to encode values as ID, IDREF, and IDREFS.</span></span> <span data-ttu-id="66a0a-174">Можно указать ключевые слова **ID**, **IDREF**и **IDREFS** в качестве значений *Directive*.</span><span class="sxs-lookup"><span data-stu-id="66a0a-174">You can specify **ID**, **IDREF**, and **IDREFS** keywords as *Directives*.</span></span> <span data-ttu-id="66a0a-175">Эти директивы переопределяют типы атрибутов.</span><span class="sxs-lookup"><span data-stu-id="66a0a-175">These directives overwrite the attribute types.</span></span> <span data-ttu-id="66a0a-176">Это позволяет создавать связи внутри документа.</span><span class="sxs-lookup"><span data-stu-id="66a0a-176">This allows you to create intra-document links.</span></span>  
  
 <span data-ttu-id="66a0a-177">Также можно использовать значение *Directive* для указания того, как сопоставлять строковые данные с XML.</span><span class="sxs-lookup"><span data-stu-id="66a0a-177">Also, you can use *Directive* to indicate how to map the string data to XML.</span></span> <span data-ttu-id="66a0a-178">Ключевые слова **hide**, **element, elementxsinil**, **xml**, **xmltext**и **cdata** также могут быть использованы в качестве значения *Directive*.</span><span class="sxs-lookup"><span data-stu-id="66a0a-178">The **hide**, **element, elementxsinil**, **xml**, **xmltext**, and **cdata** keywords can be used as the *Directive*.</span></span> <span data-ttu-id="66a0a-179">Директива **hide** скрывает узел.</span><span class="sxs-lookup"><span data-stu-id="66a0a-179">The **hide** directive hides the node.</span></span> <span data-ttu-id="66a0a-180">Это полезно, если некоторые значения извлекаются только в целях сортировки и не должны появляться в результирующем XML.</span><span class="sxs-lookup"><span data-stu-id="66a0a-180">This is useful when you retrieve values only for sorting purposes, but you do not want them in the resulting XML.</span></span>  
  
 <span data-ttu-id="66a0a-181">Директива **element** формирует содержащийся элемент вместо атрибута.</span><span class="sxs-lookup"><span data-stu-id="66a0a-181">The **element** directive generates a contained element instead of an attribute.</span></span> <span data-ttu-id="66a0a-182">Содержащиеся данные кодируются как сущность.</span><span class="sxs-lookup"><span data-stu-id="66a0a-182">The contained data is encoded as an entity.</span></span> <span data-ttu-id="66a0a-183">Например, символ **<** превращается в &lt;.</span><span class="sxs-lookup"><span data-stu-id="66a0a-183">For example, the **<** character becomes &lt;.</span></span> <span data-ttu-id="66a0a-184">Для значений столбцов, равных NULL, элемент не формируется.</span><span class="sxs-lookup"><span data-stu-id="66a0a-184">For NULL column values, no element is generated.</span></span> <span data-ttu-id="66a0a-185">Если требуется, чтобы для столбцов со значениями NULL формировался элемент, можно указать директиву **elementxsinil** .</span><span class="sxs-lookup"><span data-stu-id="66a0a-185">If you want an element generated for null column values, you can specify the **elementxsinil** directive.</span></span> <span data-ttu-id="66a0a-186">При этом будет сформирован элемент с атрибутом xsi:nil=TRUE.</span><span class="sxs-lookup"><span data-stu-id="66a0a-186">This will generate an element that has the attribute xsi:nil=TRUE.</span></span>  
  
 <span data-ttu-id="66a0a-187">Директива **xml** аналогична директиве **element** , однако при ее использовании не происходит кодирования сущности.</span><span class="sxs-lookup"><span data-stu-id="66a0a-187">The **xml** directive is the same as an **element** directive, except that no entity encoding occurs.</span></span> <span data-ttu-id="66a0a-188">Обратите внимание на то, что директива **element** может быть совмещена с **ID**, **IDREF**или **IDREFS**, в то время как директива **xml** не допускает совмещения с любой другой директивой, кроме **hide**.</span><span class="sxs-lookup"><span data-stu-id="66a0a-188">Note that the **element** directive can be combined with **ID**, **IDREF**, or **IDREFS**, whereas the **xml** directive is not allowed with any other directive, except **hide**.</span></span>  
  
 <span data-ttu-id="66a0a-189">Директива **cdata** содержит данные путем упаковывания их с помощью раздела CDATA.</span><span class="sxs-lookup"><span data-stu-id="66a0a-189">The **cdata** directive contains the data by wrapping it with a CDATA section.</span></span> <span data-ttu-id="66a0a-190">Содержимое не кодируется в виде сущности.</span><span class="sxs-lookup"><span data-stu-id="66a0a-190">The content is not entity encoded.</span></span> <span data-ttu-id="66a0a-191">Первоначальный тип данных должен быть текстовым, например **varchar**, **nvarchar**, **text**или **ntext**.</span><span class="sxs-lookup"><span data-stu-id="66a0a-191">The original data type must be a text type such as **varchar**, **nvarchar**, **text**, or **ntext**.</span></span> <span data-ttu-id="66a0a-192">Эта директива может использоваться только совместно с **hide**.</span><span class="sxs-lookup"><span data-stu-id="66a0a-192">This directive can be used only with **hide**.</span></span> <span data-ttu-id="66a0a-193">При использовании этой директивы не следует задавать значение *AttributeName* .</span><span class="sxs-lookup"><span data-stu-id="66a0a-193">When this directive is used, *AttributeName* must not be specified.</span></span>  
  
 <span data-ttu-id="66a0a-194">Комбинирование директив из двух разных групп в большинстве случаев допустимо, однако комбинирование директив одной группы недопустимо.</span><span class="sxs-lookup"><span data-stu-id="66a0a-194">Combining directives between these two groups is allowed in most cases, but combining them among themselves is not allowed.</span></span>  
  
 <span data-ttu-id="66a0a-195">Если значения *Directive* и *AttributeName* не заданы, например **Customer!1**, подразумевается директива **element** , то есть **Customer!1!!element**, а данные столбца содержатся в *ElementName*.</span><span class="sxs-lookup"><span data-stu-id="66a0a-195">If the *Directive* and the *AttributeName* is not specified, for example, **Customer!1**, an **element** directive is implied, such as **Customer!1!!element**, and column data is contained in the *ElementName*.</span></span>  
  
 <span data-ttu-id="66a0a-196">Если задана директива **xmltext** , содержимое столбца упаковывается в один тэг, который интегрируется с оставшейся частью документа.</span><span class="sxs-lookup"><span data-stu-id="66a0a-196">If the **xmltext** directive is specified, the column content is wrapped in a single tag that is integrated with the rest of the document.</span></span> <span data-ttu-id="66a0a-197">Эта директива полезна при выборке перегруженных, неиспользуемых XML-данных, сохраненных в столбец при помощи OPENXML.</span><span class="sxs-lookup"><span data-stu-id="66a0a-197">This directive is useful in fetching overflow, unconsumed, XML data stored in a column by OPENXML.</span></span> <span data-ttu-id="66a0a-198">Дополнительные сведения см в разделе [OPENXML (SQL Server)](../xml/openxml-sql-server.md).</span><span class="sxs-lookup"><span data-stu-id="66a0a-198">For more information, see [OPENXML &#40;SQL Server&#41;](../xml/openxml-sql-server.md).</span></span>  
  
 <span data-ttu-id="66a0a-199">Если задано значение *AttributeName* , имя тега заменяется указанным именем.</span><span class="sxs-lookup"><span data-stu-id="66a0a-199">If *AttributeName* is specified, the tag name is replaced by the specified name.</span></span> <span data-ttu-id="66a0a-200">В противном случае атрибут добавляется к текущему списку атрибутов включаемых элементов путем помещения содержимого в начало содержимого без кодирования сущности.</span><span class="sxs-lookup"><span data-stu-id="66a0a-200">Otherwise, the attribute is appended to the current list of attributes of the enclosing elements by putting the content at the beginning of the containment without entity encoding.</span></span> <span data-ttu-id="66a0a-201">Столбец с этой директивой должен быть текстового типа, например **varchar**, **nvarchar**, **char**, **nchar**, **text**или **ntext**.</span><span class="sxs-lookup"><span data-stu-id="66a0a-201">The column with this directive must be a text type, such as **varchar**, **nvarchar**, **char**, **nchar**, **text**, or **ntext**.</span></span> <span data-ttu-id="66a0a-202">Эта директива может использоваться только совместно с **hide**.</span><span class="sxs-lookup"><span data-stu-id="66a0a-202">This directive can be used only with **hide**.</span></span> <span data-ttu-id="66a0a-203">Эта директива полезна при выборке перегруженных данных, хранящихся в столбце.</span><span class="sxs-lookup"><span data-stu-id="66a0a-203">This directive is useful in fetching overflow data stored in a column.</span></span> <span data-ttu-id="66a0a-204">Если содержимое не является корректным XML, поведение не определено.</span><span class="sxs-lookup"><span data-stu-id="66a0a-204">If the content is not a well-formed XML, the behavior is undefined.</span></span>  
  
## <a name="in-this-section"></a><span data-ttu-id="66a0a-205">в этом разделе</span><span class="sxs-lookup"><span data-stu-id="66a0a-205">In This Section</span></span>  
 <span data-ttu-id="66a0a-206">В следующем примере демонстрируется применение режима EXPLICIT.</span><span class="sxs-lookup"><span data-stu-id="66a0a-206">The following examples illustrate the use of EXPLICIT mode.</span></span>  
  
-   [<span data-ttu-id="66a0a-207">Пример. Получение сведений о сотрудниках</span><span class="sxs-lookup"><span data-stu-id="66a0a-207">Example: Retrieving Employee Information</span></span>](../xml/example-retrieving-employee-information.md)  
  
-   [<span data-ttu-id="66a0a-208">Пример. Указание директивы ELEMENT</span><span class="sxs-lookup"><span data-stu-id="66a0a-208">Example: Specifying the ELEMENT Directive</span></span>](../xml/example-specifying-the-element-directive.md)  
  
-   [<span data-ttu-id="66a0a-209">Пример. Задание директивы ELEMENTXSINIL</span><span class="sxs-lookup"><span data-stu-id="66a0a-209">Example: Specifying the ELEMENTXSINIL Directive</span></span>](../xml/example-specifying-the-elementxsinil-directive.md)  
  
-   [<span data-ttu-id="66a0a-210">Пример. Конструирование одноуровневых элементов в режиме EXPLICIT</span><span class="sxs-lookup"><span data-stu-id="66a0a-210">Example: Constructing Siblings with EXPLICIT Mode</span></span>](../xml/example-constructing-siblings-with-explicit-mode.md)  
  
-   [<span data-ttu-id="66a0a-211">Пример. Указание директив ID и IDREF</span><span class="sxs-lookup"><span data-stu-id="66a0a-211">Example: Specifying the ID and IDREF Directives</span></span>](../xml/example-specifying-the-id-and-idref-directives.md)  
  
-   [<span data-ttu-id="66a0a-212">Пример. Указание директив ID и IDREFS</span><span class="sxs-lookup"><span data-stu-id="66a0a-212">Example: Specifying the ID and IDREFS Directives</span></span>](../xml/example-specifying-the-id-and-idrefs-directives.md)  
  
-   [<span data-ttu-id="66a0a-213">Пример. Указание директивы HIDE</span><span class="sxs-lookup"><span data-stu-id="66a0a-213">Example: Specifying the HIDE Directive</span></span>](../xml/example-specifying-the-hide-directive.md)  
  
-   [<span data-ttu-id="66a0a-214">Пример. Указание директивы ELEMENT и кодировка сущности</span><span class="sxs-lookup"><span data-stu-id="66a0a-214">Example: Specifying the ELEMENT Directive and Entity Encoding</span></span>](../xml/example-specifying-the-element-directive-and-entity-encoding.md)  
  
-   [<span data-ttu-id="66a0a-215">Пример. Задание директивы CDATA</span><span class="sxs-lookup"><span data-stu-id="66a0a-215">Example: Specifying the CDATA Directive</span></span>](../xml/example-specifying-the-cdata-directive.md)  
  
-   [<span data-ttu-id="66a0a-216">Пример. Указание директивы XMLTEXT</span><span class="sxs-lookup"><span data-stu-id="66a0a-216">Example: Specifying the XMLTEXT Directive</span></span>](../xml/example-specifying-the-xmltext-directive.md)  
  
## <a name="see-also"></a><span data-ttu-id="66a0a-217">См. также:</span><span class="sxs-lookup"><span data-stu-id="66a0a-217">See Also</span></span>  
 <span data-ttu-id="66a0a-218">[Использование с RAW Mode для FOR XML](../xml/use-raw-mode-with-for-xml.md) </span><span class="sxs-lookup"><span data-stu-id="66a0a-218">[Use RAW Mode with FOR XML](../xml/use-raw-mode-with-for-xml.md) </span></span>  
 <span data-ttu-id="66a0a-219">[Использование режима AUTO совместно с FOR XML](../xml/use-auto-mode-with-for-xml.md) </span><span class="sxs-lookup"><span data-stu-id="66a0a-219">[Use AUTO Mode with FOR XML](../xml/use-auto-mode-with-for-xml.md) </span></span>  
 <span data-ttu-id="66a0a-220">[Использование режима PATH совместно с FOR XML](../xml/use-path-mode-with-for-xml.md) </span><span class="sxs-lookup"><span data-stu-id="66a0a-220">[Use PATH Mode with FOR XML](../xml/use-path-mode-with-for-xml.md) </span></span>  
 <span data-ttu-id="66a0a-221">[SELECT (Transact-SQL)](/sql/t-sql/queries/select-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="66a0a-221">[SELECT &#40;Transact-SQL&#41;](/sql/t-sql/queries/select-transact-sql) </span></span>  
 [<span data-ttu-id="66a0a-222">FOR XML (SQL Server)</span><span class="sxs-lookup"><span data-stu-id="66a0a-222">FOR XML &#40;SQL Server&#41;</span></span>](../xml/for-xml-sql-server.md)  
  
  

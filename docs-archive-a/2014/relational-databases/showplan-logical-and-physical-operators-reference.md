---
title: Справочник по логическим и физическим операторам Showplan | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
f1_keywords:
- sql12.swb.showplan.nestedloops.f1
- sql12.swb.showplan.dynamic.f1
- sql12.swb.showplan.tableinsert.f1
- sql12.swb.showplan.remoteinsert.f1
- sql12.swb.showplan.lazyspool.f1
- sql12.swb.showplan.RIDLookup
- sql12.swb.showplan.hashmatchteam.f1
- sql12.swb.showplan.tablespool.f1
- sql12.swb.showplan.print.f1
- sql12.swb.showplan.clusteredindexupdate.f1
- sql12.swb.showplan.assert.f1
- sql12.swb.showplan.columnstoreindexscan.f1
- sql12.swb.showplan.tablevaluedfunction.f1
- sql12.swb.showplan.split.f1
- sql12.swb.showplan.union.f1
- sql12.swb.showplan.clusteredindexseek.f1
- sql12.swb.showplan.indexspool.f1
- sql12.swb.showplan.indexinsert.f1
- sql12.swb.showplan.clusteredindexscan.f1
- sql12.swb.showplan.buildhash.f1
- sql12.swb.showplan.clusteredindexmerge.f1
- sql12.swb.showplan.sequence.f1
- sql12.swb.showplan.hashmatchroot.f1
- sql12.swb.showplan.columnstoreindexupdate.f1
- sql12.swb.showplan.rightsemijoin.f1
- sql12.swb.showplan.fetchquery.f1
- sql12.swb.showplan.distinct.f1
- sql12.swb.showplan.hashmatch.f1
- sql12.swb.showplan.segment.f1
- sql12.swb.showplan.top.f1
- sql12.swb.showplan.columnstoreindexdelete.f1
- sql12.swb.showplan.gatherstreams.f1
- sql12.swb.showplan.remotedelete.f1
- sql12.swb.showplan.insert.f1
- sql12.swb.showplan.declare.f1
- sql12.swb.showplan.snapshot.f1
- sql12.swb.showplan.assign.f1
- sql12.swb.showplan.intrinsic.f1
- sql12.swb.showplan.mergejoin.f1
- sql12.swb.showplan.concatenation.f1
- sql12.swb.showplan.rowcountspool.f1
- sql12.swb.showplan.parametertablescan.f1
- sql12.swb.showplan.indexscan.f1
- sql12.swb.showplan.while.f1
- sql12.swb.showplan.columnstoreindexinsert.f1
- sql12.swb.showplan.tablemerge.f1
- sql12.swb.showplan.spool.f1
- sql12.swb.showplan.streamaggregate.f1
- sql12.swb.showplan.update.f1
- sql12.swb.showplan.innerjoin.f1
- sql12.swb.showplan.flowdistinct.f1
- sql12.swb.showplan.tableupdate.f1
- sql12.swb.showplan.result.f1
- sql12.swb.showplan.bitmap.f1
- sql12.swb.showplan.remoteindexseek.f1
- sql12.swb.showplan.populationquery.f1
- sql12.swb.showplan.rightouterjoin.f1
- sql12.swb.showplan.columnstoreindexmerge.f1
- sql12.swb.showplan.remotescan.f1
- sql12.swb.showplan.remoteupdate.f1
- sql12.swb.showplan.keyset.f1
- sql12.swb.showplan.collapse.f1
- sql12.swb.showplan.arithmeticexpression.f1
- sql12.swb.showplan.clusteredindexinsert.f1
- sql12.swb.showplan.computescalar
- sql12.swb.showplan.sort.f1
- sql12.swb.showplan.locate.f1
- sql12.swb.showplan.constantscan.f1
- sql12.swb.showplan.computescalar.f1
- sql12.swb.showplan.indexseek.f1
- sql12.swb.showplan.leftsemijoin.f1
- sql12.swb.showplan.leftantisemijoin.f1
- sql12.swb.showplan.fullouterjoin.f1
- sql12.swb.showplan.filter.f1
- sql12.swb.showplan.indexdelete.f1
- sql12.swb.showplan.repartitionstreams.f1
- sql12.swb.showplan.crossjoin.f1
- sql12.swb.showplan.mergeinterval.f1
- sql12.swb.showplan.bookmarklookup.f1
- sql12.swb.showplan.convert.f1
- sql12.swb.showplan.refreshquery.f1
- sql12.swb.showplan.distinctsort.f1
- sql12.swb.showplan.leftouterjoin.f1
- sql12.swb.showplan.rightantisemijoin.f1
- sql12.swb.showplan.deletedscan.f1
- sql12.swb.showplan.udx.f1
- sql12.swb.showplan.broadcast.f1
- sql12.swb.showplan.delete.f1
- sql12.swb.showplan.aggregate.f1
- sql12.swb.showplan.setfunction.f1
- sql12.swb.showplan.switch.f1
- sql12.swb.showplan.remoteindexscan.f1
- sql12.swb.showplan.eagerspool.f1
- sql12.swb.showplan.indexupdate.f1
- sql12.swb.showplan.keylookup.f1
- sql12.swb.showplan.branchrepartition.f1
- sql12.swb.showplan.rank.f1
- sql12.swb.showplan.tablescan.f1
- sql12.swb.showplan.distributestreams.f1
- sql12.swb.showplan.logrowscan.f1
- sql12.swb.showplan.parallelism.f1
- sql12.swb.showplan.bitmapcreate.f1
- sql12.swb.showplan.insertedscan.f1
- sql12.swb.showplan.tabledelete.f1
- sql12.swb.showplan.clusteredindexdelete.f1
- sql12.swb.showplan.remotequery.f1
- sql12.swb.showplan.if.f1
- sql12.swb.showplan.cache.f1
- sql12.swb.showplan.partialaggregate.f1
- sql12.swb.showplan.sql.f1
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
author: rothja
ms.author: jroth
ms.openlocfilehash: bc45a5fa14785294093385e6f90b47a8bdb6dff3
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87733769"
---
# <a name="showplan-logical-and-physical-operators-reference"></a><span data-ttu-id="5a2a2-102">Справочник по логическим и физическим операторам Showplan</span><span class="sxs-lookup"><span data-stu-id="5a2a2-102">Showplan Logical and Physical Operators Reference</span></span>
  <span data-ttu-id="5a2a2-103">Операторы описывают, как [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] выполняет запрос или инструкцию языка DML.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-103">Operators describe how [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] executes a query or a Data Manipulation Language (DML) statement.</span></span> <span data-ttu-id="5a2a2-104">Оптимизатор запросов использует операторы для построения плана запроса, чтобы создать результат, заданный в запросе, или произвести операцию, указанную в инструкции DML.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-104">The query optimizer uses operators to build a query plan to create the result specified in the query, or to perform the operation specified in the DML statement.</span></span> <span data-ttu-id="5a2a2-105">План запроса — это дерево физических операторов.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-105">The query plan is a tree consisting of physical operators.</span></span> <span data-ttu-id="5a2a2-106">Можно просмотреть план запроса с помощью инструкций SET SHOWPLAN, параметров графического плана выполнения в среде [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]и классов событий SQL Server Profiler Showplan.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-106">You can view the query plan by using the SET SHOWPLAN statements, the graphical execution plan options in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], or the SQL Server Profiler Showplan event classes.</span></span>  
  
 <span data-ttu-id="5a2a2-107">Операторы классифицируются как логические и физические.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-107">Operators are classified as logical and physical operators.</span></span>  
  
 <span data-ttu-id="5a2a2-108">**Логические операторы**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-108">**Logical Operators**</span></span>  
 <span data-ttu-id="5a2a2-109">Логические операторы описывают операции реляционной алгебры, используемые для обработки инструкции.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-109">Logical operators describe the relational algebraic operation used to process a statement.</span></span> <span data-ttu-id="5a2a2-110">Другими словами, логические операторы описывают на концептуальном уровне, какие действия следует совершить.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-110">In other words, logical operators describe conceptually what operation needs to be performed.</span></span>  
  
 <span data-ttu-id="5a2a2-111">**Физические операторы**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-111">**Physical Operators**</span></span>  
 <span data-ttu-id="5a2a2-112">Физические операторы реализуют действия, описанные логическими операторами.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-112">Physical operators implement the operation described by logical operators.</span></span> <span data-ttu-id="5a2a2-113">Каждый физический оператор является объектом или процедурой, выполняющей операцию.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-113">Each physical operator is an object or routine that performs an operation.</span></span> <span data-ttu-id="5a2a2-114">Например, некоторые физические операторы обращаются к столбцам и строкам таблицы, индекса или представления.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-114">For example, some physical operators access columns or rows from a table, index or view.</span></span> <span data-ttu-id="5a2a2-115">Другие физические операторы выполняют другие операции, такие как вычисления, статистическая обработка, проверка целостности данных или соединения.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-115">Other physical operators perform other operations such as calculations, aggregations, data integrity checks or joins.</span></span> <span data-ttu-id="5a2a2-116">Физическим операторам соответствует их стоимость.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-116">Physical operators have costs associated with them.</span></span>  
  
 <span data-ttu-id="5a2a2-117">Физические операторы производят инициализацию, собирают данные и закрываются.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-117">The physical operators initialize, collect data, and close.</span></span> <span data-ttu-id="5a2a2-118">Если формулировать более конкретно, физический оператор может ответить на вызов трех следующих методов.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-118">Specifically, the physical operator can answer the following three method calls:</span></span>  
  
-   <span data-ttu-id="5a2a2-119">**Init()** : метод **Init()** заставляет физический оператор инициализировать себя и подготовить все необходимые структуры данных.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-119">**Init()**: The **Init()** method causes a physical operator to initialize itself and set up any required data structures.</span></span> <span data-ttu-id="5a2a2-120">Физический оператор может получать много вызовов **Init()** , хотя обычно получает лишь один.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-120">The physical operator may receive many **Init()** calls, though typically a physical operator receives only one.</span></span>  
  
-   <span data-ttu-id="5a2a2-121">**GetNext()** : метод **GetNext()** заставляет физический оператор получить первую или последующую строку данных.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-121">**GetNext()**: The **GetNext()** method causes a physical operator to get the first, or subsequent row of data.</span></span> <span data-ttu-id="5a2a2-122">Физический оператор может получить много вызовов **GetNext()** или не получить ни одного.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-122">The physical operator may receive zero or many **GetNext()** calls.</span></span>  
  
-   <span data-ttu-id="5a2a2-123">**Close()** : при вызове метода **Close()** физический оператор выполняет некоторые действия по очистке и закрывается.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-123">**Close()**: The **Close()** method causes a physical operator to perform some clean-up operations and shut itself down.</span></span> <span data-ttu-id="5a2a2-124">Физический оператор получает только один вызов **Close()** .</span><span class="sxs-lookup"><span data-stu-id="5a2a2-124">A physical operator only receives one **Close()** call.</span></span>  
  
 <span data-ttu-id="5a2a2-125">Метод **GetNext()** возвращает одну строку данных, а число его вызовов отображается значением **ActualRows** в выводе инструкции Showplan, который формируется с использованием инструкций SET STATISTICS PROFILE ON или SET STATISTICS XML ON.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-125">The **GetNext()** method returns one row of data, and the number of times it is called appears as **ActualRows** in the Showplan output that is produced by using SET STATISTICS PROFILE ON or SET STATISTICS XML ON.</span></span> <span data-ttu-id="5a2a2-126">Дополнительные сведения об этих параметрах SET см. в разделах [SET STATISTICS PROFILE (Transact-SQL)](/sql/t-sql/statements/set-statistics-profile-transact-sql) и [SET STATISTICS XML (Transact-SQL)](/sql/t-sql/statements/set-statistics-xml-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="5a2a2-126">For more information about these SET options, see [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-profile-transact-sql) and [SET STATISTICS XML &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-xml-transact-sql).</span></span>  
  
 <span data-ttu-id="5a2a2-127">Счетчики **ActualRebinds** и **ActualRewinds**, которые появляются в выводе инструкции Showplan, указывают на число вызовов метода **Init()** .</span><span class="sxs-lookup"><span data-stu-id="5a2a2-127">The **ActualRebinds** and **ActualRewinds** counts that appear in Showplan output refer to the number of times that the **Init()** method is called.</span></span> <span data-ttu-id="5a2a2-128">Если оператор не находится внутри цикла соединения, **ActualRebinds** равняется одному, а **ActualRewinds** нулю.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-128">Unless an operator is on the inner side of a loop join, **ActualRebinds** equals one and **ActualRewinds** equals zero.</span></span> <span data-ttu-id="5a2a2-129">Если оператор находится внутри цикла соединения, сумма числа повторных привязок и сбросов на начало должна равняться количеству строк, обработанных снаружи цикла.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-129">If an operator is on the inner side of a loop join, the sum of the number of rebinds and rewinds should equal the number of rows processed on the outer side of the join.</span></span> <span data-ttu-id="5a2a2-130">Повторная привязка значит, что изменился один и более связанный параметр соединения, и внутреннюю часть нужно пересчитать.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-130">A rebind means that one or more of the correlated parameters of the join changed and the inner side must be reevaluated.</span></span> <span data-ttu-id="5a2a2-131">Сброс на начало значит, что не изменился ни один из связанных параметров и можно вновь использовать прежний внутренний результирующий набор.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-131">A rewind means that none of the correlated parameters changed and the prior inner result set may be reused.</span></span>  
  
 <span data-ttu-id="5a2a2-132">Счетчики**ActualRebinds** и **ActualRewinds** присутствуют в выводе инструкции Showplan в формате XML, который произведен с использованием инструкции SET STATISTICS XML ON.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-132">**ActualRebinds** and **ActualRewinds** are present in XML Showplan output produced by using SET STATISTICS XML ON.</span></span> <span data-ttu-id="5a2a2-133">Они заполняются только для **некластеризованной очереди индексов**, `Remote Query` , **строки с буферизацией строк**, `Sort` , **буферизации таблицы**и **возвращающих** табличное значение функций.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-133">They are only populated for the **Nonclustered Index Spool**, `Remote Query`, **Row Count Spool**, `Sort`, **Table Spool**, and **Table-valued Function** operators.</span></span> <span data-ttu-id="5a2a2-134">**Счетчики actualrebinds** и **ActualRewinds** также могут быть заполнены для `Assert` операторов **фильтров** и, если атрибут **startupexpression установлен** имеет значение true.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-134">**ActualRebinds** and **ActualRewinds** may also be populated for the `Assert` and **Filter** operators when the **StartupExpression** attribute is set to TRUE.</span></span>  
  
 <span data-ttu-id="5a2a2-135">Когда счетчики **ActualRebinds** и **ActualRewinds** присутствуют в выводе инструкции Showplan в формате XML, их значения сравнимы со значениями **EstimateRebinds** и **EstimateRewinds**.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-135">When **ActualRebinds** and **ActualRewinds** are present in an XML Showplan, they are comparable to **EstimateRebinds** and **EstimateRewinds**.</span></span> <span data-ttu-id="5a2a2-136">Когда они отсутствуют, оценочное число строк (**EstimateRows**) сравнимо с действительным числом строк (**ActualRows**).</span><span class="sxs-lookup"><span data-stu-id="5a2a2-136">When they are absent, the estimated number of rows (**EstimateRows**) is comparable to the actual number of rows (**ActualRows**).</span></span> <span data-ttu-id="5a2a2-137">Обратите внимание, что действительный графический вывод Showplan отображает нули для действительных повторных привязок и сбросов на начало, когда те отсутствуют.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-137">Note that actual graphical Showplan output displays zeros for the actual rebinds and actual rewinds when they are absent.</span></span>  
  
 <span data-ttu-id="5a2a2-138">Связанный счетчик **ActualEndOfScans**доступен только в том случае, когда вывод инструкции Showplan производится с помощью инструкции SET STATISTICS XML ON.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-138">A related counter, **ActualEndOfScans**, is available only when Showplan output is produced by using SET STATISTICS XML ON.</span></span> <span data-ttu-id="5a2a2-139">Всякий раз, когда физический оператор достигает конца потока данных, этот счетчик увеличивается на единицу.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-139">Whenever a physical operator reaches the end of its data stream, this counter is incremented by one.</span></span> <span data-ttu-id="5a2a2-140">Физический оператор может достигать конца своего потока данных ни одного, один или несколько раз.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-140">A physical operator can reach the end of its data stream zero, one, or multiple times.</span></span> <span data-ttu-id="5a2a2-141">Как и в случае с повторными привязками и сбросами на начало, число окончаний просмотров может превышать единицу только в том случае, если оператор находится внутри цикла соединения.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-141">As with rebinds and rewinds, the number of end of scans can be more than one only if the operator is on the inner side of a loop join.</span></span> <span data-ttu-id="5a2a2-142">Количество окончаний просмотров должно быть меньше или равно сумме количеств повторных привязок и сбросов на начало.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-142">The number of end of scans should be less than or equal to the sum of the number of rebinds and rewinds.</span></span>  
  
## <a name="mapping-physical-and-logical-operators"></a><span data-ttu-id="5a2a2-143">Сопоставление физических и логических операторов</span><span class="sxs-lookup"><span data-stu-id="5a2a2-143">Mapping Physical and Logical Operators</span></span>  
 <span data-ttu-id="5a2a2-144">Оптимизатор запросов создает план запроса в виде дерева логических операторов.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-144">The query optimizer creates a query plan as a tree consisting of logical operators.</span></span> <span data-ttu-id="5a2a2-145">После этого оптимизатор запросов выбирает наиболее эффективный физический оператор для каждого логического.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-145">After the query optimizer creates the plan, the query optimizer chooses the most efficient physical operator for each logical operator.</span></span> <span data-ttu-id="5a2a2-146">Оптимизатор запросов использует подход, основанный на стоимости, чтобы определить, с помощью какого физического оператора будет реализован логический.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-146">The query optimizer uses a cost-based approach to determine which physical operator will implement a logical operator.</span></span>  
  
 <span data-ttu-id="5a2a2-147">Обычно логическую операцию можно реализовать с помощью нескольких физических операторов.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-147">Usually, a logical operation can be implemented by multiple physical operators.</span></span> <span data-ttu-id="5a2a2-148">Однако в редких случаях физический оператор может реализовывать несколько логических операций.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-148">However, in rare cases, a physical operator can implement multiple logical operations as well.</span></span>  
  
## <a name="operator-descriptions"></a><span data-ttu-id="5a2a2-149">Описание оператора</span><span class="sxs-lookup"><span data-stu-id="5a2a2-149">Operator Descriptions</span></span>  
 <span data-ttu-id="5a2a2-150">Этот раздел содержит описания логических и физических операторов.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-150">This section contains descriptions of the logical and physical operators.</span></span>  
  
|<span data-ttu-id="5a2a2-151">Значок графического плана выполнения</span><span class="sxs-lookup"><span data-stu-id="5a2a2-151">Graphical Execution Plan Icon</span></span>|<span data-ttu-id="5a2a2-152">Оператор Showplan</span><span class="sxs-lookup"><span data-stu-id="5a2a2-152">Showplan Operator</span></span>|<span data-ttu-id="5a2a2-153">Описание</span><span class="sxs-lookup"><span data-stu-id="5a2a2-153">Description</span></span>|  
|-----------------------------------|-----------------------|-----------------|  
|<span data-ttu-id="5a2a2-154">None</span><span class="sxs-lookup"><span data-stu-id="5a2a2-154">None</span></span>|`Aggregate`|<span data-ttu-id="5a2a2-155">Оператор `Aggregate` вычисляет выражения с функциями MIN, MAX, SUM, COUNT или AVG.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-155">The `Aggregate` operator calculates an expression containing MIN, MAX, SUM, COUNT or AVG.</span></span> <span data-ttu-id="5a2a2-156">Оператор `Aggregate` может быть логическим или физическим.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-156">The `Aggregate` operator can be a logical operator or a physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-157">![Значок оператора Arithmetic Expression](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "Значок оператора Arithmetic Expression")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-157">![Arithmetic expression operator icon](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "Arithmetic expression operator icon")</span></span>|`Arithmetic Expression`|<span data-ttu-id="5a2a2-158">Оператор `Arithmetic Expression` вычисляет новое значение на основе существующих значений в строке.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-158">The `Arithmetic Expression` operator computes a new value from existing values in a row.</span></span> <span data-ttu-id="5a2a2-159">Оператор `Arithmetic Expression` не используется в [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5a2a2-159">`Arithmetic Expression` is not used in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span>|  
|<span data-ttu-id="5a2a2-160">![Значок оператора Assert](../../2014/database-engine/media/assert-32x.gif "Значок оператора Assert")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-160">![Assert operator icon](../../2014/database-engine/media/assert-32x.gif "Assert operator icon")</span></span>|`Assert`|<span data-ttu-id="5a2a2-161">Оператор `Assert` проверяет условие.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-161">The `Assert` operator verifies a condition.</span></span> <span data-ttu-id="5a2a2-162">Например, этот оператор проверяет целостность ссылок или гарантирует, что скалярный вложенный запрос возвращает одну строку.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-162">For example, it validates referential integrity or ensures that a scalar subquery returns one row.</span></span> <span data-ttu-id="5a2a2-163">Для каждой входной строки `Assert` оператор вычисляет выражение в `Argument` столбце плана выполнения.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-163">For each input row, the `Assert` operator evaluates the expression in the `Argument` column of the execution plan.</span></span> <span data-ttu-id="5a2a2-164">Если значением этого выражения является NULL, строка передается через оператор `Assert` и выполнение запроса продолжается.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-164">If this expression evaluates to NULL, the row is passed through the `Assert` operator and the query execution continues.</span></span> <span data-ttu-id="5a2a2-165">При значении этого выражения, отличном от NULL, будет выдана соответствующая ошибка.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-165">If this expression evaluates to a nonnull value, the appropriate error will be raised.</span></span> <span data-ttu-id="5a2a2-166">`Assert` является физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-166">The `Assert` operator is a physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-167">![Значок элемента Assign Language](../../2014/database-engine/media/assign-32.gif "Значок элемента Assign Language")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-167">![Assign language element icon](../../2014/database-engine/media/assign-32.gif "Assign language element icon")</span></span>|`Assign`|<span data-ttu-id="5a2a2-168">Оператор `Assign` присваивает переменной значение выражения или константы.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-168">The `Assign` operator assigns the value of an expression or a constant to a variable.</span></span> <span data-ttu-id="5a2a2-169">`Assign` является элементом языка.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-169">`Assign` is a language element.</span></span>|  
|<span data-ttu-id="5a2a2-170">Нет</span><span class="sxs-lookup"><span data-stu-id="5a2a2-170">None</span></span>|`Asnyc Concat`|<span data-ttu-id="5a2a2-171">Оператор `Asnyc Concat` применяется только в удаленных запросах (распределенных запросах).</span><span class="sxs-lookup"><span data-stu-id="5a2a2-171">The `Asnyc Concat` operator is used only in remote queries (distributed queries).</span></span> <span data-ttu-id="5a2a2-172">Он имеет *n* дочерних узлов и один родительский узел.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-172">It has *n* children and one parent node.</span></span> <span data-ttu-id="5a2a2-173">Обычно некоторые дочерние узлы являются удаленными компьютерами, участвующими в распределенном запросе.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-173">Usually, some of the children are remote computers that participate in a distributed query.</span></span> <span data-ttu-id="5a2a2-174">Оператор `Asnyc Concat` выполняет вызовы методов `open()` одновременно ко всем дочерним узлам, а затем применяет к каждому битовую карту.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-174">`Asnyc Concat` issues `open()` calls to all of the children simultaneously and then applies a bitmap to each child.</span></span> <span data-ttu-id="5a2a2-175">Для каждого бита, равного 1, оператор `Async Concat` по запросу отправляет выходные строки родительскому узлу.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-175">For each bit that is a 1, `Async Concat` sends the output rows to the parent node on demand.</span></span>|  
|<span data-ttu-id="5a2a2-176">![Значок оператора Bitmap](../../2014/database-engine/media/bitmap-32x.gif "Значок оператора Bitmap")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-176">![Bitmap operator icon](../../2014/database-engine/media/bitmap-32x.gif "Bitmap operator icon")</span></span>|`Bitmap`|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]<span data-ttu-id="5a2a2-177">использует `Bitmap` оператор для реализации фильтрации по битовым картам в параллельных планах запросов.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-177">uses the `Bitmap` operator to implement bitmap filtering in parallel query plans.</span></span> <span data-ttu-id="5a2a2-178">Фильтрация по битовым картам ускоряет выполнение запроса, исключая строки со значениями ключа, которые не могут создавать записи объединения, перед передачей строк через другой оператор, например `Parallelism` оператор.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-178">Bitmap filtering speeds up query execution by eliminating rows with key values that cannot produce any join records before passing rows through another operator such as the `Parallelism` operator.</span></span> <span data-ttu-id="5a2a2-179">Фильтр по битовым картам использует компактное представление набора значений из таблицы, находящейся в одной части дерева операторов, для фильтрации строк из другой таблицы, находящейся в другой части дерева.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-179">A bitmap filter uses a compact representation of a set of values from a table in one part of the operator tree to filter rows from a second table in another part of the tree.</span></span> <span data-ttu-id="5a2a2-180">Если сразу удалять ненужные строки в запросе, последующие операторы работают с меньшим количеством строк, тем самым повышая общую производительность.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-180">By removing unnecessary rows early in the query, subsequent operators have fewer rows to work with, and the overall performance of the query improves.</span></span> <span data-ttu-id="5a2a2-181">Оптимизатор определяет, достаточно ли избирательна битовая маска, чтобы быть полезной, и в каких операторах применить фильтр.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-181">The optimizer determines when a bitmap is selective enough to be useful and in which operators to apply the filter.</span></span> <span data-ttu-id="5a2a2-182">`Bitmap` является физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-182">`Bitmap` is a physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-183">![Значок оператора Bitmap](../../2014/database-engine/media/bitmap-32x.gif "Значок оператора Bitmap")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-183">![Bitmap operator icon](../../2014/database-engine/media/bitmap-32x.gif "Bitmap operator icon")</span></span>|`Bitmap Create`|<span data-ttu-id="5a2a2-184">Оператор `Bitmap Create` появляется на выходе инструкции Showplan, в которой строятся битовые маски.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-184">The `Bitmap Create` operator appears in the Showplan output where bitmaps are built.</span></span> <span data-ttu-id="5a2a2-185">`Bitmap Create` является логическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-185">`Bitmap Create` is a logical operator.</span></span>|  
|<span data-ttu-id="5a2a2-186">![Значок оператора Bookmark Lookup](../../2014/database-engine/media/bookmark-lookup-32x.gif "Значок оператора Bookmark Lookup")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-186">![Bookmark lookup operator icon](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark lookup operator icon")</span></span>|`Bookmark Lookup`|<span data-ttu-id="5a2a2-187">Оператор `Bookmark Lookup` производит поиск соответствующей строки в таблице или кластеризованном индексе по закладке (идентификатору строки или ключу кластеризации).</span><span class="sxs-lookup"><span data-stu-id="5a2a2-187">The `Bookmark Lookup` operator uses a bookmark (row ID or clustering key) to look up the corresponding row in the table or clustered index.</span></span> <span data-ttu-id="5a2a2-188">`Argument`Столбец содержит метку закладки, используемую для поиска строки в таблице или кластеризованном индексе.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-188">The `Argument` column contains the bookmark label used to look up the row in the table or clustered index.</span></span> <span data-ttu-id="5a2a2-189">`Argument`Столбец также содержит имя таблицы или кластеризованного индекса, в котором выполняется поиск строки.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-189">The `Argument` column also contains the name of the table or clustered index in which the row is looked up.</span></span> <span data-ttu-id="5a2a2-190">Если в столбце присутствует предложение WITH упреждающей выборки `Argument` , обработчик запросов определил, что оптимально использовать асинхронную предварительную выборку (упреждающее чтение) при поиске закладок в таблице или кластеризованном индексе.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-190">If the WITH PREFETCH clause appears in the `Argument` column, the query processor has determined that it is optimal to use asynchronous prefetching (read-ahead) when looking up bookmarks in the table or clustered index.</span></span><br /><br /> <span data-ttu-id="5a2a2-191">Оператор `Bookmark Lookup` не используется в [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5a2a2-191">`Bookmark Lookup` is not used in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span> <span data-ttu-id="5a2a2-192">Вместо этого функцию поиска закладок обеспечивают операторы `Clustered Index Seek` и `RID Lookup`.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-192">Instead, `Clustered Index Seek` and `RID Lookup` provide bookmark lookup functionality.</span></span> <span data-ttu-id="5a2a2-193">Оператор `Key Lookup` также выполняет данные функции.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-193">The `Key Lookup` operator also provides this functionality.</span></span>|  
|<span data-ttu-id="5a2a2-194">Нет</span><span class="sxs-lookup"><span data-stu-id="5a2a2-194">None</span></span>|`Branch Repartition`|<span data-ttu-id="5a2a2-195">В плане параллельных запросов иногда содержатся концептуальные области итераторов.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-195">In a parallel query plan, sometimes there are conceptual regions of iterators.</span></span> <span data-ttu-id="5a2a2-196">Все итераторы в рамках такой области могут обрабатываться параллельными потоками.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-196">All of the iterators within such a region can be executed by parallel threads.</span></span> <span data-ttu-id="5a2a2-197">Сами же области должны обрабатываться последовательно.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-197">The regions themselves must be executed serially.</span></span> <span data-ttu-id="5a2a2-198">Некоторые итераторы оператора `Parallelism` внутри отдельной области называются `Branch Repartition`.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-198">Some of the `Parallelism` iterators within an individual region are called `Branch Repartition`.</span></span> <span data-ttu-id="5a2a2-199">Итератор оператора `Parallelism` на границе двух таких областей называется `Segment Repartition`.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-199">The `Parallelism` iterator at the boundary of two such regions is called `Segment Repartition`.</span></span> <span data-ttu-id="5a2a2-200">`Branch Repartition` и `Segment Repartition` являются логическими операторами.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-200">`Branch Repartition` and `Segment Repartition` are logical operators.</span></span>|  
|<span data-ttu-id="5a2a2-201">Нет</span><span class="sxs-lookup"><span data-stu-id="5a2a2-201">None</span></span>|`Broadcast`|<span data-ttu-id="5a2a2-202">`Broadcast`имеет один дочерний узел и *n* родительских узлов.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-202">`Broadcast` has one child node and *n* parent nodes.</span></span> <span data-ttu-id="5a2a2-203">`Broadcast` рассылает входные строки нескольким получателям по требованию.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-203">`Broadcast` sends its input rows to multiple consumers on demand.</span></span> <span data-ttu-id="5a2a2-204">Каждый пользователь получает полный набор строк.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-204">Each consumer gets all of the rows.</span></span> <span data-ttu-id="5a2a2-205">Например, если все получатели являются элементами хэш-соединения, то будет создано *n* копий хэш-таблиц.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-205">For example, if all of the consumers are build sides of a hash join, then *n* copies of the hash tables will be built.</span></span>|  
|<span data-ttu-id="5a2a2-206">![Значок оператора Build Hash](../../2014/database-engine/media/build-hash.gif "Значок оператора Build Hash")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-206">![Build hash operator icon](../../2014/database-engine/media/build-hash.gif "Build hash operator icon")</span></span>|`Build Hash`|<span data-ttu-id="5a2a2-207">Указывает сборку хэш-таблицы пакета для индекса columnstore, оптимизированного для памяти xVelocity.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-207">Indicates the build of a batch hash table for an xVelocity memory optimized columnstore index.</span></span>|  
|<span data-ttu-id="5a2a2-208">None</span><span class="sxs-lookup"><span data-stu-id="5a2a2-208">None</span></span>|`Cache`|<span data-ttu-id="5a2a2-209">`Cache`является специализированной версией оператора **spool** .</span><span class="sxs-lookup"><span data-stu-id="5a2a2-209">`Cache` is a specialized version of the **Spool** operator.</span></span> <span data-ttu-id="5a2a2-210">Он сохраняет только одну строку данных.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-210">It stores only one row of data.</span></span> <span data-ttu-id="5a2a2-211">`Cache` является логическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-211">`Cache` is a logical operator.</span></span> <span data-ttu-id="5a2a2-212">Оператор `Cache` не используется в [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5a2a2-212">`Cache` is not used in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span>|  
|<span data-ttu-id="5a2a2-213">![Значок оператора Clustered Index Delete](../../2014/database-engine/media/clustered-index-delete-32x.gif "Значок оператора Clustered Index Delete")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-213">![Clustered index delete operator icon](../../2014/database-engine/media/clustered-index-delete-32x.gif "Clustered index delete operator icon")</span></span>|`Clustered Index Delete`|<span data-ttu-id="5a2a2-214">Оператор `Clustered Index Delete` удаляет строки из кластеризованного индекса, заданного в столбце Argument плана выполнения запроса.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-214">The `Clustered Index Delete` operator deletes rows from the clustered index specified in the Argument column of the query execution plan.</span></span> <span data-ttu-id="5a2a2-215">При наличии в столбце Argument предиката WHERE:() удаляются только строки, удовлетворяющие условиям предиката.`Clustered Index Delete`</span><span class="sxs-lookup"><span data-stu-id="5a2a2-215">If a WHERE:() predicate is present in the Argument column, then only those rows that satisfy the predicate are deleted.`Clustered Index Delete`</span></span> <span data-ttu-id="5a2a2-216"> является физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-216">is a physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-217">![Значок оператора Clustered Index Insert](../../2014/database-engine/media/clustered-index-insert-32x.gif "Значок оператора Clustered Index Insert")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-217">![Clustered index insert operator icon](../../2014/database-engine/media/clustered-index-insert-32x.gif "Clustered index insert operator icon")</span></span>|`Clustered Index Insert`|<span data-ttu-id="5a2a2-218">Оператор `Clustered Index Insert` инструкции Showplan вставляет строки со своего входа в кластеризованный индекс, указанный в столбце Argument.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-218">The `Clustered Index Insert` Showplan operator inserts rows from its input into the clustered index specified in the Argument column.</span></span> <span data-ttu-id="5a2a2-219">В столбце Argument также содержится предикат SET:(), который указывает значение, устанавливаемое для каждого столбца.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-219">The Argument column also contains a SET:() predicate, which indicates the value to which each column is set.</span></span> <span data-ttu-id="5a2a2-220">Если не `Clustered Index Insert` имеет дочерних элементов для вставки значений, вставляемая строка берется из `Insert` самого оператора.`Clustered Index Insert`</span><span class="sxs-lookup"><span data-stu-id="5a2a2-220">If `Clustered Index Insert` has no children for insert values, the row inserted is taken from the `Insert` operator itself.`Clustered Index Insert`</span></span> <span data-ttu-id="5a2a2-221"> является физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-221">is a physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-222">![Оператор Clustered Index Merge](../../2014/database-engine/media/clustered-index-merge-32x.gif "Оператор Clustered Index Merge")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-222">![Clustered index merge operator](../../2014/database-engine/media/clustered-index-merge-32x.gif "Clustered index merge operator")</span></span>|<span data-ttu-id="5a2a2-223">**Clustered Index Merge**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-223">**Clustered Index Merge**</span></span>|<span data-ttu-id="5a2a2-224">Оператор **Clustered Index Merge** применяет поток данных слияния к кластеризованному индексу.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-224">The **Clustered Index Merge** operator applies a merge data stream to a clustered index.</span></span> <span data-ttu-id="5a2a2-225">Оператор удаляет, обновляет или вставляет строки из кластеризованного индекса, указанного в `Argument` столбце оператора.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-225">The operator deletes, updates, or inserts rows from the clustered index specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="5a2a2-226">Фактическая операция зависит от значения времени выполнения столбца **Action** , указанного в `Argument` столбце оператора.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-226">The actual operation performed depends on the runtime value of the **ACTION** column specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="5a2a2-227">**Clustered Index Merge** является физическим.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-227">**Clustered Index Merge** is a physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-228">![Значок оператора Clustered Index Scan](../../2014/database-engine/media/clustered-index-scan-32x.gif "Значок оператора Clustered Index Scan")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-228">![Clustered index scan operator icon](../../2014/database-engine/media/clustered-index-scan-32x.gif "Clustered index scan operator icon")</span></span>|`Clustered Index Scan`|<span data-ttu-id="5a2a2-229">Оператор `Clustered Index Scan` сканирует кластеризованный индекс, заданный в столбце Argument плана выполнения запроса.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-229">The `Clustered Index Scan` operator scans the clustered index specified in the Argument column of the query execution plan.</span></span> <span data-ttu-id="5a2a2-230">При наличии необязательного предиката WHERE:() возвращаются только строки, удовлетворяющие предикату.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-230">When an optional WHERE:() predicate is present, only those rows that satisfy the predicate are returned.</span></span> <span data-ttu-id="5a2a2-231">Если столбец Argument содержит предложение ORDERED, обработчик запросов требует, чтобы выходные данные строк были возвращены в порядке, в соответствии с которым они были отсортированы в кластеризованном индексе.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-231">If the Argument column contains the ORDERED clause, the query processor has requested that the output of the rows be returned in the order in which the clustered index has sorted it.</span></span> <span data-ttu-id="5a2a2-232">Если предложение ORDERED отсутствует, подсистема хранилища выполняет поиск в индексе оптимальным способом, без обязательной сортировки выходных данных.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-232">If the ORDERED clause is not present, the storage engine scans the index in the optimal way, without necessarily sorting the output.</span></span> <span data-ttu-id="5a2a2-233">`Clustered Index Scan` является логическим и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-233">`Clustered Index Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-234">![Значок оператора Clustered Index Seek](../../2014/database-engine/media/clustered-index-seek-32x.gif "Значок оператора Clustered Index Seek")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-234">![Clustered index seek operator icon](../../2014/database-engine/media/clustered-index-seek-32x.gif "Clustered index seek operator icon")</span></span>|`Clustered Index Seek`|<span data-ttu-id="5a2a2-235">Оператор `Clustered Index Seek` использует возможности поиска по индексам для получения строк из кластеризованного индекса.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-235">The `Clustered Index Seek` operator uses the seeking ability of indexes to retrieve rows from a clustered index.</span></span> <span data-ttu-id="5a2a2-236">`Argument`Столбец содержит имя используемого кластеризованного индекса и ПРЕДИКАТ Seek:().</span><span class="sxs-lookup"><span data-stu-id="5a2a2-236">The `Argument` column contains the name of the clustered index being used and the SEEK:() predicate.</span></span> <span data-ttu-id="5a2a2-237">Подсистема хранилища использует этот индекс для обработки только тех строк, которые удовлетворяют данному предикату SEEK:().</span><span class="sxs-lookup"><span data-stu-id="5a2a2-237">The storage engine uses the index to process only those rows that satisfy this SEEK:() predicate.</span></span> <span data-ttu-id="5a2a2-238">Также может включаться предикат WHERE:(), в котором подсистема хранилища вычисляет выражение для всех строк, удовлетворяющих предикату SEEK:(), но это не является обязательным и не использует индексы для завершения процесса.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-238">It can also include a WHERE:() predicate where the storage engine evaluates against all rows that satisfy the SEEK:() predicate, but this is optional and does not use indexes to complete this process.</span></span><br /><br /> <span data-ttu-id="5a2a2-239">Если `Argument` столбец содержит предложение ORDERED, обработчик запросов определил, что строки должны возвращаться в том порядке, в котором они были отсортированы в кластеризованном индексе.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-239">If the `Argument` column contains the ORDERED clause, the query processor has determined that the rows must be returned in the order in which the clustered index has sorted them.</span></span> <span data-ttu-id="5a2a2-240">Если предложение ORDERED отсутствует, подсистема хранилища выполняет поиск индекса оптимальным способом, без обязательной сортировки выходных данных.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-240">If the ORDERED clause is not present, the storage engine searches the index in the optimal way, without necessarily sorting the output.</span></span> <span data-ttu-id="5a2a2-241">Сохранять порядок выходных данных является менее эффективным, чем формировать несортированные выходные данные.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-241">Allowing the output to retain its ordering can be less efficient than producing nonsorted output.</span></span> <span data-ttu-id="5a2a2-242">При указании ключевого слова LOOKUP выполняется поиск закладок.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-242">When the keyword LOOKUP appears, then a bookmark lookup is being performed.</span></span> <span data-ttu-id="5a2a2-243">В [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] и более поздних версиях `Key Lookup` оператор предоставляет функцию поиска закладок.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-243">In [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] and later versions, the `Key Lookup` operator provides bookmark lookup functionality.</span></span> <span data-ttu-id="5a2a2-244">`Clustered Index Seek` является логическим и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-244">`Clustered Index Seek` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-245">![Значок оператора Clustered Index Update](../../2014/database-engine/media/clustered-index-update-32x.gif "Значок оператора Clustered Index Update")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-245">![Clustered index update operator icon](../../2014/database-engine/media/clustered-index-update-32x.gif "Clustered index update operator icon")</span></span>|`Clustered Index Update`|<span data-ttu-id="5a2a2-246">`Clustered Index Update`Оператор обновляет входные строки в кластеризованном индексе, указанном в `Argument` столбце. Если имеется предикат WHERE:(), обновляются только те строки, которые соответствуют этому предикату.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-246">The `Clustered Index Update` operator updates input rows in the clustered index specified in the `Argument` column.If a WHERE:() predicate is present, only those rows that satisfy this predicate are updated.</span></span> <span data-ttu-id="5a2a2-247">При наличии предиката SET:() данное значение устанавливается для каждого обновляемого столбца.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-247">If a SET:() predicate is present, each updated column is set to this value.</span></span> <span data-ttu-id="5a2a2-248">При наличии предиката DEFINE:() перечисляются значения, определенные данным оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-248">If a DEFINE:() predicate is present, the values that this operator defines are listed.</span></span> <span data-ttu-id="5a2a2-249">Ссылки на эти значения могут присутствовать в предложении SET или в любом месте внутри данного оператора либо внутри данного запроса.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-249">These values may be referenced in the SET clause or elsewhere within this operator and elsewhere within this query.</span></span> <span data-ttu-id="5a2a2-250">`Clustered Index Update` является логическим и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-250">`Clustered Index Update` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-251">![Значок оператора Collapse](../../2014/database-engine/media/collapse-32x.gif "Значок оператора Collapse")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-251">![Collapse operator icon](../../2014/database-engine/media/collapse-32x.gif "Collapse operator icon")</span></span>|`Collapse`|<span data-ttu-id="5a2a2-252">Оператор `Collapse` оптимизирует процедуру обновления.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-252">The `Collapse` operator optimizes update processing.</span></span> <span data-ttu-id="5a2a2-253">При выполнении она может быть разбита (оператором `Split`) на операции удаления и вставки.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-253">When an update is performed, it can be split (using the `Split` operator) into a delete and an insert.</span></span> <span data-ttu-id="5a2a2-254">`Argument`Столбец содержит предложение Group By:(), которое задает список ключевых столбцов.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-254">The `Argument` column contains a GROUP BY:() clause that specifies a list of key columns.</span></span> <span data-ttu-id="5a2a2-255">Если обработчик запросов встречает смежные строки, удаляющие и вставляющие одни и те же значения ключей, он заменяет эти отдельные операции на одну, более эффективную операцию обновления.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-255">If the query processor encounters adjacent rows that delete and insert the same key values, it replaces these separate operations with a single more efficient update operation.</span></span> <span data-ttu-id="5a2a2-256">`Collapse` является логическим и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-256">`Collapse` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-257">![Просмотр индекса columnstore](../../2014/database-engine/media/columnstoreindexscan.gif "Просмотр индекса columnstore")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-257">![Columnstore Index Scan](../../2014/database-engine/media/columnstoreindexscan.gif "Columnstore Index Scan")</span></span>|`Columnstore Index Scan`|<span data-ttu-id="5a2a2-258">`Columnstore Index Scan`Оператор сканирует индекс columnstore, указанный в `Argument` столбце плана выполнения запроса.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-258">The `Columnstore Index Scan` operator scans the columnstore index specified in the `Argument` column of the query execution plan.</span></span>|  
|<span data-ttu-id="5a2a2-259">![Значок оператора Compute Scalar](../../2014/database-engine/media/compute-scalar-32x.gif "Значок оператора Compute Scalar")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-259">![Compute scalar operator icon](../../2014/database-engine/media/compute-scalar-32x.gif "Compute scalar operator icon")</span></span>|`Compute Scalar`|<span data-ttu-id="5a2a2-260">`Compute Scalar`Оператор вычисляет выражение для получения вычисляемого скалярного значения.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-260">The `Compute Scalar` operator evaluates an expression to produce a computed scalar value.</span></span> <span data-ttu-id="5a2a2-261">Затем эту величину можно вернуть пользователю или сослаться на нее в каком-либо запросе, а также выполнить эти действия одновременно.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-261">This may then be returned to the user, referenced elsewhere in the query, or both.</span></span> <span data-ttu-id="5a2a2-262">Примерами одновременного использования этих возможностей являются предикаты фильтра или соединения.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-262">An example of both is in a filter predicate or join predicate.</span></span> <span data-ttu-id="5a2a2-263">`Compute Scalar` является логическим и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-263">`Compute Scalar` is a logical and physical operator.</span></span><br /><br /> <span data-ttu-id="5a2a2-264">`Compute Scalar`операторы, которые отображаются в Showplan, созданных с помощью SET STATISTICS XML, могут не содержать `RunTimeInformation` элемент.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-264">`Compute Scalar` operators that appear in Showplans generated by SET STATISTICS XML might not contain the `RunTimeInformation` element.</span></span> <span data-ttu-id="5a2a2-265">(В графических инструкциях Showplan **Фактическое число строк**, **Фактическое число повторных привязок**и **Фактическое число сбросов на начало** могут отсутствовать в окне **Свойства** , если в среде **выбран параметр** Включить действительный план выполнения [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)].)</span><span class="sxs-lookup"><span data-stu-id="5a2a2-265">In graphical Showplans, **Actual Rows**, **Actual Rebinds**, and **Actual Rewinds** might be absent from the **Properties** window when the **Include Actual Execution Plan** option is selected in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)].</span></span> <span data-ttu-id="5a2a2-266">В данном случае это означает, что хотя эти операторы были использованы в скомпилированном плане запроса, их работа выполнялась другими операторами в исполняемом плане запроса.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-266">When this occurs, it means that although these operators were used in the compiled query plan, their work was performed by other operators in the run-time query plan.</span></span> <span data-ttu-id="5a2a2-267">Кроме того, обратите внимание, что число запусков на выходе Showplan, сформированных SET STATISTICS PROFILE, равно сумме повторных привязок и сбросов на начало в инструкциях Showplan, сформированных XML SET STATISTICS.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-267">Also note that the number of executes in Showplan output generated by SET STATISTICS PROFILE is equivalent to the sum of rebinds and rewinds in Showplans generated by SET STATISTICS XML.</span></span>|  
|<span data-ttu-id="5a2a2-268">![Значок оператора Concatenation](../../2014/database-engine/media/concatenation-32x.gif "Значок оператора Concatenation")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-268">![Concatenation operator icon](../../2014/database-engine/media/concatenation-32x.gif "Concatenation operator icon")</span></span>|<span data-ttu-id="5a2a2-269">**Concatenation**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-269">**Concatenation**</span></span>|<span data-ttu-id="5a2a2-270">Оператор **Concatenation** просматривает несколько входов, возвращая каждую просмотренную строку.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-270">The **Concatenation** operator scans multiple inputs, returning each row scanned.</span></span> <span data-ttu-id="5a2a2-271">Оператор**Concatenation** обычно используется для реализации конструкции [!INCLUDE[tsql](../includes/tsql-md.md)] UNION ALL.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-271">**Concatenation** is typically used to implement the [!INCLUDE[tsql](../includes/tsql-md.md)] UNION ALL construct.</span></span> <span data-ttu-id="5a2a2-272">Физический оператор **Concatenation** имеет два или более входов и один выход.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-272">The **Concatenation** physical operator has two or more inputs and one output.</span></span> <span data-ttu-id="5a2a2-273">Он копирует строки из первого входного потока в выходной поток и повторяет эту операцию для каждого дополнительного входного потока.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-273">Concatenation copies rows from the first input stream to the output stream, then repeats this operation for each additional input stream.</span></span> <span data-ttu-id="5a2a2-274">**Concatenation** является как логическим, так и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-274">**Concatenation** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-275">![Значок оператора Constant Scan](../../2014/database-engine/media/constant-scan-32x.gif "Значок оператора Constant Scan")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-275">![Constant scan operator icon](../../2014/database-engine/media/constant-scan-32x.gif "Constant scan operator icon")</span></span>|`Constant Scan`|<span data-ttu-id="5a2a2-276">`Constant Scan`Оператор вводит в запрос одну или несколько строк констант.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-276">The `Constant Scan` operator introduces one or more constant rows into a query.</span></span> <span data-ttu-id="5a2a2-277">`Compute Scalar`Оператор часто используется после, `Constant Scan` чтобы добавить столбцы в строку, созданную `Constant Scan` оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-277">A `Compute Scalar` operator is often used after a `Constant Scan` to add columns to a row produced by the `Constant Scan` operator.</span></span>|  
|<span data-ttu-id="5a2a2-278">![Значок элемента языка Convert (ядро СУБД)](../../2014/database-engine/media/convert-32x.gif "Значок элемента языка Convert (ядро СУБД)")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-278">![Convert (Database Engine) language element icon](../../2014/database-engine/media/convert-32x.gif "Convert (Database Engine) language element icon")</span></span>|`Convert`|<span data-ttu-id="5a2a2-279">Оператор `Convert` автоматически преобразует скалярные данные из одного типа в другой.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-279">The `Convert` operator converts one scalar data type to another.</span></span> <span data-ttu-id="5a2a2-280">`Convert` является элементом языка.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-280">`Convert` is a language element.</span></span>|  
|<span data-ttu-id="5a2a2-281">Нет</span><span class="sxs-lookup"><span data-stu-id="5a2a2-281">None</span></span>|`Cross Join`|<span data-ttu-id="5a2a2-282">Оператор `Cross Join` соединяет каждую строку из первого (верхнего) входного параметра с каждой строкой второго (нижнего) входного параметра.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-282">The `Cross Join` operator joins each row from the first (top) input with each row from the second (bottom) input.</span></span> <span data-ttu-id="5a2a2-283">`Cross Join` является логическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-283">`Cross Join` is a logical operator.</span></span>|  
|<span data-ttu-id="5a2a2-284">![Значок оператора курсора Cursor Catchall](../../2014/database-engine/media/cursor-catch-all.gif "Значок оператора курсора Cursor Catchall")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-284">![Cursor catchall cursor operator icon](../../2014/database-engine/media/cursor-catch-all.gif "Cursor catchall cursor operator icon")</span></span>|`catchall`|<span data-ttu-id="5a2a2-285">Общий значок отображается в тех случаях, когда с помощью логики, управляющей графическими планами визуализации, не удается найти подходящий значок для итератора.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-285">The catchall icon is displayed when a suitable icon for the iterator cannot be found by the logic that produces graphical showplans.</span></span> <span data-ttu-id="5a2a2-286">Значок общего захвата не обязательно указывает на ошибку.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-286">The catchall icon does not necessarily indicate an error condition.</span></span> <span data-ttu-id="5a2a2-287">Существует три общих значка захвата: синий (итераторы), оранжевый (курсоры) и зеленый (элементы языка [!INCLUDE[tsql](../includes/tsql-md.md)] ).</span><span class="sxs-lookup"><span data-stu-id="5a2a2-287">There are three catchall icons: blue (for iterators), orange (for cursors), and green (for [!INCLUDE[tsql](../includes/tsql-md.md)] language elements).</span></span>|  
|<span data-ttu-id="5a2a2-288">None</span><span class="sxs-lookup"><span data-stu-id="5a2a2-288">None</span></span>|<span data-ttu-id="5a2a2-289">**Курсор**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-289">**Cursor**</span></span>|<span data-ttu-id="5a2a2-290">Логический и физический операторы **Cursor** предназначены для описания того, каким образом выполняются операции запроса или обновления с участием курсора.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-290">The **Cursor** logical and physical operators are used to describe how a query or update involving cursor operations is executed.</span></span> <span data-ttu-id="5a2a2-291">Физические операторы описывают алгоритм физической реализации обработки курсора, например использование курсора, управляемого набором ключей.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-291">The physical operators describe the physical implementation algorithm used to process the cursor; for example, using a keyset-driven cursor.</span></span> <span data-ttu-id="5a2a2-292">Каждый шаг выполнения курсора соответствует физическому оператору.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-292">Each step in the execution of a cursor involves a physical operator.</span></span> <span data-ttu-id="5a2a2-293">Логические операторы описывают свойства курсора, например доступность курсора только для чтения.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-293">The logical operators describe a property of the cursor, such as the cursor is read only.</span></span><br /><br /> <span data-ttu-id="5a2a2-294">Логические операторы включают в себя Asynchronous, Optimistic, Primary, Read Only, Scroll Locks, Secondary и Synchronous.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-294">Logical operators include Asynchronous, Optimistic, Primary, Read Only, Scroll Locks, and Secondary and Synchronous.</span></span><br /><br /> <span data-ttu-id="5a2a2-295">Физические операторы включают в себя Dynamic, Fetch Query, Keyset, Population Query, Refresh Query и Snapshot.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-295">Physical operators include Dynamic, Fetch Query, Keyset, Population Query, Refresh Query and Snapshot.</span></span>|  
|<span data-ttu-id="5a2a2-296">![Значок элемента языка Declare](../../2014/database-engine/media/declare-32x.gif "Значок элемента языка Declare")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-296">![Declare language element icon](../../2014/database-engine/media/declare-32x.gif "Declare language element icon")</span></span>|`Declare`|<span data-ttu-id="5a2a2-297">`Declare`Оператор выделяет локальную переменную в плане запроса.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-297">The `Declare`  operator allocates a local variable in the query plan.</span></span> <span data-ttu-id="5a2a2-298">`Declare` является элементом языка.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-298">`Declare` is a language element.</span></span>|  
|<span data-ttu-id="5a2a2-299">![Значок оператора Delete (ядро СУБД)](../../2014/database-engine/media/delete-32x.gif "Значок оператора Delete (ядро СУБД)")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-299">![Delete (Database Engine) operator icon](../../2014/database-engine/media/delete-32x.gif "Delete (Database Engine) operator icon")</span></span>|`Delete`|<span data-ttu-id="5a2a2-300">`Delete`Оператор удаляет из строк объекта, которые соответствуют необязательному предикату в `Argument` столбце.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-300">The `Delete` operator deletes from an object rows that satisfy the optional predicate in the `Argument` column.</span></span>|  
|<span data-ttu-id="5a2a2-301">![Значок оператора Delete Scan](../../2014/database-engine/media/delete-scan-32x.gif "Значок оператора Delete Scan")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-301">![Delete scan operator icon](../../2014/database-engine/media/delete-scan-32x.gif "Delete scan operator icon")</span></span>|`Deleted Scan`|<span data-ttu-id="5a2a2-302">Оператор `Deleted Scan` просматривает удаленную таблицу в триггере.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-302">The `Deleted Scan` operator scans the deleted table within a trigger.</span></span>|  
|<span data-ttu-id="5a2a2-303">Нет</span><span class="sxs-lookup"><span data-stu-id="5a2a2-303">None</span></span>|`Distinct`|<span data-ttu-id="5a2a2-304">Оператор `Distinct` удаляет дубликаты из набора строк или из коллекции значений.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-304">The `Distinct` operator removes duplicates from a rowset or from a collection of values.</span></span> <span data-ttu-id="5a2a2-305">`Distinct` является логическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-305">`Distinct` is a logical operator.</span></span>|  
|<span data-ttu-id="5a2a2-306">Нет</span><span class="sxs-lookup"><span data-stu-id="5a2a2-306">None</span></span>|`Distinct Sort`|<span data-ttu-id="5a2a2-307">`Distinct Sort`Логический оператор сканирует входные данные, удаляя дубликаты и сортировку по столбцам, указанным в предикате DISTINCT ORDER BY:() `Argument` столбца.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-307">The `Distinct Sort` logical operator scans the input, removing duplicates and sorting by the columns specified in the DISTINCT ORDER BY:() predicate of the `Argument` column.</span></span> <span data-ttu-id="5a2a2-308">`Distinct Sort` является логическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-308">`Distinct Sort` is a logical operator.</span></span>|  
|<span data-ttu-id="5a2a2-309">![Значок оператора параллелизма Distribute Streams](../../2014/database-engine/media/parallelism-distribute-stream.gif "Значок оператора параллелизма Distribute Streams")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-309">![Distribute streams parallelism operator icon](../../2014/database-engine/media/parallelism-distribute-stream.gif "Distribute streams parallelism operator icon")</span></span>|<span data-ttu-id="5a2a2-310">**Distribute Streams**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-310">**Distribute Streams**</span></span>|<span data-ttu-id="5a2a2-311">Оператор **Distribute Streams** используется только в параллельных планах запросов.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-311">The **Distribute Streams** operator is used only in parallel query plans.</span></span> <span data-ttu-id="5a2a2-312">Оператор **Distribute Streams** преобразует один входящий поток записей в несколько выходящих потоков.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-312">The **Distribute Streams** operator takes a single input stream of records and produces multiple output streams.</span></span> <span data-ttu-id="5a2a2-313">Формат и содержимое записей не меняются.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-313">The record contents and format are not changed.</span></span> <span data-ttu-id="5a2a2-314">Каждая запись из входящего потока направляется в один из выходящих потоков.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-314">Each record from the input stream appears in one of the output streams.</span></span> <span data-ttu-id="5a2a2-315">Данный оператор автоматически сохраняет в выходящих потоках относительный порядок входящих записей.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-315">This operator automatically preserves the relative order of the input records in the output streams.</span></span> <span data-ttu-id="5a2a2-316">Чтобы определить выходящий поток, в который попадет запись из входящего потока, обычно используется хэширование.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-316">Usually, hashing is used to decide to which output stream a particular input record belongs.</span></span><br /><br /> <span data-ttu-id="5a2a2-317">Если выходные данные секционированы, то `Argument` столбец содержит ПРЕДИКАТ PARTITION COLUMNS:() и столбцы секционирования.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-317">If the output is partitioned, then the `Argument` column contains a PARTITION COLUMNS:() predicate and the partitioning columns.</span></span> <span data-ttu-id="5a2a2-318">Оператор**Distribute Streams** является логическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-318">**Distribute Streams** is a logical operator</span></span>|  
|<span data-ttu-id="5a2a2-319">![Значок оператора Dynamic Cursor](../../2014/database-engine/media/dynamic-32x.gif "Значок оператора Dynamic Cursor")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-319">![Dynamic cursor operator icon](../../2014/database-engine/media/dynamic-32x.gif "Dynamic cursor operator icon")</span></span>|`Dynamic`|<span data-ttu-id="5a2a2-320">В операторе `Dynamic` используется курсор, который отслеживает изменения, внесенные другими.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-320">The `Dynamic` operator uses a cursor that can see all changes made by others.</span></span>|  
|<span data-ttu-id="5a2a2-321">![Значок оператора Spool](../../2014/database-engine/media/spool-32x.gif "Значок оператора Spool")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-321">![Spool operator icon](../../2014/database-engine/media/spool-32x.gif "Spool operator icon")</span></span>|<span data-ttu-id="5a2a2-322">**Eager Spool**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-322">**Eager Spool**</span></span>|<span data-ttu-id="5a2a2-323">Оператор **безотлагательной буферизации** принимает все входные данные, сохраняя каждую строку в скрытом временном объекте, хранящемся в `tempdb` базе данных.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-323">The **Eager Spool** operator takes the entire input, storing each row in a hidden temporary object stored in the `tempdb` database.</span></span> <span data-ttu-id="5a2a2-324">Если оператор перематывает (например, `Nested Loops` оператор), но не требуется повторная привязка, то вместо повторного сканирования входных данных используется очередь.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-324">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span> <span data-ttu-id="5a2a2-325">Если требуется повторная привязка, буферизованные данные удаляются, а объект буфера перестраивается путем повторного просмотра ввода.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-325">If rebinding is needed, the spooled data is discarded and the spool object is rebuilt by rescanning the (rebound) input.</span></span> <span data-ttu-id="5a2a2-326">Оператор **Eager Spool** выполняет построение своего буферного файла «жадным» способом: когда родительский оператор буфера запрашивает первую строку, оператор буферизации принимает все строки из своего входного оператора и сохраняет ее в буфер.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-326">The **Eager Spool** operator builds its spool file in an "eager" manner: when the spool's parent operator asks for the first row, the spool operator consumes all rows from its input operator and stores them in the spool.</span></span> <span data-ttu-id="5a2a2-327">**Eager Spool** — логический оператор.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-327">**Eager Spool** is a logical operator.</span></span>|  
|<span data-ttu-id="5a2a2-328">![Значок оператора Fetch Query Cursor](../../2014/database-engine/media/fetch-query-32x.gif "Значок оператора Fetch Query Cursor")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-328">![Fetch query cursor operator icon](../../2014/database-engine/media/fetch-query-32x.gif "Fetch query cursor operator icon")</span></span>|`Fetch Query`|<span data-ttu-id="5a2a2-329">Оператор `Fetch Query` извлекает строки, если выборка выполняется в курсоре.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-329">The `Fetch Query` operator retrieves rows when a fetch is issued against a cursor.</span></span>|  
|<span data-ttu-id="5a2a2-330">![Значок оператора Filter (ядро СУБД)](../../2014/database-engine/media/filter-32x.gif "Значок оператора Filter (ядро СУБД)")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-330">![Filter (Database Engine) operator icon](../../2014/database-engine/media/filter-32x.gif "Filter (Database Engine) operator icon")</span></span>|<span data-ttu-id="5a2a2-331">**Filter**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-331">**Filter**</span></span>|<span data-ttu-id="5a2a2-332">Оператор **Filter** просматривает входные данные, возвращая только те строки, которые соответствуют критерию фильтра (предикату), который отображается в `Argument` столбце.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-332">The **Filter** operator scans the input, returning only those rows that satisfy the filter expression (predicate) that appears in the `Argument` column.</span></span>|  
|<span data-ttu-id="5a2a2-333">Нет</span><span class="sxs-lookup"><span data-stu-id="5a2a2-333">None</span></span>|`Flow Distinct`|<span data-ttu-id="5a2a2-334">Логический оператор `Flow Distinct` просматривает входные данные и удаляет дубликаты.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-334">The `Flow Distinct` logical operator scans the input, removing duplicates.</span></span> <span data-ttu-id="5a2a2-335">В то время как `Distinct` оператор принимает все входные данные до получения выходных данных, оператор **фловдистинкт** возвращает каждую строку, как получено от входных данных (если эта строка не является дубликатом, в этом случае она отбрасывается).</span><span class="sxs-lookup"><span data-stu-id="5a2a2-335">Whereas the `Distinct` operator consumes all input before producing any output, the **FlowDistinct** operator returns each row as it is obtained from the input (unless that row is a duplicate, in which case it is discarded).</span></span>|  
|<span data-ttu-id="5a2a2-336">Нет</span><span class="sxs-lookup"><span data-stu-id="5a2a2-336">None</span></span>|`Full Outer Join`|<span data-ttu-id="5a2a2-337">Логический оператор `Full Outer Join` возвращает каждую строку, удовлетворяющую предикату соединения из первого (верхнего) входа и соединенную с каждой строкой из второго (нижнего) входа.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-337">The `Full Outer Join` logical operator returns each row satisfying the join predicate from the first (top) input joined with each row from the second (bottom) input.</span></span> <span data-ttu-id="5a2a2-338">Он также возвращает строки из:</span><span class="sxs-lookup"><span data-stu-id="5a2a2-338">It also returns rows from:</span></span><br /><br /> <span data-ttu-id="5a2a2-339">первых входных данных, не имеющих соответствий во вторых входных данных;</span><span class="sxs-lookup"><span data-stu-id="5a2a2-339">-The first input that had no matches in the second input.</span></span><br /><br /> <span data-ttu-id="5a2a2-340">вторых входных данных, не имеющих соответствий в первых входных данных.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-340">-The second input that had no matches in the first input.</span></span><br /><br /> <br /><br /> <span data-ttu-id="5a2a2-341">Вход, не содержащий совпадающих значений, возвращается как значение NULL.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-341">The input that does not contain the matching values is returned as a null value.</span></span> <span data-ttu-id="5a2a2-342">`Full Outer Join` является логическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-342">`Full Outer Join` is a logical operator.</span></span>|  
|<span data-ttu-id="5a2a2-343">![Значок оператора параллелизма Gather Streams](../../2014/database-engine/media/parallelism-32x.gif "Значок оператора параллелизма Gather Streams")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-343">![Gather streams parallelism operator icon](../../2014/database-engine/media/parallelism-32x.gif "Gather streams parallelism operator icon")</span></span>|<span data-ttu-id="5a2a2-344">**Gather Streams**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-344">**Gather Streams**</span></span>|<span data-ttu-id="5a2a2-345">Оператор **Gather Streams** используется только в планах параллельных запросов.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-345">The **Gather Streams** operator is only used in parallel query plans.</span></span> <span data-ttu-id="5a2a2-346">Оператор **Gather Streams** считывает несколько входных потоков и создает один выходной поток записей, комбинируя все входные потоки.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-346">The **Gather Streams** operator consumes several input streams and produces a single output stream of records by combining the input streams.</span></span> <span data-ttu-id="5a2a2-347">Формат и содержимое записей не меняются.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-347">The record contents and format are not changed.</span></span> <span data-ttu-id="5a2a2-348">Если этот оператор сохраняет порядок, все входные потоки должны быть упорядочены.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-348">If this operator is order preserving, all input streams must be ordered.</span></span> <span data-ttu-id="5a2a2-349">Если выходные данные упорядочены, `Argument` столбец содержит ПРЕДИКАТ Order By:() и имена упорядоченных столбцов.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-349">If the output is ordered, the `Argument` column contains an ORDER BY:() predicate and the names of columns being ordered.</span></span> <span data-ttu-id="5a2a2-350">**Gather Streams** — логический оператор.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-350">**Gather Streams** is a logical operator.</span></span>|  
|<span data-ttu-id="5a2a2-351">![Значок оператора Hash Match](../../2014/database-engine/media/hash-match-32x.gif "Значок оператора Hash Match")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-351">![Hash match operator icon](../../2014/database-engine/media/hash-match-32x.gif "Hash match operator icon")</span></span>|`Hash Match`|<span data-ttu-id="5a2a2-352">Оператор `Hash Match` строит хэш-таблицу при помощи вычисления хэш-значения для каждой строки из своих входных данных.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-352">The `Hash Match` operator builds a hash table by computing a hash value for each row from its build input.</span></span> <span data-ttu-id="5a2a2-353">В столбце появится предикат HASH:() со списком столбцов, используемых для создания хэш-значения `Argument` .</span><span class="sxs-lookup"><span data-stu-id="5a2a2-353">A HASH:() predicate with a list of columns used to create a hash value appears in the `Argument` column.</span></span> <span data-ttu-id="5a2a2-354">Затем для каждой тестовой строки (если возможно) он вычисляет хэш-значение (с использованием той же хэш-функции) и осуществляет поиск совпадений по хэш-таблице.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-354">Then, for each probe row (as applicable), it computes a hash value (using the same hash function) and looks in the hash table for matches.</span></span> <span data-ttu-id="5a2a2-355">При наличии остаточного предиката (определяемого ОСТАТКом предиката:() в `Argument` столбце) Этот предикат должен также удовлетворять требованиям, чтобы строки считались совпадающими.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-355">If a residual predicate is present (identified by RESIDUAL:() in the `Argument` column), that predicate must also be satisfied for rows to be considered a match.</span></span> <span data-ttu-id="5a2a2-356">Поведение зависит от выполняемой логической операции.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-356">Behavior depends on the logical operation being performed:</span></span><br /><br /> <span data-ttu-id="5a2a2-357">Для любых соединений используйте первую (верхнюю) входную строку с целью построения хэш-таблицы, а вторую (нижнюю) входную строку — для тестирования хэш-таблицы.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-357">For any joins, use the first (top) input to build the hash table and the second (bottom) input to probe the hash table.</span></span> <span data-ttu-id="5a2a2-358">Выходные данные совпадают (или не совпадают) в зависимости от типа соединения.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-358">Output matches (or nonmatches) as dictated by the join type.</span></span> <span data-ttu-id="5a2a2-359">Если несколько операций соединения используют один и тот же столбец соединения, эти операции группируются в хэш-группу.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-359">If multiple joins use the same join column, these operations are grouped into a hash team.</span></span><br /><br /> <span data-ttu-id="5a2a2-360">Для операторов Distinct и Aggregate используйте входные данные с целью построения хэш-таблицы (удаляя дубликаты и вычисляя любые статистические выражения).</span><span class="sxs-lookup"><span data-stu-id="5a2a2-360">For the distinct or aggregate operators, use the input to build the hash table (removing duplicates and computing any aggregate expressions).</span></span> <span data-ttu-id="5a2a2-361">Когда хэш-таблица будет построена, просмотрите таблицу и выведите все записи.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-361">When the hash table is built, scan the table and output all entries.</span></span><br /><br /> <span data-ttu-id="5a2a2-362">Для оператора Union используйте первую входную строку с целью построения хэш-таблицы (с удалением дубликатов).</span><span class="sxs-lookup"><span data-stu-id="5a2a2-362">For the union operator, use the first input to build the hash table (removing duplicates).</span></span> <span data-ttu-id="5a2a2-363">Используйте вторую входную строку (в которой не должно быть дубликатов) с целью тестирования хэш-таблицы, возвращения всех строк, не имеющих совпадений, затем просмотрите хэш-таблицу для возвращения всех записей.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-363">Use the second input (which must have no duplicates) to probe the hash table, returning all rows that have no matches, then scan the hash table and return all entries.</span></span><br /><br /> <br /><br /> <span data-ttu-id="5a2a2-364">`Hash Match` является физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-364">`Hash Match` is a physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-365">![Значок элемента языка If](../../2014/database-engine/media/if-32x.gif "Значок элемента языка If")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-365">![If language element icon](../../2014/database-engine/media/if-32x.gif "If language element icon")</span></span>|`If`|<span data-ttu-id="5a2a2-366">Оператор `If` выполняет условную обработку в зависимости от значения выражения.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-366">The `If` operator carries out conditional processing based on an expression.</span></span> <span data-ttu-id="5a2a2-367">`If` является элементом языка.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-367">`If` is a language element.</span></span>|  
|<span data-ttu-id="5a2a2-368">Нет</span><span class="sxs-lookup"><span data-stu-id="5a2a2-368">None</span></span>|`Inner Join`|<span data-ttu-id="5a2a2-369">Логический оператор `Inner Join` возвращает каждую строку, которая удовлетворяет соединению первого (верхнего) входа со вторым (нижним).</span><span class="sxs-lookup"><span data-stu-id="5a2a2-369">The `Inner Join` logical operator returns each row that satisfies the join of the first (top) input with the second (bottom) input.</span></span>|  
|<span data-ttu-id="5a2a2-370">![Значок оператора Insert (ядро СУБД)](../../2014/database-engine/media/insert-32x.gif "Значок оператора Insert (ядро СУБД)")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-370">![Insert (Database Engine) operator icon](../../2014/database-engine/media/insert-32x.gif "Insert (Database Engine) operator icon")</span></span>|`Insert`|<span data-ttu-id="5a2a2-371">`Insert`Логический оператор вставляет каждую строку из входных данных в объект, указанный в `Argument` столбце.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-371">The `Insert` logical operator inserts each row from its input into the object specified in the `Argument` column.</span></span> <span data-ttu-id="5a2a2-372">Соответствующим физическим оператором является `Table Insert`, `Index Insert` или `Clustered Index Insert`.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-372">The physical operator is either the `Table Insert`, `Index Insert`, or `Clustered Index Insert` operator.</span></span>|  
|<span data-ttu-id="5a2a2-373">![Значок оператора Inserted Scan](../../2014/database-engine/media/inserted-scan-32x.gif "Значок оператора Inserted Scan")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-373">![Inserted scan operator icon](../../2014/database-engine/media/inserted-scan-32x.gif "Inserted scan operator icon")</span></span>|<span data-ttu-id="5a2a2-374">**Inserted Scan**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-374">**Inserted Scan**</span></span>|<span data-ttu-id="5a2a2-375">Оператор **Inserted Scan** просматривает таблицу **inserted** .</span><span class="sxs-lookup"><span data-stu-id="5a2a2-375">The **Inserted Scan** operator scans the **inserted** table.</span></span> <span data-ttu-id="5a2a2-376">**Inserted Scan** является логическим и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-376">**Inserted Scan** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-377">![Значок элемента языка Intrinsic](../../2014/database-engine/media/intrinsic-32x.gif "Значок элемента языка Intrinsic")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-377">![Intrinsic language element icon](../../2014/database-engine/media/intrinsic-32x.gif "Intrinsic language element icon")</span></span>|`Intrinsic`|<span data-ttu-id="5a2a2-378">Оператор `Intrinsic` вызывает внутреннюю функцию [!INCLUDE[tsql](../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5a2a2-378">The `Intrinsic` operator invokes an internal [!INCLUDE[tsql](../includes/tsql-md.md)] function.</span></span> <span data-ttu-id="5a2a2-379">`Intrinsic` является элементом языка.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-379">`Intrinsic` is a language element.</span></span>|  
|<span data-ttu-id="5a2a2-380">![Значок оператора Iterator Catchall](../../2014/database-engine/media/iterator-catch-all.gif "Значок оператора Iterator Catchall")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-380">![Iterator catchall operator icon](../../2014/database-engine/media/iterator-catch-all.gif "Iterator catchall operator icon")</span></span>|`Iterator`|<span data-ttu-id="5a2a2-381">Общий значок `Iterator` отображается в тех случаях, когда с помощью логики, управляющей графическими планами Showplan, не удается найти подходящий значок для итератора.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-381">The `Iterator` catchall icon is displayed when a suitable icon for the iterator cannot be found by the logic that produces graphical Showplans.</span></span> <span data-ttu-id="5a2a2-382">Значок общего захвата не обязательно указывает на ошибку.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-382">The catchall icon does not necessarily indicate an error condition.</span></span> <span data-ttu-id="5a2a2-383">Существуют три общих значка: синий (итераторы), оранжевый (курсоры) и зеленый (конструкции языка [!INCLUDE[tsql](../includes/tsql-md.md)] ).</span><span class="sxs-lookup"><span data-stu-id="5a2a2-383">There are three catchall icons: blue (for iterators), orange (for cursors), and green (for [!INCLUDE[tsql](../includes/tsql-md.md)] language constructs).</span></span>|  
|<span data-ttu-id="5a2a2-384">![Значок оператора Bookmark Lookup](../../2014/database-engine/media/bookmark-lookup-32x.gif "Значок оператора Bookmark Lookup")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-384">![Bookmark lookup operator icon](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark lookup operator icon")</span></span>|`Key Lookup`|<span data-ttu-id="5a2a2-385">`Key Lookup`Оператор является уточняющим запросом закладки для таблицы с кластеризованным индексом.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-385">The `Key Lookup` operator is a bookmark lookup on a table with a clustered index.</span></span> <span data-ttu-id="5a2a2-386">`Argument`Столбец содержит имя кластеризованного индекса и ключ кластеризации, используемый для поиска строки в кластеризованном индексе.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-386">The `Argument` column contains the name of the clustered index and the clustering key used to look up the row in the clustered index.</span></span> <span data-ttu-id="5a2a2-387">`Key Lookup`всегда сопровождается `Nested Loops` оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-387">`Key Lookup` is always accompanied by a `Nested Loops` operator.</span></span> <span data-ttu-id="5a2a2-388">Если в столбце присутствует предложение WITH упреждающей выборки `Argument` , обработчик запросов определил, что оптимально использовать асинхронную предварительную выборку (упреждающее чтение) при поиске закладок в кластеризованном индексе.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-388">If the WITH PREFETCH clause appears in the `Argument` column, the query processor has determined that it is optimal to use asynchronous prefetching (read-ahead) when looking up bookmarks in the clustered index.</span></span><br /><br /> <span data-ttu-id="5a2a2-389">Использование `Key Lookup` оператора в плане запроса указывает на то, что запрос может выиграть от настройки производительности.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-389">The use of a `Key Lookup` operator in a query plan indicates that the query might benefit from performance tuning.</span></span> <span data-ttu-id="5a2a2-390">Например, производительность запроса можно повысить, добавив покрывающий индекс.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-390">For example, query performance might be improved by adding a covering index.</span></span>|  
|<span data-ttu-id="5a2a2-391">![Значок оператора курсора Keyset](../../2014/database-engine/media/keyset-32x.gif "Значок оператора курсора Keyset")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-391">![Keyset cursor operator icon](../../2014/database-engine/media/keyset-32x.gif "Keyset cursor operator icon")</span></span>|`Keyset`|<span data-ttu-id="5a2a2-392">Оператор `Keyset` использует курсор, для которого видимыми являются обновления, но не вставки, выполненные другими.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-392">The `Keyset` operator uses a cursor that can see updates, but not inserts made by others.</span></span>|  
|<span data-ttu-id="5a2a2-393">![Значок Language Element Catchall](../../2014/database-engine/media/language-construct-catch-all.gif "Значок Language Element Catchall")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-393">![Language element catchall icon](../../2014/database-engine/media/language-construct-catch-all.gif "Language element catchall icon")</span></span>|`Language Element`|<span data-ttu-id="5a2a2-394">Общий значок `Language Element` отображается в тех случаях, когда с помощью логики, управляющей графическими планами Showplan, не удается найти подходящий значок для итератора.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-394">The `Language Element` catchall icon is displayed when a suitable icon for the iterator cannot be found by the logic that produces graphical Showplans.</span></span> <span data-ttu-id="5a2a2-395">Значок общего захвата не обязательно указывает на ошибку.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-395">The catchall icon does not necessarily indicate an error condition.</span></span> <span data-ttu-id="5a2a2-396">Существуют три общих значка: синий (итераторы), оранжевый (курсоры) и зеленый (конструкции языка [!INCLUDE[tsql](../includes/tsql-md.md)] ).</span><span class="sxs-lookup"><span data-stu-id="5a2a2-396">There are three catchall icons: blue (for iterators), orange (for cursors), and green (for [!INCLUDE[tsql](../includes/tsql-md.md)] language constructs).</span></span>|  
|<span data-ttu-id="5a2a2-397">![Значок оператора Spool](../../2014/database-engine/media/spool-32x.gif "Значок оператора Spool")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-397">![Spool operator icon](../../2014/database-engine/media/spool-32x.gif "Spool operator icon")</span></span>|<span data-ttu-id="5a2a2-398">**Lazy Spool**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-398">**Lazy Spool**</span></span>|<span data-ttu-id="5a2a2-399">Логический оператор **Lazy spool** сохраняет каждую строку из входных данных в скрытом временном объекте, хранящемся в `tempdb` базе данных.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-399">The **Lazy Spool** logical operator stores each row from its input in a hidden temporary object stored in the `tempdb` database.</span></span> <span data-ttu-id="5a2a2-400">Если оператор перематывает (например, `Nested Loops` оператор), но не требуется повторная привязка, то вместо повторного сканирования входных данных используется очередь.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-400">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span> <span data-ttu-id="5a2a2-401">Если требуется повторная привязка, буферизованные данные удаляются, а объект буфера перестраивается путем повторного просмотра ввода.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-401">If rebinding is needed, the spooled data is discarded and the spool object is rebuilt by rescanning the (rebound) input.</span></span> <span data-ttu-id="5a2a2-402">Оператор **Lazy Spool** производит отложенное построение своего буферного файла: каждый раз, когда родительский оператор буфера запрашивает строку, оператор буферизации получает строку из своего входного оператора и сохраняет ее в буфер, а не обрабатывает все строки сразу.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-402">The **Lazy Spool** operator builds its spool file in a "lazy" manner, that is, each time the spool's parent operator asks for a row, the spool operator gets a row from its input operator and stores it in the spool, rather than consuming all rows at once.</span></span> <span data-ttu-id="5a2a2-403">Lazy Spool — это логический оператор.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-403">Lazy Spool is a logical operator.</span></span>|  
|<span data-ttu-id="5a2a2-404">Нет</span><span class="sxs-lookup"><span data-stu-id="5a2a2-404">None</span></span>|`Left Anti Semi Join`|<span data-ttu-id="5a2a2-405">Оператор `Left Anti Semi Join` возвращает каждую строку первого (верхнего) входа, для которой нет соответствующей строки во втором (нижнем) входе.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-405">The `Left Anti Semi Join` operator returns each row from the first (top) input when there is no matching row in the second (bottom) input.</span></span> <span data-ttu-id="5a2a2-406">Если в столбце нет предиката объединения `Argument` , каждая строка будет соответствующей строкой.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-406">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="5a2a2-407">`Left Anti Semi Join` является логическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-407">`Left Anti Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="5a2a2-408">Нет</span><span class="sxs-lookup"><span data-stu-id="5a2a2-408">None</span></span>|`Left Outer Join`|<span data-ttu-id="5a2a2-409">Оператор `Left Outer Join` возвращает строки, удовлетворяющие условию соединения первого (верхнего) входа со вторым (нижним) входом.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-409">The `Left Outer Join` operator returns each row that satisfies the join of the first (top) input with the second (bottom) input.</span></span> <span data-ttu-id="5a2a2-410">Он также возвращает строки из первого входа, не имеющие соответствия строкам во втором входе.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-410">It also returns any rows from the first input that had no matching rows in the second input.</span></span> <span data-ttu-id="5a2a2-411">Строки, не имеющие соответствия строкам во втором входе, возвращаются как значения NULL.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-411">The nonmatching rows in the second input are returned as null values.</span></span> <span data-ttu-id="5a2a2-412">Если в столбце нет предиката объединения `Argument` , каждая строка будет соответствующей строкой.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-412">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="5a2a2-413">`Left Outer Join` является логическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-413">`Left Outer Join` is a logical operator.</span></span>|  
|<span data-ttu-id="5a2a2-414">Нет</span><span class="sxs-lookup"><span data-stu-id="5a2a2-414">None</span></span>|`Left Semi Join`|<span data-ttu-id="5a2a2-415">Оператор `Left Semi Join` возвращает каждую строку из первого (верхнего) входа, для которой есть соответствующая строка во втором (нижнем) входе.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-415">The `Left Semi Join` operator returns each row from the first (top) input when there is a matching row in the second (bottom) input.</span></span> <span data-ttu-id="5a2a2-416">Если в столбце нет предиката объединения `Argument` , каждая строка будет соответствующей строкой.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-416">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="5a2a2-417">`Left Semi Join` является логическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-417">`Left Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="5a2a2-418">![Значок оператора Log Row Scan](../../2014/database-engine/media/log-row-scan-32x.gif "Значок оператора Log Row Scan")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-418">![Log row scan operator icon](../../2014/database-engine/media/log-row-scan-32x.gif "Log row scan operator icon")</span></span>|`Log Row Scan`|<span data-ttu-id="5a2a2-419">Оператор `Log Row Scan` просматривает журнал транзакций.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-419">The `Log Row Scan` operator scans the transaction log.</span></span> <span data-ttu-id="5a2a2-420">`Log Row Scan` является логическим и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-420">`Log Row Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-421">![Значок оператора Merge interval](../../2014/database-engine/media/merge-interval-32x.gif "Значок оператора Merge Interval")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-421">![Merge interval operator icon](../../2014/database-engine/media/merge-interval-32x.gif "Merge interval operator icon")</span></span>|`Merge Interval`|<span data-ttu-id="5a2a2-422">Оператор `Merge Interval` проводит слияние нескольких (возможно, пересекающихся) интервалов и возвращает минимальный, непересекающийся интервал, который затем используется для поиска записей индекса.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-422">The `Merge Interval` operator merges multiple (potentially overlapping) intervals to produce minimal, nonoverlapping intervals that are then used to seek index entries.</span></span> <span data-ttu-id="5a2a2-423">Этот оператор обычно появляется над одним или несколькими `Compute Scalar` операторами над `Constant Scan` операторами, которые создают интервалы (представленные в виде столбцов в строке), объединяемые этим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-423">This operator typically appears above one or more `Compute Scalar` operators over `Constant Scan` operators, which construct the intervals (represented as columns in a row) that this operator merges.</span></span> <span data-ttu-id="5a2a2-424">`Merge Interval` является логическим и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-424">`Merge Interval` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-425">![Значок оператора Merge Join](../../2014/database-engine/media/merge-join-32x.gif "Значок оператора Merge Join")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-425">![Merge join operator icon](../../2014/database-engine/media/merge-join-32x.gif "Merge join operator icon")</span></span>|<span data-ttu-id="5a2a2-426">**Merge Join**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-426">**Merge Join**</span></span>|<span data-ttu-id="5a2a2-427">Оператор **Merge Join** выполняет внутреннее соединение, левое внешнее соединение, левое полусоединение, левое антиполусоединение, правое внешнее соединение, правое полусоединение, правое антиполусоединение, а также логические операции соединения.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-427">The **Merge Join** operator performs the inner join, left outer join, left semi join, left anti semi join, right outer join, right semi join, right anti semi join, and union logical operations.</span></span><br /><br /> <span data-ttu-id="5a2a2-428">В `Argument` столбце Оператор объединения **слиянием** содержит предикат MERGE:(), если операция выполняет соединение "один ко многим", или предикат MERGE:() "многие ко многим", если операция выполняет соединение "многие ко многим".</span><span class="sxs-lookup"><span data-stu-id="5a2a2-428">In the `Argument` column, the **Merge Join** operator contains a MERGE:() predicate if the operation is performing a one-to-many join, or a MANY-TO-MANY MERGE:() predicate if the operation is performing a many-to-many join.</span></span> <span data-ttu-id="5a2a2-429">`Argument`Столбец также содержит список столбцов с разделителями-запятыми, используемых для выполнения операции.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-429">The `Argument` column also includes a comma-separated list of columns used to perform the operation.</span></span> <span data-ttu-id="5a2a2-430">Оператор **Merge Join** требует наличия двух входных значений, отсортированных в соответствующих столбцах, что можно сделать с помощью вставки явных операций сортировки в план запроса.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-430">The **Merge Join** operator requires two inputs sorted on their respective columns, possibly by inserting explicit sort operations into the query plan.</span></span> <span data-ttu-id="5a2a2-431">Соединение слиянием особенно эффективно в случаях, когда явной сортировки не требуется, например, когда в базе данных имеется подходящий индекс сбалансированного дерева или когда порядок сортировки может использоваться для нескольких операций вроде соединения слиянием или группирования со сведением.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-431">Merge join is particularly effective if explicit sorting is not required, for example, if there is a suitable B-tree index in the database or if the sort order can be exploited for multiple operations, such as a merge join and grouping with roll up.</span></span> <span data-ttu-id="5a2a2-432">**Merge Join** является физическим.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-432">**Merge Join** is a physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-433">![Значок оператора Nested Loops](../../2014/database-engine/media/nested-loops-32x.gif "Значок оператора Nested Loops")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-433">![Nested loops operator icon](../../2014/database-engine/media/nested-loops-32x.gif "Nested loops operator icon")</span></span>|`Nested Loops`|<span data-ttu-id="5a2a2-434">Оператор `Nested Loops` выполняет логические операции внутреннего соединения, левого внешнего соединения, левого полусоединения и антилевого полусоединения.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-434">The `Nested Loops` operator performs the inner join, left outer join, left semi join, and left anti semi join logical operations.</span></span> <span data-ttu-id="5a2a2-435">При соединениях вложенными циклами выполняется поиск во внутренней таблице каждой строки внешней таблицы, обычно с помощью индекса.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-435">Nested loops joins perform a search on the inner table for each row of the outer table, typically using an index.</span></span> <span data-ttu-id="5a2a2-436">На основании предполагаемых затрат обработчик запросов определяет, сортировать ли внешние входные данные, чтобы улучшить сосредоточенность поиска по индексу во внутренней таблице.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-436">The query processor decides, based on anticipated costs, whether to sort the outer input in order to improve locality of the searches on the index over the inner input.</span></span> <span data-ttu-id="5a2a2-437">Все строки, которые соответствуют (необязательным) предикату в `Argument` столбце, возвращаются в зависимости от выполняемой логической операции.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-437">Any rows that satisfy the (optional) predicate in the `Argument` column are returned as applicable, based on the logical operation being performed.</span></span> <span data-ttu-id="5a2a2-438">`Nested Loops` является физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-438">`Nested Loops` is a physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-439">![Значок оператора Nonclustered Index Delete](../../2014/database-engine/media/nonclust-index-delete-32x.gif "Значок оператора Nonclustered Index Delete")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-439">![Nonclustered index delete operator icon](../../2014/database-engine/media/nonclust-index-delete-32x.gif "Nonclustered index delete operator icon")</span></span>|`Nonclustered Index Delete`|<span data-ttu-id="5a2a2-440">`Nonclustered Index Delete`Оператор удаляет входные строки из некластеризованного индекса, указанного в `Argument` столбце.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-440">The `Nonclustered Index Delete` operator deletes input rows from the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="5a2a2-441">`Nonclustered Index Delete` является физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-441">`Nonclustered Index Delete` is a physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-442">![Значок оператора Nonclustered Index Insert](../../2014/database-engine/media/nonclust-index-insert-32x.gif "Значок оператора Nonclustered Index Insert")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-442">![Nonclustered index insert operator icon](../../2014/database-engine/media/nonclust-index-insert-32x.gif "Nonclustered index insert operator icon")</span></span>|`Index Insert`|<span data-ttu-id="5a2a2-443">`Index Insert`Оператор вставляет строки из входных данных в некластеризованный индекс, указанный в `Argument` столбце.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-443">The `Index Insert` operator inserts rows from its input into the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="5a2a2-444">В столбце `Argument` также содержится предикат SET:(), который указывает значение, устанавливаемое для каждого столбца.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-444">The `Argument` column also contains a SET:() predicate, which indicates the value to which each column is set.</span></span> <span data-ttu-id="5a2a2-445">`Index Insert` является физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-445">`Index Insert` is a physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-446">![Значок оператора Nonclustered Index Scan](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "Значок оператора Nonclustered Index Scan")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-446">![Nonclustered index scan operator icon](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "Nonclustered index scan operator icon")</span></span>|`Index Scan`|<span data-ttu-id="5a2a2-447">`Index Scan`Оператор получает все строки из некластеризованного индекса, указанного в `Argument` столбце.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-447">The `Index Scan` operator retrieves all rows from the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="5a2a2-448">Если в столбце появляется необязательный предикат WHERE:() `Argument` , возвращаются только те строки, которые соответствуют предикату.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-448">If an optional WHERE:() predicate appears in the `Argument` column, only those rows that satisfy the predicate are returned.</span></span> <span data-ttu-id="5a2a2-449">`Index Scan` является логическим и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-449">`Index Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-450">![Значок оператора Nonclustered Index Seek](../../2014/database-engine/media/index-seek-32x.gif "Значок оператора Nonclustered Index Seek")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-450">![Nonclustered index seek operator icon](../../2014/database-engine/media/index-seek-32x.gif "Nonclustered index seek operator icon")</span></span>|`Index Seek`|<span data-ttu-id="5a2a2-451">Оператор `Index Seek` использует возможности поиска по индексам для получения строк из некластеризованного индекса.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-451">The `Index Seek` operator uses the seeking ability of indexes to retrieve rows from a nonclustered index.</span></span> <span data-ttu-id="5a2a2-452">`Argument`Столбец содержит имя используемого некластеризованного индекса.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-452">The `Argument` column contains the name of the nonclustered index being used.</span></span> <span data-ttu-id="5a2a2-453">Он также содержит предикат SEEK:().</span><span class="sxs-lookup"><span data-stu-id="5a2a2-453">It also contains the SEEK:() predicate.</span></span> <span data-ttu-id="5a2a2-454">Подсистема хранилища использует этот индекс для обработки только строк, удовлетворяющих предикату SEEK:().</span><span class="sxs-lookup"><span data-stu-id="5a2a2-454">The storage engine uses the index to process only those rows that satisfy the SEEK:() predicate.</span></span> <span data-ttu-id="5a2a2-455">При необходимости может включаться предикат WHERE:(), в котором подсистема хранилища вычисляет выражение для всех строк, удовлетворяющих предикату SEEK:() (при этом не используются индексы).</span><span class="sxs-lookup"><span data-stu-id="5a2a2-455">It optionally may include a WHERE:() predicate, which the storage engine will evaluate against all rows that satisfy the SEEK:() predicate (it does not use the indexes to do this).</span></span> <span data-ttu-id="5a2a2-456">Если `Argument` столбец содержит предложение ORDERED, обработчик запросов определил, что строки должны возвращаться в том порядке, в котором они были отсортированы в некластеризованном индексе.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-456">If the `Argument` column contains the ORDERED clause, the query processor has determined that the rows must be returned in the order in which the nonclustered index has sorted them.</span></span> <span data-ttu-id="5a2a2-457">Если предложение ORDERED отсутствует, подсистема хранилища производит поиск индекса оптимальным способом (что не гарантирует сортировки выходных данных).</span><span class="sxs-lookup"><span data-stu-id="5a2a2-457">If the ORDERED clause is not present, the storage engine searches the index in the optimal way (which does not guarantee that the output will be sorted).</span></span> <span data-ttu-id="5a2a2-458">Сохранение сортировки в выводе может оказаться менее эффективным, чем возврат неупорядоченного вывода.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-458">Allowing the output to retain its ordering may be less efficient than producing nonsorted output.</span></span> <span data-ttu-id="5a2a2-459">`Index Seek` является логическим и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-459">`Index Seek` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-460">![Значок оператора Nonclustered Index Spool](../../2014/database-engine/media/index-spool-32x.gif "Значок оператора Nonclustered Index Spool")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-460">![Nonclustered index spool operator icon](../../2014/database-engine/media/index-spool-32x.gif "Nonclustered index spool operator icon")</span></span>|<span data-ttu-id="5a2a2-461">**Index Spool**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-461">**Index Spool**</span></span>|<span data-ttu-id="5a2a2-462">Физический оператор **Index Spool** содержит предикат SEEK:() в `Argument` столбце.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-462">The **Index Spool** physical operator contains a SEEK:() predicate in the `Argument` column.</span></span> <span data-ttu-id="5a2a2-463">Оператор **Index Spool** сканирует свои входные строки, помещая копии каждой строки в скрытый файл очереди (хранящийся в `tempdb` базе данных и существующий только в течение времени существования запроса), и создает некластеризованный индекс для строк.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-463">The **Index Spool** operator scans its input rows, placing a copy of each row in a hidden spool file (stored in the `tempdb` database and existing only for the lifetime of the query), and builds a nonclustered index on the rows.</span></span> <span data-ttu-id="5a2a2-464">Это позволяет использовать поддерживаемый индексами механизм поиска для вывода только строк, отвечающих требованиям предиката SEEK:().</span><span class="sxs-lookup"><span data-stu-id="5a2a2-464">This allows you to use the seeking capability of indexes to output only those rows that satisfy the SEEK:() predicate.</span></span> <span data-ttu-id="5a2a2-465">Если оператор перематывает (например, `Nested Loops` оператор), но не требуется повторная привязка, то вместо повторного сканирования входных данных используется очередь.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-465">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span>|  
|<span data-ttu-id="5a2a2-466">![Значок оператора Nonclustered Index Update](../../2014/database-engine/media/nonclust-index-update-32x.gif "Значок оператора Nonclustered Index Update")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-466">![Nonclustered index update operator icon](../../2014/database-engine/media/nonclust-index-update-32x.gif "Nonclustered index update operator icon")</span></span>|`Nonclustered Index Update`|<span data-ttu-id="5a2a2-467">`Nonclustered Index Update`Физический оператор обновляет строки входных данных в некластеризованном индексе, указанном в `Argument` столбце.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-467">The `Nonclustered Index Update` physical operator updates rows from its input in the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="5a2a2-468">При наличии предиката SET:() данное значение устанавливается для каждого обновляемого столбца.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-468">If a SET:() predicate is present, each updated column is set to this value.</span></span> <span data-ttu-id="5a2a2-469">`Nonclustered Index Update` является физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-469">`Nonclustered Index Update` is a physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-470">![Значок оператора Online Index Insert](../../2014/database-engine/media/online-index-32x.gif "Значок оператора Online Index Insert")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-470">![Online index insert operator icon](../../2014/database-engine/media/online-index-32x.gif "Online index insert operator icon")</span></span>|<span data-ttu-id="5a2a2-471">**Online Index Insert**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-471">**Online Index Insert**</span></span>|<span data-ttu-id="5a2a2-472">Физический оператор **Online Index Insert** указывает, что операции создания, изменения и удаления индекса выполняются в сети.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-472">The **Online Index Insert** physical operator indicates that an index create, alter, or drop operation is performed online.</span></span> <span data-ttu-id="5a2a2-473">То есть данные базовых таблиц по-прежнему доступны для пользователей во время операции с индексом.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-473">That is, the underlying table data remains available to users during the index operation.</span></span>|  
|<span data-ttu-id="5a2a2-474">None</span><span class="sxs-lookup"><span data-stu-id="5a2a2-474">None</span></span>|`Parallelism`|<span data-ttu-id="5a2a2-475">`Parallelism`Оператор выполняет логические операции потоков распределения, сбора потоков и повторного секционирования.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-475">The `Parallelism` operator performs the distribute streams, gather streams, and repartition streams logical operations.</span></span> <span data-ttu-id="5a2a2-476">`Argument`Столбцы могут содержать ПРЕДИКАТ PARTITION COLUMNS:() с разделенным запятыми списком столбцов, для которых выполняется секционирование.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-476">The `Argument` columns can contain a PARTITION COLUMNS:() predicate with a comma-separated list of the columns being partitioned.</span></span> <span data-ttu-id="5a2a2-477">`Argument`Столбцы также могут содержать ПРЕДИКАТ Order By:(), в котором перечислены столбцы для сохранения порядка сортировки во время секционирования.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-477">The `Argument` columns can also contain an ORDER BY:() predicate, listing the columns to preserve the sort order for during partitioning.</span></span> <span data-ttu-id="5a2a2-478">`Parallelism` является физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-478">`Parallelism` is a physical operator.</span></span><br /><br /> <span data-ttu-id="5a2a2-479">Примечание. Если запрос был скомпилирован как параллельный, но во время выполнения он выполняется как последовательный, то выходные данные инструкции Showplan, формируемые SET STATISTICS XML или с помощью параметра **Включить действительный план выполнения** в, [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] не будут содержать `RunTimeInformation` элемент для `Parallelism` оператора.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-479">Note: If a query has been compiled as a parallel query, but at run time it is run as a serial query, the Showplan output generated by SET STATISTICS XML or by using the **Include Actual Execution Plan** option in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] will not contain the `RunTimeInformation` element for the `Parallelism` operator.</span></span> <span data-ttu-id="5a2a2-480">В выходных данных «SET STATISTICS PROFILE» фактическое количество строк и фактическое число выполнений для оператора отображаются нулями `Parallelism` .</span><span class="sxs-lookup"><span data-stu-id="5a2a2-480">In SET STATISTICS PROFILE output, the actual row counts and actual number of executes will display zeroes for the `Parallelism` operator.</span></span> <span data-ttu-id="5a2a2-481">При возникновении любого из этих условий это означает, что оператор использовался `Parallelism` только во время компиляции запроса, а не в плане запроса времени выполнения.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-481">When either condition occurs, it means that the `Parallelism` operator was only used during query compilation and not in the run-time query plan.</span></span> <span data-ttu-id="5a2a2-482">Обратите внимание, что иногда планы параллельных запросов выполняются последовательно, если сервер выполняет большое количество параллельных запросов.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-482">Note that sometimes parallel query plans are run in serial if there is a high concurrent load on the server.</span></span>|  
|<span data-ttu-id="5a2a2-483">![Значок оператора Parameter Table Scan](../../2014/database-engine/media/parameter-table-scan-32x.gif "Значок оператора Parameter Table Scan")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-483">![Parameter table scan operator icon](../../2014/database-engine/media/parameter-table-scan-32x.gif "Parameter table scan operator icon")</span></span>|`Parameter Table Scan`|<span data-ttu-id="5a2a2-484">Оператор `Parameter Table Scan` просматривает таблицу, переданную как параметр текущего запроса.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-484">The `Parameter Table Scan` operator scans a table that is acting as a parameter in the current query.</span></span> <span data-ttu-id="5a2a2-485">Обычно он применяется для запросов INSERT из хранимой процедуры.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-485">Typically, this is used for INSERT queries within a stored procedure.</span></span> <span data-ttu-id="5a2a2-486">`Parameter Table Scan` является логическим и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-486">`Parameter Table Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-487">None</span><span class="sxs-lookup"><span data-stu-id="5a2a2-487">None</span></span>|<span data-ttu-id="5a2a2-488">**Partial Aggregate**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-488">**Partial Aggregate**</span></span>|<span data-ttu-id="5a2a2-489">Оператор**Partial Aggregate** используется в параллельных планах.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-489">**Partial Aggregate** is used in parallel plans.</span></span> <span data-ttu-id="5a2a2-490">Он применяется в статистической функции к максимальному числу входных строк, чтобы избежать записи на диск (сброса на диск).</span><span class="sxs-lookup"><span data-stu-id="5a2a2-490">It applies an aggregation function to as many input rows as possible so that writing to disk (known as a "spill") is not necessary.</span></span> <span data-ttu-id="5a2a2-491">`Hash Match`является единственным физическим оператором (итератором), реализующим агрегирование секций.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-491">`Hash Match` is the only physical operator (iterator) that implements partition aggregation.</span></span> <span data-ttu-id="5a2a2-492">**Partial Aggregate** является логическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-492">**Partial Aggregate** is a logical operator.</span></span>|  
|<span data-ttu-id="5a2a2-493">![Значок оператора курсора Population Query](../../2014/database-engine/media/poulation-query-32x.gif "Значок оператора курсора Population Query")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-493">![Population query cursor operator icon](../../2014/database-engine/media/poulation-query-32x.gif "Population query cursor operator icon")</span></span>|`Population Query`|<span data-ttu-id="5a2a2-494">Оператор `Population Query` заполняет рабочую таблицу курсора при его открытии.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-494">The `Population Query` operator populates the work table of a cursor when the cursor is opened.</span></span>|  
|<span data-ttu-id="5a2a2-495">![Значок оператора курсора Refresh Query](../../2014/database-engine/media/refresh-query-32x.gif "Значок оператора курсора Refresh Query")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-495">![Refresh query cursor operator icon](../../2014/database-engine/media/refresh-query-32x.gif "Refresh query cursor operator icon")</span></span>|`Refresh Query`|<span data-ttu-id="5a2a2-496">Оператор `Refresh Query` выбирает текущие данные для строк из буфера выборки.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-496">The `Refresh Query` operator fetches current data for rows in the fetch buffer.</span></span>|  
|<span data-ttu-id="5a2a2-497">![Значок оператора Remote Delete](../../2014/database-engine/media/remote-delete-32x.gif "Значок оператора Remote Delete")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-497">![Remote delete operator icon](../../2014/database-engine/media/remote-delete-32x.gif "Remote delete operator icon")</span></span>|`Remote Delete`|<span data-ttu-id="5a2a2-498">Оператор `Remote Delete` удаляет входные строки удаленного объекта.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-498">The `Remote Delete` operator deletes the input rows from a remote object.</span></span> <span data-ttu-id="5a2a2-499">`Remote Delete` является логическим и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-499">`Remote Delete` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-500">![Оператор удаленного индекса Seek инструкции Showplan](../../2014/database-engine/media/remote-index-scan-32x.gif "Оператор Showplan Remote Index Seek")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-500">![remote index seek showplan operator](../../2014/database-engine/media/remote-index-scan-32x.gif "remote index seek showplan operator")</span></span>|<span data-ttu-id="5a2a2-501">**Remote Index Scan**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-501">**Remote Index Scan**</span></span>|<span data-ttu-id="5a2a2-502">Оператор **Remote Index Scan** просматривает удаленный индекс, указанный в столбце Argument.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-502">The **Remote Index Scan** operator scans the remote index specified in the Argument column.</span></span> <span data-ttu-id="5a2a2-503">**Remote Index Scan** является логическим и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-503">**Remote Index Scan** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-504">![Оператор удаленного индекса Seek инструкции Showplan](../../2014/database-engine/media/remote-index-seek-32x.gif "Оператор Showplan Remote Index Seek")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-504">![remote index seek showplan operator](../../2014/database-engine/media/remote-index-seek-32x.gif "remote index seek showplan operator")</span></span>|<span data-ttu-id="5a2a2-505">**Remote Index Seek**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-505">**Remote Index Seek**</span></span>|<span data-ttu-id="5a2a2-506">Оператор **Remote Index Seek** использует возможности поиска объекта удаленного индекса, чтобы получить строки.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-506">The **Remote Index Seek** operator uses the seeking ability of a remote index object to retrieve rows.</span></span> <span data-ttu-id="5a2a2-507">`Argument`Столбец содержит имя используемого удаленного индекса и ПРЕДИКАТ Seek:().</span><span class="sxs-lookup"><span data-stu-id="5a2a2-507">The `Argument` column contains the name of the remote index being used and the SEEK:() predicate.</span></span> <span data-ttu-id="5a2a2-508">**Remote Index Seek** является логическим физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-508">**Remote Index Seek** is a logical physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-509">![Значок оператора Remote Insert](../../2014/database-engine/media/remote-insert-32x.gif "Значок оператора Remote insert")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-509">![Remote insert operator icon](../../2014/database-engine/media/remote-insert-32x.gif "Remote insert operator icon")</span></span>|<span data-ttu-id="5a2a2-510">**Remote Insert**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-510">**Remote Insert**</span></span>|<span data-ttu-id="5a2a2-511">Оператор **Remote Insert** вставляет входные строки в удаленный объект.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-511">The **Remote Insert** operator inserts the input rows into a remote object.</span></span> <span data-ttu-id="5a2a2-512">**Remote Insert** является логическим и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-512">**Remote Insert** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-513">![Значок оператора Remote Query](../../2014/database-engine/media/remote-query-32x.gif "Значок оператора Remote Query")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-513">![Remote query operator icon](../../2014/database-engine/media/remote-query-32x.gif "Remote query operator icon")</span></span>|`Remote Query`|<span data-ttu-id="5a2a2-514">Оператор `Remote Query` отправляет запрос удаленному источнику.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-514">The `Remote Query` operator submits a query to a remote source.</span></span> <span data-ttu-id="5a2a2-515">Текст запроса, отправленного на удаленный сервер, отображается в `Argument` столбце.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-515">The text of the query sent to the remote server appears in the `Argument` column.</span></span> <span data-ttu-id="5a2a2-516">`Remote Query` является логическим и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-516">`Remote Query` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-517">![Значок оператора Remote Scan](../../2014/database-engine/media/remote-scan-32x.gif "Значок оператора Remote Scan")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-517">![Remote scan operator icon](../../2014/database-engine/media/remote-scan-32x.gif "Remote scan operator icon")</span></span>|`Remote Scan`|<span data-ttu-id="5a2a2-518">Оператор `Remote Scan` позволяет удаленно просматривать необходимые объекты.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-518">The `Remote Scan` operator scans a remote object.</span></span> <span data-ttu-id="5a2a2-519">Имя удаленного объекта отображается в `Argument` столбце.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-519">The name of the remote object appears in the `Argument` column.</span></span> <span data-ttu-id="5a2a2-520">`Remote Scan` является логическим и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-520">`Remote Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-521">![Значок оператора Remote Update](../../2014/database-engine/media/remote-update-32x.gif "Значок оператора Remote Update")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-521">![Remote update operator icon](../../2014/database-engine/media/remote-update-32x.gif "Remote update operator icon")</span></span>|`Remote Update`|<span data-ttu-id="5a2a2-522">Оператор `Remote Update` обновляет входные строки удаленного объекта.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-522">The `Remote Update` operator updates the input rows in a remote object.</span></span> <span data-ttu-id="5a2a2-523">`Remote Update` является логическим и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-523">`Remote Update` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-524">![Значок оператора параллелизма Repartition Streams](../../2014/database-engine/media/parallelism-repartition-stream.gif "Значок оператора параллелизма Repartition Streams")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-524">![Repartition streams parallelism operator icon](../../2014/database-engine/media/parallelism-repartition-stream.gif "Repartition streams parallelism operator icon")</span></span>|<span data-ttu-id="5a2a2-525">**Repartition Streams**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-525">**Repartition Streams**</span></span>|<span data-ttu-id="5a2a2-526">Оператор **Repartition Streams** собирает несколько потоков и создает несколько потоков записей.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-526">The **Repartition Streams** operator consumes multiple streams and produces multiple streams of records.</span></span> <span data-ttu-id="5a2a2-527">Формат и содержимое записей не меняются.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-527">The record contents and format are not changed.</span></span> <span data-ttu-id="5a2a2-528">Если оптимизатор запросов использует фильтр по битовым картам, то число строк в выходном потоке сокращается.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-528">If the query optimizer uses a bitmap filter, the number of rows in the output stream is reduced.</span></span> <span data-ttu-id="5a2a2-529">Каждая запись из входного потока помещается в один выходной поток.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-529">Each record from an input stream is placed into one output stream.</span></span> <span data-ttu-id="5a2a2-530">Если оператор настроен для сохранения порядка, то все входные потоки упорядочиваются и сливаются в несколько упорядоченных выходных потоков.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-530">If this operator is order preserving, all input streams must be ordered and merged into several ordered output streams.</span></span> <span data-ttu-id="5a2a2-531">Если выходные данные секционированы, `Argument` столбец содержит ПРЕДИКАТ PARTITION COLUMNS:() и столбцы секционирования. Если выходные данные упорядочены, `Argument` столбец содержит ПРЕДИКАТ Order By:() и упорядоченные столбцы.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-531">If the output is partitioned, the `Argument` column contains a PARTITION COLUMNS:() predicate and the partitioning columns.If the output is ordered, the `Argument` column contains an ORDER BY:() predicate and the columns being ordered.</span></span> <span data-ttu-id="5a2a2-532">**Repartition Streams** — это логический оператор.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-532">**Repartition Streams** is a logical operator.</span></span> <span data-ttu-id="5a2a2-533">Он используется только в параллельных планах запроса.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-533">The operator is used only in parallel query plans.</span></span>|  
|<span data-ttu-id="5a2a2-534">![Значок элемента языка Result](../../2014/database-engine/media/result-32x.gif "Значок элемента языка Result")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-534">![Result language element icon](../../2014/database-engine/media/result-32x.gif "Result language element icon")</span></span>|`Result`|<span data-ttu-id="5a2a2-535">Оператор `Result` представляет собой данные, возвращенные в конце плана запроса.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-535">The `Result` operator is the data returned at the end of a query plan.</span></span> <span data-ttu-id="5a2a2-536">Обычно он является корневым элементом инструкции Showplan.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-536">This is usually the root element of a Showplan.</span></span> <span data-ttu-id="5a2a2-537">`Result` является элементом языка.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-537">`Result` is a language element.</span></span>|  
|<span data-ttu-id="5a2a2-538">![Значок оператора RID Lookup](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "Значок оператора RID Lookup")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-538">![RID lookup operator icon](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "RID lookup operator icon")</span></span>|`RID Lookup`|<span data-ttu-id="5a2a2-539">Оператор `RID Lookup` осуществляет поиск закладки в куче при помощи заданного идентификатора строки.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-539">`RID Lookup` is a bookmark lookup on a heap using a supplied row identifier (RID).</span></span> <span data-ttu-id="5a2a2-540">`Argument`Столбец содержит метку закладки, используемую для поиска строки в таблице, и имя таблицы, в которой выполняется поиск строки.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-540">The `Argument` column contains the bookmark label used to look up the row in the table and the name of the table in which the row is looked up.</span></span> <span data-ttu-id="5a2a2-541">Оператор `RID Lookup` всегда сопровождается оператором NESTED LOOP JOIN.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-541">`RID Lookup` is always accompanied by a NESTED LOOP JOIN.</span></span> <span data-ttu-id="5a2a2-542">`RID Lookup` является физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-542">`RID Lookup` is a physical operator.</span></span> <span data-ttu-id="5a2a2-543">Дополнительные сведения о поиске закладок см. в разделе[Bookmark Lookup](https://go.microsoft.com/fwlink/?LinkId=132568)на веб-узле MSDN в блоге SQL Server.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-543">For more information about bookmark lookups, see "[Bookmark Lookup](https://go.microsoft.com/fwlink/?LinkId=132568)" on the MSDN SQL Server blog.</span></span>|  
|<span data-ttu-id="5a2a2-544">Нет</span><span class="sxs-lookup"><span data-stu-id="5a2a2-544">None</span></span>|`Right Anti Semi Join`|<span data-ttu-id="5a2a2-545">Оператор `Right Anti Semi Join` выводит каждую строку второго (нижнего) входного множества, для которой не существует соответствующей строки в первом (верхнем) входном множестве.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-545">The `Right Anti Semi Join` operator outputs each row from the second (bottom) input when a matching row in the first (top) input does not exist.</span></span> <span data-ttu-id="5a2a2-546">Соответствующая строка определяется как строка, удовлетворяющая предикату в `Argument` столбце (если предикат не существует, каждая строка является совпадающей строкой).</span><span class="sxs-lookup"><span data-stu-id="5a2a2-546">A matching row is defined as a row that satisfies the predicate in the `Argument` column (if no predicate exists, each row is a matching row).</span></span> <span data-ttu-id="5a2a2-547">`Right Anti Semi Join` является логическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-547">`Right Anti Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="5a2a2-548">Нет</span><span class="sxs-lookup"><span data-stu-id="5a2a2-548">None</span></span>|`Right Outer Join`|<span data-ttu-id="5a2a2-549">Оператор `Right Outer Join` возвращает каждую строку, которая удовлетворяет соединению второго (нижнего) входа с первым (верхним).</span><span class="sxs-lookup"><span data-stu-id="5a2a2-549">The `Right Outer Join` operator returns each row that satisfies the join of the second (bottom) input with each matching row from the first (top) input.</span></span> <span data-ttu-id="5a2a2-550">Она также возвращает все строки из второго входа, для которых нет совпадений в первом, соединяя их со значением NULL.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-550">It also returns any rows from the second input that had no matching rows in the first input, joined with NULL.</span></span> <span data-ttu-id="5a2a2-551">Если в столбце нет предиката объединения `Argument` , каждая строка будет соответствующей строкой.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-551">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="5a2a2-552">`Right Outer Join` является логическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-552">`Right Outer Join` is a logical operator.</span></span>|  
|<span data-ttu-id="5a2a2-553">Нет</span><span class="sxs-lookup"><span data-stu-id="5a2a2-553">None</span></span>|`Right Semi Join`|<span data-ttu-id="5a2a2-554">Оператор `Right Semi Join` возвращает каждую строку из второго (нижнего) потока входных данных, если имеется соответствующая строка в первом (нижнем) потоке входных данных.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-554">The `Right Semi Join` operator returns each row from the second (bottom) input when there is a matching row in the first (top) input.</span></span> <span data-ttu-id="5a2a2-555">Если в столбце нет предиката объединения `Argument` , каждая строка будет соответствующей строкой.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-555">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="5a2a2-556">`Right Semi Join` является логическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-556">`Right Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="5a2a2-557">![Значок оператора Row Count Spool](../../2014/database-engine/media/remote-count-spool-32x.gif "Значок оператора Row Count Spool")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-557">![Row count spool operator icon](../../2014/database-engine/media/remote-count-spool-32x.gif "Row count spool operator icon")</span></span>|<span data-ttu-id="5a2a2-558">**Row Count Spool**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-558">**Row Count Spool**</span></span>|<span data-ttu-id="5a2a2-559">Оператор **Row Count Spool** просматривает входные данные, подсчитывая число представленных строк и возвращая такое же количество строк, очищенных от данных.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-559">The **Row Count Spool** operator scans the input, counting how many rows are present and returning the same number of rows without any data in them.</span></span> <span data-ttu-id="5a2a2-560">Этот оператор используется, когда необходимо проверить существование строк, а не наличие в них данных.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-560">This operator is used when it is important to check for the existence of rows, rather than the data contained in the rows.</span></span> <span data-ttu-id="5a2a2-561">Например, если `Nested Loops` оператор выполняет левую операцию объединения, а предикат Join применяется к внутренним входным данным, то в верхней части внутреннего ввода оператора может быть помещено количество строк в очереди `Nested Loops` .</span><span class="sxs-lookup"><span data-stu-id="5a2a2-561">For example, if a `Nested Loops` operator performs a left semi join operation and the join predicate applies to inner input, a row count spool may be placed at the top of the inner input of the `Nested Loops` operator.</span></span> <span data-ttu-id="5a2a2-562">Затем `Nested Loops` оператор может определить, сколько строк выводится с помощью очереди строк Count (поскольку фактические данные с внутренней стороны не требуются), чтобы определить, следует ли возвращать внешнюю строку.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-562">Then the `Nested Loops` operator can determine how many rows are output by the row count spool (because the actual data from the inner side is not needed) to determine whether to return the outer row.</span></span> <span data-ttu-id="5a2a2-563">Оператор**Row Count Spool** — это физический оператор.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-563">**Row Count Spool** is a physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-564">![Значок оператора Segment](../../2014/database-engine/media/segment-32x.gif "Значок оператора Segment")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-564">![Segment operator icon](../../2014/database-engine/media/segment-32x.gif "Segment operator icon")</span></span>|<span data-ttu-id="5a2a2-565">**Segment**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-565">**Segment**</span></span>|<span data-ttu-id="5a2a2-566">**Segment** является физическим и логическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-566">**Segment** is a physical and a logical operator.</span></span> <span data-ttu-id="5a2a2-567">Он делит входной набор на сегменты в соответствии со значением одного или нескольких столбцов.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-567">It divides the input set into segments based on the value of one or more columns.</span></span> <span data-ttu-id="5a2a2-568">Эти столбцы отображаются в виде аргументов оператора **Segment** .</span><span class="sxs-lookup"><span data-stu-id="5a2a2-568">These columns are shown as arguments in the **Segment** operator.</span></span> <span data-ttu-id="5a2a2-569">Затем оператор выводит по одному сегменту за раз.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-569">The operator then outputs one segment at a time.</span></span>|  
|<span data-ttu-id="5a2a2-570">Нет</span><span class="sxs-lookup"><span data-stu-id="5a2a2-570">None</span></span>|`Segment Repartition`|<span data-ttu-id="5a2a2-571">В плане параллельных запросов иногда содержатся концептуальные области итераторов.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-571">In a parallel query plan, sometimes there are conceptual regions of iterators.</span></span> <span data-ttu-id="5a2a2-572">Все итераторы в рамках такой области могут обрабатываться параллельными потоками.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-572">All of the iterators within such a region can be executed by parallel threads.</span></span> <span data-ttu-id="5a2a2-573">Сами же области должны обрабатываться последовательно.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-573">The regions themselves must be executed serially.</span></span> <span data-ttu-id="5a2a2-574">Некоторые итераторы оператора `Parallelism` внутри отдельной области называются `Branch Repartition`.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-574">Some of the `Parallelism` iterators within an individual region are called `Branch Repartition`.</span></span> <span data-ttu-id="5a2a2-575">Итератор оператора `Parallelism` на границе двух таких областей называется `Segment Repartition`.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-575">The `Parallelism` iterator at the boundary of two such regions is called `Segment Repartition`.</span></span> <span data-ttu-id="5a2a2-576">`Branch Repartition` и `Segment Repartition` являются логическими операторами.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-576">`Branch Repartition` and `Segment Repartition` are logical operators.</span></span>|  
|<span data-ttu-id="5a2a2-577">![Значок оператора Sequence](../../2014/database-engine/media/sequence-32x.gif "Значок оператора Sequence")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-577">![Sequence operator icon](../../2014/database-engine/media/sequence-32x.gif "Sequence operator icon")</span></span>|`Sequence`|<span data-ttu-id="5a2a2-578">Оператор `Sequence` выполняет планы широкого обновления.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-578">The `Sequence` operator drives wide update plans.</span></span> <span data-ttu-id="5a2a2-579">Практически он выполняет каждый вход по очереди (сверху вниз).</span><span class="sxs-lookup"><span data-stu-id="5a2a2-579">Functionally, it executes each input in sequence (top to bottom).</span></span> <span data-ttu-id="5a2a2-580">Каждый вход обычно является обновлением отдельного объекта.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-580">Each input is usually an update of a different object.</span></span> <span data-ttu-id="5a2a2-581">Он возвращает лишь строки, полученные из последнего (нижнего) входа.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-581">It returns only those rows that come from its last (bottom) input.</span></span> <span data-ttu-id="5a2a2-582">`Sequence` является логическим и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-582">`Sequence` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-583">![Значок оператора Sequence Project](../../2014/database-engine/media/sequence-project-32x.gif "Значок оператора Sequence Project")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-583">![Sequence project operator icon](../../2014/database-engine/media/sequence-project-32x.gif "Sequence project operator icon")</span></span>|`Sequence Project`|<span data-ttu-id="5a2a2-584">Оператор `Sequence Project` добавляет столбцы для выполнения вычислений над упорядоченным набором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-584">The `Sequence Project` operator adds columns to perform computations over an ordered set.</span></span> <span data-ttu-id="5a2a2-585">Он делит входной набор на сегменты в соответствии со значением одного или нескольких столбцов.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-585">It divides the input set into segments based on the value of one or more columns.</span></span> <span data-ttu-id="5a2a2-586">Затем оператор выводит по одному сегменту за раз.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-586">The operator then outputs one segment at a time.</span></span> <span data-ttu-id="5a2a2-587">Эти столбцы отображаются как аргументы оператора `Sequence Project`.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-587">These columns are shown as arguments in the `Sequence Project` operator.</span></span> <span data-ttu-id="5a2a2-588">`Sequence Project` является логическим и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-588">`Sequence Project` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-589">![Значок оператора курсора Snapshot](../../2014/database-engine/media/snapshot-32x.gif "Значок оператора курсора Snapshot")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-589">![Snapshot cursor operator icon](../../2014/database-engine/media/snapshot-32x.gif "Snapshot cursor operator icon")</span></span>|<span data-ttu-id="5a2a2-590">**Моментальный снимок**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-590">**Snapshot**</span></span>|<span data-ttu-id="5a2a2-591">Оператор **Snapshot** создает курсор, который не видит изменений, сделанных другими курсорами.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-591">The **Snapshot** operator creates a cursor that does not see changes made by others.</span></span>|  
|<span data-ttu-id="5a2a2-592">![Значок оператора Sort](../../2014/database-engine/media/sort-32x.gif "Значок оператора Sort")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-592">![Sort operator icon](../../2014/database-engine/media/sort-32x.gif "Sort operator icon")</span></span>|`Sort`|<span data-ttu-id="5a2a2-593">`Sort`Оператор сортирует все входящие строки.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-593">The `Sort` operator sorts all incoming rows.</span></span> <span data-ttu-id="5a2a2-594">`Argument`Столбец содержит ПРЕДИКАТ Order By:(), если в этой операции удаляются дубликаты, или ПРЕДИКАТ Order By:() с разделенным запятыми списком столбцов.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-594">The `Argument` column contains either a DISTINCT ORDER BY:() predicate if duplicates are removed by this operation, or an ORDER BY:() predicate with a comma-separated list of the columns being sorted.</span></span> <span data-ttu-id="5a2a2-595">Столбцы имеют префикс со значением ASC, если они сортируются по возрастанию, или значением DESC, если сортируются по убыванию.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-595">The columns are prefixed with the value ASC if the columns are sorted in ascending order, or the value DESC if the columns are sorted in descending order.</span></span> <span data-ttu-id="5a2a2-596">`Sort` является логическим и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-596">`Sort` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-597">![Значок оператора Split](../../2014/database-engine/media/split-32x.gif "Значок оператора Split")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-597">![Split operator icon](../../2014/database-engine/media/split-32x.gif "Split operator icon")</span></span>|`Split`|<span data-ttu-id="5a2a2-598">`Split`Оператор используется для оптимизации обработки обновлений.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-598">The `Split` operator is used to optimize update processing.</span></span> <span data-ttu-id="5a2a2-599">Он разбивает каждую операцию обновления на операции удаления и вставки.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-599">It splits each update operation into a delete and an insert operation.</span></span> <span data-ttu-id="5a2a2-600">`Split` является логическим и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-600">`Split` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-601">![Значок оператора Spool](../../2014/database-engine/media/spool-32x.gif "Значок оператора Spool")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-601">![Spool operator icon](../../2014/database-engine/media/spool-32x.gif "Spool operator icon")</span></span>|<span data-ttu-id="5a2a2-602">**Spool**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-602">**Spool**</span></span>|<span data-ttu-id="5a2a2-603">Оператор **spool** сохраняет промежуточный результат запроса в `tempdb` базе данных.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-603">The **Spool** operator saves an intermediate query result to the `tempdb` database.</span></span>|  
|<span data-ttu-id="5a2a2-604">![Значок оператора Stream Aggregate](../../2014/database-engine/media/stream-aggregate-32x.gif "Значок оператора Stream Aggregate")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-604">![Stream aggregate operator icon](../../2014/database-engine/media/stream-aggregate-32x.gif "Stream aggregate operator icon")</span></span>|`Stream Aggregate`|<span data-ttu-id="5a2a2-605">Оператор `Stream Aggregate` группирует строки в один или несколько столбцов и вычисляет одно или несколько агрегатных выражений, возвращенных запросом.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-605">The `Stream Aggregate` operator groups rows by one or more columns and then calculates one or more aggregate expressions returned by the query.</span></span> <span data-ttu-id="5a2a2-606">Выход этого оператора может быть использован последующими операторами запроса, возвращен клиенту или то и другое.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-606">The output of this operator can be referenced by later operators in the query, returned to the client, or both.</span></span> <span data-ttu-id="5a2a2-607">Оператору `Stream Aggregate` необходимы входные данные, упорядоченные по группируемым столбцам.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-607">The `Stream Aggregate` operator requires input ordered by the columns within its groups.</span></span> <span data-ttu-id="5a2a2-608">Оптимизатор использует перед этим оператором оператор `Sort`, если данные не были ранее отсортированы оператором `Sort` или используется упорядоченный поиск или просмотр в индексе.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-608">The optimizer will use a `Sort` operator prior to this operator if the data is not already sorted due to a prior `Sort` operator or due to an ordered index seek or scan.</span></span> <span data-ttu-id="5a2a2-609">В инструкции SHOWPLAN_ALL или графическом плане выполнения в [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] , столбцы в предикате GROUP BY перечислены в `Argument` столбце, а статистические выражения перечислены в столбце **определенные значения** .</span><span class="sxs-lookup"><span data-stu-id="5a2a2-609">In the SHOWPLAN_ALL statement or the graphical execution plan in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], the columns in the GROUP BY predicate are listed in the `Argument` column, and the aggregate expressions are listed in the **Defined Values** column.</span></span> <span data-ttu-id="5a2a2-610">`Stream Aggregate` является физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-610">`Stream Aggregate` is a physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-611">![Значок оператора Switch](../../2014/database-engine/media/switch-32x.gif "Значок оператора Switch")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-611">![Switch operator icon](../../2014/database-engine/media/switch-32x.gif "Switch operator icon")</span></span>|<span data-ttu-id="5a2a2-612">**Параметр**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-612">**Switch**</span></span>|<span data-ttu-id="5a2a2-613">Оператор**Switch** представляет собой особый тип итератора объединения, который имеет *n* входов.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-613">**Switch** is a special type of concatenation iterator that has *n* inputs.</span></span> <span data-ttu-id="5a2a2-614">Выражение связывается с каждым оператором **Switch** .</span><span class="sxs-lookup"><span data-stu-id="5a2a2-614">An expression is associated with each **Switch** operator.</span></span> <span data-ttu-id="5a2a2-615">В зависимости от возвращаемого значения выражения (между 0 и *n*-1) оператор **Switch** копирует соответствующий входной поток в выходной поток.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-615">Depending on the return value of the expression (between 0 and *n*-1), **Switch** copies the appropriate input stream to the output stream.</span></span> <span data-ttu-id="5a2a2-616">В частности, оператор **Switch** применяется при реализации планов запроса, содержащих быстрые курсоры прямого направления с такими операторами, как **TOP** .</span><span class="sxs-lookup"><span data-stu-id="5a2a2-616">One use of **Switch** is to implement query plans involving fast forward cursors with certain operators such as the **TOP** operator.</span></span> <span data-ttu-id="5a2a2-617">**Switch** является и логическим, и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-617">**Switch** is both a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-618">![Значок оператора Table Delete](../../2014/database-engine/media/table-delete-32x.gif "Значок оператора Table Delete")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-618">![Table delete operator icon](../../2014/database-engine/media/table-delete-32x.gif "Table delete operator icon")</span></span>|`Table Delete`|<span data-ttu-id="5a2a2-619">`Table Delete`Физический оператор удаляет строки из таблицы, указанной в `Argument` столбце плана выполнения запроса.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-619">The `Table Delete` physical operator deletes rows from the table specified in the `Argument` column of the query execution plan.</span></span>|  
|<span data-ttu-id="5a2a2-620">![Значок оператора Table insert](../../2014/database-engine/media/table-insert-32x.gif "Значок оператора Table Insert")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-620">![Table insert operator icon](../../2014/database-engine/media/table-insert-32x.gif "Table insert operator icon")</span></span>|`Table Insert`|<span data-ttu-id="5a2a2-621">`Table Insert`Оператор вставляет строки из входных данных в таблицу, указанную в `Argument` столбце плана выполнения запроса.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-621">The `Table Insert` operator inserts rows from its input into the table specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="5a2a2-622">В столбце `Argument` также содержится предикат SET:(), который указывает значение, устанавливаемое для каждого столбца.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-622">The `Argument` column also contains a SET:() predicate, which indicates the value to which each column is set.</span></span> <span data-ttu-id="5a2a2-623">Если оператор `Table Insert` не имеет потомков для вставки значений, то вставленная строка берется из самого оператора вставки.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-623">If `Table Insert` has no children for insert values, then the row inserted is taken from the Insert operator itself.</span></span> <span data-ttu-id="5a2a2-624">`Table Insert` является физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-624">`Table Insert` is a physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-625">![Оператор Table Merge](../../2014/database-engine/media/table-merge-32x.gif "Оператор Table Merge")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-625">![Table merge operator](../../2014/database-engine/media/table-merge-32x.gif "Table merge operator")</span></span>|<span data-ttu-id="5a2a2-626">**Table Merge**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-626">**Table Merge**</span></span>|<span data-ttu-id="5a2a2-627">Оператор **Table Merge** применяет поток данных слияния к куче.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-627">The **Table Merge** operator applies a merge data stream to a heap.</span></span> <span data-ttu-id="5a2a2-628">Оператор удаляет, обновляет или вставляет строки в таблицу, указанную в `Argument` столбце оператора.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-628">The operator deletes, updates, or inserts rows in the table specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="5a2a2-629">Фактическая операция зависит от значения столбца **Action** во время выполнения, указанного в `Argument` столбце оператора.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-629">The actual operation performed depends on the run-time value of the **ACTION** column specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="5a2a2-630">**Table Merge** является физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-630">**Table Merge** is a physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-631">![Значок оператора Table Scan](../../2014/database-engine/media/table-scan-32x.gif "Значок оператора Table Scan")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-631">![Table scan operator icon](../../2014/database-engine/media/table-scan-32x.gif "Table scan operator icon")</span></span>|`Table Scan`|<span data-ttu-id="5a2a2-632">`Table Scan`Оператор получает все строки из таблицы, указанной в `Argument` столбце плана выполнения запроса.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-632">The `Table Scan` operator retrieves all rows from the table specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="5a2a2-633">Если в столбце присутствует предикат WHERE:() `Argument` , возвращаются только те строки, которые соответствуют предикату.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-633">If a WHERE:() predicate appears in the `Argument` column, only those rows that satisfy the predicate are returned.</span></span> <span data-ttu-id="5a2a2-634">`Table Scan` является логическим и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-634">`Table Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-635">![Значок оператора Table Spool](../../2014/database-engine/media/table-spool-32x.gif "Значок оператора Table Spool")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-635">![Table spool operator icon](../../2014/database-engine/media/table-spool-32x.gif "Table spool operator icon")</span></span>|<span data-ttu-id="5a2a2-636">**Table Spool**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-636">**Table Spool**</span></span>|<span data-ttu-id="5a2a2-637">Оператор **Table Spool** просматривает входную таблицу и помещает копию каждой строки в скрытую буферную таблицу, которая находится в базе данных [tempdb](../relational-databases/databases/tempdb-database.md) и существует только в течение времени жизни запроса.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-637">The **Table Spool** operator scans the input and places a copy of each row in a hidden spool table that is stored in the [tempdb](../relational-databases/databases/tempdb-database.md) database and existing only for the lifetime of the query.</span></span> <span data-ttu-id="5a2a2-638">Если оператор перематывает (например, `Nested Loops` оператор), но не требуется повторная привязка, то вместо повторного сканирования входных данных используется очередь.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-638">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span> <span data-ttu-id="5a2a2-639">**Table Spool** является физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-639">**Table Spool** is a physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-640">![Значок оператора Table Update](../../2014/database-engine/media/table-update-32x.gif "Значок оператора Table Update")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-640">![Table update operator icon](../../2014/database-engine/media/table-update-32x.gif "Table update operator icon")</span></span>|`Table Update`|<span data-ttu-id="5a2a2-641">`Table Update`Физический оператор обновляет входные строки в таблице, указанной в `Argument` столбце плана выполнения запроса.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-641">The `Table Update` physical operator updates input rows in the table specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="5a2a2-642">Предикат SET:() определяет значение для каждого обновляемого столбца.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-642">The SET:() predicate determines the value of each updated column.</span></span> <span data-ttu-id="5a2a2-643">Эти значения могут быть упомянуты в предложении SET или в другом месте в этом операторе, а также в каком-либо другом месте в рамках запроса.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-643">These values may be referenced in the SET clause or elsewhere within this operator as well as elsewhere within this query.</span></span>|  
|<span data-ttu-id="5a2a2-644">![Значок оператора Table-Valued Function](../../2014/database-engine/media/table-valued-function-32x.gif "Значок оператора Table-Valued Function")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-644">![Table-valued function operator icon](../../2014/database-engine/media/table-valued-function-32x.gif "Table-valued function operator icon")</span></span>|<span data-ttu-id="5a2a2-645">**Table-valued Function**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-645">**Table-valued Function**</span></span>|<span data-ttu-id="5a2a2-646">Оператор **Table-valued Function** вычисляет функцию с табличным значением (языка [!INCLUDE[tsql](../includes/tsql-md.md)] или среды CLR) и сохраняет строки результата в базе данных [tempdb](../relational-databases/databases/tempdb-database.md) .</span><span class="sxs-lookup"><span data-stu-id="5a2a2-646">The **Table-valued Function** operator evaluates a table-valued function (either [!INCLUDE[tsql](../includes/tsql-md.md)] or CLR), and stores the resulting rows in the [tempdb](../relational-databases/databases/tempdb-database.md) database.</span></span> <span data-ttu-id="5a2a2-647">Когда родительские итераторы запрашивают строки, возвращающая **табличное значение функция** возвращает строки из `tempdb` .</span><span class="sxs-lookup"><span data-stu-id="5a2a2-647">When the parent iterators request the rows, **Table-valued Function** returns the rows from `tempdb`.</span></span><br /><br /> <span data-ttu-id="5a2a2-648">Запросы, вызывающие функции с табличным значением, формируют планы запросов с итератором **Table-valued Function** .</span><span class="sxs-lookup"><span data-stu-id="5a2a2-648">Queries with calls to table-valued functions generate query plans with the **Table-valued Function** iterator.</span></span> <span data-ttu-id="5a2a2-649">**Функция с табличным значением** может вычисляться с различными значениями параметров:</span><span class="sxs-lookup"><span data-stu-id="5a2a2-649">**Table-valued Function** can be evaluated with different parameter values:</span></span><br /><br /> <span data-ttu-id="5a2a2-650">**Модуль чтения функции с табличным значением XML** принимает большой двоичный объект XML как параметр и возвращает набор строк, представляющий узлы XML в том же порядке, что и в документе XML.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-650">**Table-valued Function XML Reader** inputs an XML BLOB as a parameter and produces a rowset representing XML nodes in XML document order.</span></span> <span data-ttu-id="5a2a2-651">Другие параметры могут ограничивать возвращаемые XML-узлы подмножеством XML-документа.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-651">Other input parameters may restrict XML nodes returned to a subset of XML document.</span></span><br /><br /> <span data-ttu-id="5a2a2-652">**Модуль чтения функции с табличным значением XML с фильтром XPath** — это специальный тип **модуля чтения функции с табличным значением XML** , ограничивающий результат узлами XML, соответствующими выражению XPath.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-652">**Table Valued Function XML Reader with XPath filter** is a special type of **XML Reader Table-valued Function** that restricts output to XML nodes satisfying an XPath expression.</span></span><br /><br /> <br /><br /> <span data-ttu-id="5a2a2-653">Оператор**Table-valued Function** — это логический и физический оператор.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-653">**Table-valued Function** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-654">![Значок оператора Top](../../2014/database-engine/media/top-32x.gif "Значок оператора Top")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-654">![Top operator icon](../../2014/database-engine/media/top-32x.gif "Top operator icon")</span></span>|<span data-ttu-id="5a2a2-655">**Top**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-655">**Top**</span></span>|<span data-ttu-id="5a2a2-656">Оператор **Top** просматривает входные данные и возвращает только указанное число или процент строк, выбранных, возможно, на основе порядка сортировки.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-656">The **Top** operator scans the input, returning only the first specified number or percent of rows, possibly based on a sort order.</span></span> <span data-ttu-id="5a2a2-657">`Argument`Столбец может содержать список столбцов, которые проверяются на наличие связей.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-657">The `Argument` column can contain a list of the columns that are being checked for ties.</span></span> <span data-ttu-id="5a2a2-658">Планируется использовать оператор **Top** для соблюдения ограничений на число строк.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-658">In update plans, the **Top** operator is used to enforce row count limits.</span></span> <span data-ttu-id="5a2a2-659">**Top** — это логический и физический оператор.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-659">**Top** is a logical and physical operator.</span></span> <span data-ttu-id="5a2a2-660">**Top** — это логический и физический оператор.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-660">**Top** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="5a2a2-661">None</span><span class="sxs-lookup"><span data-stu-id="5a2a2-661">None</span></span>|<span data-ttu-id="5a2a2-662">**Top N Sort**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-662">**Top N Sort**</span></span>|<span data-ttu-id="5a2a2-663">**Первые n сортировок** похожи на `Sort` итератор, за исключением того, что требуются только первые *n* строк, а не весь результирующий набор.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-663">**Top N Sort** is similar to the `Sort` iterator, except that only the first *N* rows are needed, and not the entire result set.</span></span> <span data-ttu-id="5a2a2-664">Для небольших значений *N*ядро выполнения запросов [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] пытается выполнить операцию сортировки полностью в памяти.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-664">For small values of *N*, the [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] query execution engine attempts to perform the entire sort operation in memory.</span></span> <span data-ttu-id="5a2a2-665">Для больших значений *N*ядро выполнения запросов использует более общий способ сортировки, в котором *N* не является параметром.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-665">For large values of *N*, the query execution engine resorts to the more generic method of sorting to which *N* is not a parameter.</span></span>|  
|<span data-ttu-id="5a2a2-666">![Значок расширенного оператора (UDX)](../../2014/database-engine/media/udx-32x.gif "Значок расширенного оператора (UDX)")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-666">![Extended operator (UDX) icon](../../2014/database-engine/media/udx-32x.gif "Extended operator (UDX) icon")</span></span>|`UDX`|<span data-ttu-id="5a2a2-667">Расширенные операторы (UDX) реализуют часть операций XQuery и XPath в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5a2a2-667">Extended Operators (UDX) implement one of many XQuery and XPath operations in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="5a2a2-668">Все операторы UDX являются и логическими, и физическими операторами.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-668">All UDX operators are both logical and physical operators.</span></span><br /><br /> <span data-ttu-id="5a2a2-669">Расширенный оператор (UDX) `FOR XML` используется для сериализации реляционных наборов строк, которые он получает на входе, в представление XML в одном столбце BLOB в единственной строке на выходе.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-669">Extended operator (UDX) `FOR XML` is used to serialize the relational row set it inputs into XML representation in a single BLOB column in a single output row.</span></span> <span data-ttu-id="5a2a2-670">Это статистический оператор XML, учитывающий порядок данных.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-670">It is an order sensitive XML aggregation operator.</span></span><br /><br /> <span data-ttu-id="5a2a2-671">Расширенный оператор (UDX) `XML SERIALIZER` — это статистический оператор XML, учитывающий порядок данных.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-671">Extended operator (UDX) `XML SERIALIZER` is an order sensitive XML aggregation operator.</span></span> <span data-ttu-id="5a2a2-672">Он получает на входе строки, представляющие XML-узлы или скаляры XQuery в порядке, соответствующем XML-документу, и выдает сериализованный XML BLOB в единственном XML-столбце единственной строки вывода.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-672">It inputs rows representing XML nodes or XQuery scalars in XML document order and produces a serialized XML BLOB in a single XML column in a single output row.</span></span><br /><br /> <span data-ttu-id="5a2a2-673">Расширенный оператор (UDX) `XML FRAGMENT SERIALIZER` является особым видом оператора `XML SERIALIZER`, использующимся для обработки входных строк, представляющих фрагменты XML, вставляемые в расширении вставки данных XQuery.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-673">Extended operator (UDX) `XML FRAGMENT SERIALIZER` is a special type of `XML SERIALIZER` that is used for processing input rows representing XML fragments being inserted in XQuery insert data modification extension.</span></span><br /><br /> <span data-ttu-id="5a2a2-674">Расширенный оператор (UDX) `XQUERY STRING` вычисляет строковое значение XQuery из входных строк, представляющих собой узлы XML.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-674">Extended operator (UDX) `XQUERY STRING` evaluates the XQuery string value of input rows representing XML nodes.</span></span> <span data-ttu-id="5a2a2-675">Это статистический строковый оператор, чувствительный к порядку данных.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-675">It is an order sensitive string aggregation operator.</span></span> <span data-ttu-id="5a2a2-676">Он выводит одну строку со столбцами, представляющими скаляр XQuery, содержащий строковое значение входа.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-676">It outputs one row with columns representing the XQuery scalar that contains string value of the input.</span></span><br /><br /> <span data-ttu-id="5a2a2-677">Расширенный оператор (UDX) `XQUERY LIST DECOMPOSER` является оператором декомпозиции списка XQuery.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-677">Extended operator (UDX) `XQUERY LIST DECOMPOSER` is an XQuery list decomposition operator.</span></span> <span data-ttu-id="5a2a2-678">Для каждой входной строки, представляющей собой узел XML, он создает одну или несколько строк, представляющих скаляр XQuery, содержащий значение элемента списка, если входные данные имеют тип списка XSD.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-678">For each input row representing an XML node it produces one or more rows each representing XQuery scalar containing a list element value if the input is of XSD list type.</span></span><br /><br /> <span data-ttu-id="5a2a2-679">Расширенный оператор (UDX) `XQUERY DATA` определяет значение функции XQuery fn:data() для входных данных, представляющих собой узлы XML.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-679">Extended operator (UDX) `XQUERY DATA` evaluates the XQuery fn:data() function on input representing XML nodes.</span></span> <span data-ttu-id="5a2a2-680">Это статистический строковый оператор, чувствительный к порядку данных.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-680">It is an order sensitive string aggregation operator.</span></span> <span data-ttu-id="5a2a2-681">Он выводит одну строку со столбцами, представляющими собой скаляр XQuery, содержащий значение функции **fn:data()** .</span><span class="sxs-lookup"><span data-stu-id="5a2a2-681">It outputs one row with columns representing XQuery scalar that contains the result of **fn:data()**.</span></span><br /><br /> <span data-ttu-id="5a2a2-682">Расширенный оператор `XQUERY CONTAINS` определяет значение функции XQuery fn:contains() для входных данных, представляющих собой узлы XML.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-682">Extended operator `XQUERY CONTAINS` evaluates the XQuery fn:contains() function on input representing XML nodes.</span></span> <span data-ttu-id="5a2a2-683">Это статистический строковый оператор, чувствительный к порядку данных.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-683">It is an order sensitive string aggregation operator.</span></span> <span data-ttu-id="5a2a2-684">Он выводит одну строку со столбцами, представляющими собой скаляр XQuery, содержащий значение функции **fn:contains()** .</span><span class="sxs-lookup"><span data-stu-id="5a2a2-684">It outputs one row with columns representing XQuery scalar that contains the result of **fn:contains()**.</span></span><br /><br /> <span data-ttu-id="5a2a2-685">Расширенный оператор `UPDATE XML NODE` обновляет XML-узел в расширении изменения данных XQuery Replace в методе **Modify ()** для типа XML.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-685">Extended operator `UPDATE XML NODE` updates XML node in the XQuery replace data modification extension in the **modify()** method on XML type.</span></span>|  
|<span data-ttu-id="5a2a2-686">None</span><span class="sxs-lookup"><span data-stu-id="5a2a2-686">None</span></span>|<span data-ttu-id="5a2a2-687">**Union**</span><span class="sxs-lookup"><span data-stu-id="5a2a2-687">**Union**</span></span>|<span data-ttu-id="5a2a2-688">Оператор **Union** просматривает несколько входов, выводя каждую просмотренную строку и удаляя дубликаты.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-688">The **Union** operator scans multiple inputs, outputting each row scanned and removing duplicates.</span></span> <span data-ttu-id="5a2a2-689">**Union** — это логический оператор.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-689">**Union** is a logical operator.</span></span>|  
|<span data-ttu-id="5a2a2-690">![Значок оператора Update (ядро СУБД)](../../2014/database-engine/media/update-32x.gif "Значок оператора Update (ядро СУБД)")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-690">![Update (Database Engine) operator icon](../../2014/database-engine/media/update-32x.gif "Update (Database Engine) operator icon")</span></span>|`Update`|<span data-ttu-id="5a2a2-691">`Update`Оператор обновляет каждую строку из входных данных в объекте, указанном в `Argument` столбце плана выполнения запроса.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-691">The `Update` operator updates each row from its input in the object specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="5a2a2-692">`Update` является логическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-692">`Update` is a logical operator.</span></span> <span data-ttu-id="5a2a2-693">Операторы `Table Update`, `Index Update` или `Clustered Index Update` являются физическими.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-693">The physical operator is `Table Update`, `Index Update`, or `Clustered Index Update`.</span></span>|  
|<span data-ttu-id="5a2a2-694">![Значок элемента языка While](../../2014/database-engine/media/while-32x.gif "Значок элемента языка While")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-694">![While language element icon](../../2014/database-engine/media/while-32x.gif "While language element icon")</span></span>|`While`|<span data-ttu-id="5a2a2-695">Оператор `While` реализует цикл while языка [!INCLUDE[tsql](../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5a2a2-695">The `While` operator implements the [!INCLUDE[tsql](../includes/tsql-md.md)] while loop.</span></span> <span data-ttu-id="5a2a2-696">`While` является элементом языка.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-696">`While` is a language element</span></span>|  
|<span data-ttu-id="5a2a2-697">![Значок оператора Table Spool](../../2014/database-engine/media/table-spool-32x.gif "Значок оператора Table Spool")</span><span class="sxs-lookup"><span data-stu-id="5a2a2-697">![Table spool operator icon](../../2014/database-engine/media/table-spool-32x.gif "Table spool operator icon")</span></span>|`Window Spool`|<span data-ttu-id="5a2a2-698">Оператор `Window Spool` расширяет каждую строку в набор строк, представляющий связанное с ним окно.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-698">The `Window Spool` operator expands each row into the set of rows that represents the window associated with it.</span></span> <span data-ttu-id="5a2a2-699">В запросе предложение OVER определяет окно в наборе результатов запроса, а оконная функция затем вычисляет значения для каждой строки в окне.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-699">In a query, the OVER clause defines the window within a query result set and a window function then computes a value for each row in the window.</span></span> <span data-ttu-id="5a2a2-700">`Window Spool` является логическим и физическим оператором.</span><span class="sxs-lookup"><span data-stu-id="5a2a2-700">`Window Spool` is a logical and physical operator.</span></span>|  
  
  

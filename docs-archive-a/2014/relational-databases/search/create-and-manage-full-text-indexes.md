---
title: Создание полнотекстовых индексов и управление ими | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: search
ms.topic: conceptual
helpviewer_keywords:
- full-text indexes [SQL Server], about
ms.assetid: f8a98486-5438-44a8-b454-9e6ecbc74f83
author: MikeRayMSFT
ms.author: mikeray
ms.openlocfilehash: 603b5e6b929259dc8b1408c0c2a1afab383446e1
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87732537"
---
# <a name="create-and-manage-full-text-indexes"></a>Создание и управление полнотекстовыми индексами
  Данные полнотекстовых индексов используются средством полнотекстового поиска для компиляции полнотекстовых запросов, способных быстро находить таблицу с теми или иными словами или словосочетаниями. В полнотекстовом индексе хранятся данные о значимых для поиска словах и их расположении в одном или нескольких столбцах таблицы базы данных. Полнотекстовый индекс — это специальный тип функционального индекса на основе токенов, создаваемый и используемый средством полнотекстового поиска для [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Процесс создания полнотекстового индекса отличается от создания индексов других типов. Вместо создания сбалансированного дерева на основе значения, хранящегося в конкретной строке, служба полнотекстового поиска создает инвертированную стековую сжатую структуру индекса на основе отдельных токенов индексируемого текста.  Размер полнотекстового индекса ограничен только доступными ресурсами памяти компьютера, на котором запущен экземпляр [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] .  
  
 Начиная с [!INCLUDE[ssKatmai](../../includes/sskatmai-md.md)]полнотекстовые индексы встроены в ядро СУБД, а не размещены в файловой системе, как в предыдущих версиях [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. В новой базе данных полнотекстовый каталог является виртуальным объектом, не принадлежащим ни к одной файловой группе. Он является лишь логическим понятием, связанным с группой полнотекстовых индексов. Однако обратите внимание, что при обновлении базы данных [!INCLUDE[ssVersion2005](../../includes/ssversion2005-md.md)] (любого полнотекстового каталога с файлами данных) создается новая файловая группа. Дополнительные сведения см. в разделе [Обновление полнотекстового поиска](upgrade-full-text-search.md).  
  
> [!NOTE]  
>  В [!INCLUDE[ssKatmai](../../includes/sskatmai-md.md)] и более поздних версиях средство полнотекстового поиска находится в процессе [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] , а не в отдельной службе. Интеграция средства полнотекстового поиска в компонент Database Engine повышает управляемость, оптимизацию смешанных запросов и общую производительность.  
  
 На одну таблицу может приходиться только один полнотекстовый индекс. Чтобы в таблице можно было создать полнотекстовый индекс, она должна содержать один уникальный столбец, значением которого не является NULL. Можно создать полнотекстовый индекс на столбцах типа `char`, `varchar`, `nchar`, `nvarchar`, `text`, `ntext`, `image`, `xml`, `varbinary`, а также для полнотекстового поиска может индексироваться `varbinary(max)`. Для создания полнотекстового индекса на столбце, тип данных которого `varbinary`, `varbinary(max)`, `image` или `xml`, необходимо указать столбец типов. *Столбец типов* — это столбец таблицы, в каждой строке которого хранятся расширения файлов (DOC, PDF, XLS и т. д.) документа.  
  
 Процесс создания и сопровождения полнотекстового индекса называется *заполнением* (а также *сканированием*). Существует три типа заполнения полнотекстового индекса: полное заполнение, заполнение на основе отслеживания изменений и добавочное заполнение с использованием меток времени. Дополнительные сведения см. в разделе [Заполнение полнотекстовых индексов](populate-full-text-indexes.md).  
  
##  <a name="common-tasks"></a><a name="tasks"></a>Общие задачи  
 **Создание полнотекстового индекса**  
  
-   [CREATE FULLTEXT INDEX (Transact-SQL)](/sql/t-sql/statements/create-fulltext-index-transact-sql)  
  
 **Изменение полнотекстового индекса**  
  
-   [ALTER FULLTEXT INDEX (Transact-SQL)](/sql/t-sql/statements/alter-fulltext-index-transact-sql)  
  
 **Удаление полнотекстового индекса**  
  
-   [DROP FULLTEXT INDEX (Transact-SQL)](/sql/t-sql/statements/drop-fulltext-index-transact-sql)  
  
 [В этом разделе](#top)  
  
##  <a name="full-text-index-structure"></a><a name="structure"></a>Структура полнотекстового индекса  
 Чтобы понять, как работает средство полнотекстового поиска, необходимо разобраться в структуре полнотекстового индекса. В данном разделе в качестве примера таблицы используется следующий фрагмент таблицы **Document** в [!INCLUDE[ssSampleDBCoShort](../../includes/sssampledbcoshort-md.md)] . В данном фрагменте показываются только два столбца: **DocumentID** и **Title** , а также три строки из таблицы.  
  
 В этом примере подразумевается, что полнотекстовый индекс был создан по столбцу **Title** .  
  
|DocumentID|Title|  
|----------------|-----------|  
|1|Crank Arm and Tire Maintenance|  
|2|Front Reflector Bracket and Reflector Assembly 3|  
|3|Front Reflector Bracket Installation|  
  
 Например, в следующей таблице, в которой приведен фрагмент 1, показано содержимое полнотекстового индекса, созданного по столбцу **Title** таблицы **Document** . Полнотекстовые индексы содержат больше данных, чем представлено в этой таблице. Таблица является логическим представлением полнотекстового индекса, она предоставляется только с целью демонстрации. Строки хранятся в сжатом формате для оптимизации использования диска.  
  
 Обратите внимание, что данные были инвертированы по сравнению с оригинальными документами. Инверсия происходит, поскольку ключевые слова сопоставлены с идентификаторами документов. По этой причине полнотекстовый индекс часто называют инвертированным индексом.  
  
 Обратите также внимание, что ключевое слово «and» было удалено из полнотекстового индекса. Это было сделано, поскольку «and» является стоп-словом. Удаление стоп-слов из полнотекстового индекса может привести к значительной экономии дискового пространства, тем самым увеличивая производительность запросов. Дополнительные сведения о стоп-словах см. в разделе [Настройка и управление стоп-словами и списками стоп-слов для полнотекстового поиска](configure-and-manage-stopwords-and-stoplists-for-full-text-search.md).  
  
 **Фрагмент 1**  
  
|Ключевое слово|ColId|DocId|Наличие|  
|-------------|-----------|-----------|----------------|  
|Crank|1|1|1|  
|Arm|1|1|2|  
|Tire|1|1|4|  
|Обслуживание|1|1|5|  
|Front|1|2|1|  
|Front|1|3|1|  
|Reflector|1|2|2|  
|Reflector|1|2|5|  
|Reflector|1|3|2|  
|Bracket|1|2|3|  
|Bracket|1|3|3|  
|Сборка|1|2|6|  
|3|1|2|7|  
|Установка|1|3|4|  
  
 Столбец **Keyword** содержит представление одного токена, извлеченного при индексировании. Токены определяются средствами разбиения по словам.  
  
 Столбец **ColId** содержит значение, соответствующее столбцу, по которому выполняется полнотекстовое индексирование.  
  
 `DocId`Столбец содержит значения для 8-байтового целого числа, сопоставляемого с определенным значением полнотекстового ключа в таблице с полнотекстовым индексом. Данное поведение необходимо, если полнотекстовый ключ имеет тип данных, отличный от целого. В таких случаях сопоставления между значениями полнотекстовых ключей и `DocId` значениями сохраняются в отдельной таблице, именуемой таблицей сопоставления DocId. Для создания запросов к этим сопоставлениям следует использовать системную хранимую процедуру [sp_fulltext_keymappings](/sql/relational-databases/system-stored-procedures/sp-fulltext-keymappings-transact-sql) . Для удовлетворения условия поиска необходимо соединить значения DocId из приведенной выше таблицы с таблицей сопоставления DocId. Это позволит возвращать строки из запрашиваемой базовой таблицы. Если значение полнотекстового ключа из базовой таблицы имеет целочисленный тип, то само значение служит в качестве значения DocId и дополнительного сопоставления не требуется. Следовательно, использование целочисленных значений полнотекстового ключа может оптимизировать выполнение полнотекстовых запросов.  
  
 Столбец **Occurrence** содержит целочисленное значение. Каждому значению DocId соответствует список значений частотности, которые соответствуют относительным смещениям слов для определенного ключевого слова в документе с этим значением DocId. С помощью значений частотности удобно определять фразовое или близкое совпадение; например, для фраз значения частотности находятся рядом. Кроме того, их удобно использовать при вычислении коэффициента релевантности. Например, они дают возможность подсчитать частоту употребления ключевого слова в документе DocId.  
  
 [В этом разделе](#top)  
  
##  <a name="full-text-index-fragments"></a><a name="fragments"></a>Фрагменты полнотекстового индекса  
 Логический полнотекстовый индекс обычно разбивается по нескольким внутренним таблицам. Каждая из внутренних таблиц называется фрагментом полнотекстового индекса. Некоторые из данных фрагментов могут содержать более свежие данные. Например, если пользователь обновляет следующую строку с DocId, равным 3, а в таблице выполняется автоматическое отслеживание изменений, то будет создан новый фрагмент.  
  
|DocumentID|Title|  
|----------------|-----------|  
|3|Rear Reflector|  
  
 В следующем примере, в котором показан фрагмент 2, содержатся более новые данные о DocId 3, чем во фрагменте 1. Следовательно, если пользователь запрашивает «задний отражатель», то для DocId 3 будут использованы данные из фрагмента 2. Каждый из фрагментов имеет отметку времени создания, которую можно использовать в запросах с помощью представления каталога [sys.fulltext_index_fragments](/sql/relational-databases/system-catalog-views/sys-fulltext-index-fragments-transact-sql) .  
  
 **Фрагмент 2**  
  
|Ключевое слово|ColId|DocId|Occ|  
|-------------|-----------|-----------|---------|  
|Rear|1|3|1|  
|Reflector|1|3|2|  
  
 Как можно увидеть во фрагменте 2, полнотекстовым запросам необходимо осуществить внутреннее обращение к каждому фрагменту. Более старые записи не учитываются. Следовательно, наличие слишком большого количества полнотекстовых фрагментов индекса в полнотекстовом индексе может привести к существенному уменьшению производительности запросов. Для уменьшения количества фрагментов выполните переорганизацию полнотекстового каталога, используя параметр REORGANIZE инструкции [ALTER FULLTEXT CATALOG](/sql/t-sql/statements/alter-fulltext-catalog-transact-sql)[!INCLUDE[tsql](../../includes/tsql-md.md)] . Данная инструкция выполняет *слияние в единый файл*, объединяя все фрагменты в единый большой фрагмент, и удаляет все устаревшие записи из полнотекстового индекса.  
  
 После выполнения реорганизации в образце индекса будут содержаться следующие строки.  
  
|Ключевое слово|ColId|DocId|Occ|  
|-------------|-----------|-----------|---------|  
|Crank|1|1|1|  
|Arm|1|1|2|  
|Tire|1|1|4|  
|Обслуживание|1|1|5|  
|Front|1|2|1|  
|Rear|1|3|1|  
|Reflector|1|2|2|  
|Reflector|1|2|5|  
|Reflector|1|3|2|  
|Bracket|1|2|3|  
|Сборка|1|2|6|  
|3|1|2|7|  
  
 [В этом разделе](#top)  
  
  

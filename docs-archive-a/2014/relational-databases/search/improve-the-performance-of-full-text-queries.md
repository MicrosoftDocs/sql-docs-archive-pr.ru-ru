---
title: Повышение производительности полнотекстовых запросов | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: search
ms.topic: conceptual
ms.assetid: 0658dc74-25eb-4486-bbd6-e85c1f92c272
author: MikeRayMSFT
ms.author: mikeray
ms.openlocfilehash: a1437f710725df5c87d31f6a80939a5d7869b412
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87733802"
---
# <a name="improve-the-performance-of-full-text-queries"></a>Улучшение производительности полнотекстовых запросов
  Далее приведен список рекомендаций по повышению производительности обработки полнотекстовых запросов.  
  
 Производительность выполнения полнотекстовых запросов зависит от архитектуры компьютера, а также от объема памяти, скорости работы жесткого диска, ЦП и другого оборудования.  
  
-   Выполните дефрагментацию индекса базовой таблицы с помощью инструкции [ALTER INDEX REORGANIZE](/sql/t-sql/statements/alter-index-transact-sql).  
  
-   Реорганизуйте полнотекстовый каталог с помощью инструкции [ALTER FULLTEXT CATALOG REORGANIZE](/sql/t-sql/statements/alter-fulltext-catalog-transact-sql). Это необходимо сделать до начала тестирования производительности, поскольку при выполнении этой инструкции производится слияние полнотекстовых индексов в каталоге в единый файл.  
  
-   В качестве полнотекстового ключевого столбца выбирайте небольшой столбец. Несмотря на то, что поддерживаются столбцы шириной до 900 байт, рекомендуется использовать для полнотекстового индекса ключевые столбцы меньшего размера. Использование типов `int` и `bigint` обеспечивает улучшенную производительность.  
  
-   При использовании целочисленного полнотекстового ключа можно избежать соединения с таблицей сопоставлений **docid** . Следовательно, использование целочисленного полнотекстового ключа на порядок увеличивает производительность запросов и увеличивает производительность сканирования. Еще большей производительности можно добиться, если сделать полнотекстовый ключ также и ключом кластеризованного индекса.  
  
-   Соедините несколько предикатов [CONTAINS](/sql/t-sql/queries/contains-transact-sql) в один. В [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] в запросе с предикатом CONTAINS можно указывать список столбцов.  
  
-   Если нужно лишь получить полнотекстовый ключ или сведения о ранжировании, то вместо предикатов CONTAINS и FREETEXT следует использовать соответственно функции [CONTAINSTABLE](/sql/relational-databases/system-functions/containstable-transact-sql) и [FREETEXTTABLE](/sql/relational-databases/system-functions/freetexttable-transact-sql) .  
  
-   Чтобы ограничить результаты и повысить производительность, воспользуйтесь параметром *top_n_by_rank* функций FREETEXTTABLE и CONTAINSTABLE. Параметр*top_n_by_rank* позволяет выбирать только те попадания, которые соответствуют запросу в наибольшей степени. Этот параметр используется, только если для бизнес-сценария не требуется выбирать все возможные попадания (т.е. не требуется *общая выборка*).  
  
    > [!NOTE]  
    >  Общая выборка обычно необходима для юридических сценариев, но для безнес-сценариев, например для электронного бизнеса, она может быть менее важна, чем производительность.  
  
-   Проверьте план полнотекстового запроса и убедитесь, что выбран подходящий план соединения. При необходимости используйте указание соединения или запроса. Если в полнотекстовом запросе используется параметр, то его начальное значение определяется планом запроса. Для принудительной компиляции запроса с заданным значением используйте [указание запроса](/sql/t-sql/queries/hints-transact-sql-query) OPTIMIZE FOR. Это позволит сделать план запроса детерминированным и повысить его производительность.  
  
-   Наличие в полнотекстовом индексе слишком большого числа полнотекстовых фрагментов может привести к существенному снижению производительности запросов. Чтобы уменьшить число фрагментов, выполните переорганизацию полнотекстового каталога с помощью параметра REORGANIZE в инструкции [ALTER FULLTEXT CATALOG](/sql/t-sql/statements/alter-fulltext-catalog-transact-sql)[!INCLUDE[tsql](../../includes/tsql-md.md)] . Эта инструкция выполняет слияние всех фрагментов в единый большой фрагмент и удаляет все устаревшие записи из полнотекстового индекса.  
  
-   В полнотекстовом поиске логические операторы, указанные в функции CONTAINSTABLE (AND, OR), могут быть реализованы либо как соединения SQL, либо в полнотекстовых потоковых функциях с табличным значением. Обычно запросы, в которых используется только один тип логических операторов, реализуются только средствами полнотекстового выполнения, а запросы, в которых используется одновременно несколько операторов, используют также соединения SQL. При реализации логического оператора в полнотекстовой системной функции, возвращающей табличное значение, используются некоторые специальные свойства индекса, которые обеспечивают уровень производительности, намного превышающий уровень производительности соединений SQL. В связи с этим рекомендуется по возможности составлять запросы, в которых используется только один тип логического оператора.  
  
-   В приложениях, в которых используются предикаты с селективной связью, наилучшей производительности запросов с использованием избирательных реляционных предикатов и неизбирательных полнотекстовых предикатов можно добиться, настроив их на использование оптимизатора запросов. Это позволит оптимизатору запросов определить, может ли он использовать предикат или диапазон для создания эффективного плана запроса. Данный подход более прост и часто более эффективен, чем индексирование реляционных данных в качестве полнотекстовых данных.  
  
## <a name="related-resources"></a>Связанные ресурсы  
 [Средство полнотекстового поиска SQL Server 2008: возможности и улучшения](https://go.microsoft.com/fwlink/?LinkId=129544)  
  
## <a name="see-also"></a>См. также:  
 [sys.dm_fts_memory_buffers (Transact-SQL)](/sql/relational-databases/system-dynamic-management-views/sys-dm-fts-memory-buffers-transact-sql)   
 [sys.dm_fts_memory_pools (Transact-SQL)](/sql/relational-databases/system-dynamic-management-views/sys-dm-fts-memory-pools-transact-sql)  
  
  

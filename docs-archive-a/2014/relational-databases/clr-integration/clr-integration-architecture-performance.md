---
title: Производительность интеграции со средой CLR | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: clr
ms.topic: reference
helpviewer_keywords:
- common language runtime [SQL Server], performance
- common language runtime [SQL Server], compilation process
- performance [CLR integration]
ms.assetid: 7ce2dfc0-4b1f-4dcb-a979-2c4f95b4cb15
author: rothja
ms.author: jroth
ms.openlocfilehash: 33e45039ed98ea3df607df1714b3c6108ec17c35
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87735322"
---
# <a name="performance-of-clr-integration"></a><span data-ttu-id="d853e-102">Производительность интеграции со средой CLR</span><span class="sxs-lookup"><span data-stu-id="d853e-102">Performance of CLR Integration</span></span>
  <span data-ttu-id="d853e-103">В этом разделе обсуждаются некоторые варианты проектирования, повышающие производительность [!INCLUDE[msCoName](../../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] интеграции с [!INCLUDE[msCoName](../../../includes/msconame-md.md)] .NET Framework среды CLR.</span><span class="sxs-lookup"><span data-stu-id="d853e-103">This topic discusses some of the design choices that enhance the performance of [!INCLUDE[msCoName](../../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] integration with the [!INCLUDE[msCoName](../../../includes/msconame-md.md)] .NET Framework common language runtime (CLR).</span></span>  
  
## <a name="the-compilation-process"></a><span data-ttu-id="d853e-104">Процесс компиляции</span><span class="sxs-lookup"><span data-stu-id="d853e-104">The Compilation Process</span></span>  
 <span data-ttu-id="d853e-105">Во время компиляции выражений SQL при обнаружении ссылки на управляемую подпрограмму [!INCLUDE[msCoName](../../../includes/msconame-md.md)] создается заглушка промежуточного языка (MSIL).</span><span class="sxs-lookup"><span data-stu-id="d853e-105">During compilation of SQL expressions, when a reference to a managed routine is encountered, a [!INCLUDE[msCoName](../../../includes/msconame-md.md)] intermediate language (MSIL) stub is generated.</span></span> <span data-ttu-id="d853e-106">Заглушка содержит программный код для упаковки параметров процедуры из [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] в среду CLR, вызова функции и возвращения результата.</span><span class="sxs-lookup"><span data-stu-id="d853e-106">This stub includes code to marshal the routine parameters from [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to the CLR, invoke the function, and return the result.</span></span> <span data-ttu-id="d853e-107">Этот связующий код основан на типе параметра и его направлении (входной, выходной, передача по ссылке).</span><span class="sxs-lookup"><span data-stu-id="d853e-107">This "glue" code is based on the type of parameter and on parameter direction (in, out, or reference).</span></span>  
  
 <span data-ttu-id="d853e-108">Связующий код позволяет проводить оптимизацию для конкретного типа и гарантирует эффективное обеспечение семантики [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] таких свойств, как допустимость значений NULL, ограничивающие аспекты, передача параметров по значению и стандартная обработка исключений.</span><span class="sxs-lookup"><span data-stu-id="d853e-108">The glue code enables type-specific optimizations and ensures efficient enforcement of [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] semantics, such as nullability, constraining facets, by-value, and standard exception handling.</span></span> <span data-ttu-id="d853e-109">Создавая код для конкретных типов аргументов, можно избежать приведения типов и нагрузки по созданию объектов-оболочек (этот процесс называют также «упаковкой») при вызове, пересекающем границы процессов.</span><span class="sxs-lookup"><span data-stu-id="d853e-109">By generating code for the exact types of the arguments, you avoid type coercion or wrapper object creation costs (called "boxing") across the invocation boundary.</span></span>  
  
 <span data-ttu-id="d853e-110">Затем созданная заглушка компилируется в собственный код и оптимизируется для конкретной аппаратной архитектуры, на которой выполняется [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], с использованием служб JIT-компиляции среды CLR.</span><span class="sxs-lookup"><span data-stu-id="d853e-110">The generated stub is then compiled to native code and optimized for the particular hardware architecture on which [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] executes, using the JIT (just-in-time) compilation services of the CLR.</span></span> <span data-ttu-id="d853e-111">JIT-службы вызываются на уровне методов и позволяют управляющему окружению [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] создавать единый объект компиляции между СУБД [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] и выполнением в среде CLR.</span><span class="sxs-lookup"><span data-stu-id="d853e-111">The JIT services are invoked at the method level and allow the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] hosting environment to create a single compilation unit that spans both [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and CLR execution.</span></span> <span data-ttu-id="d853e-112">После компиляции заглушки результирующий указатель на функцию становится реализацией этой функции времени выполнения.</span><span class="sxs-lookup"><span data-stu-id="d853e-112">Once the stub is compiled, the resulting function pointer becomes the run-time implementation of the function.</span></span> <span data-ttu-id="d853e-113">Такой подход к созданию кода гарантирует отсутствие лишних расходов по вызову функций, связанных с отражением или доступом к метаданным во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="d853e-113">This code generation approach ensures that there are no additional invocation costs related to reflection or metadata access at run time.</span></span>  
  
### <a name="fast-transitions-between-sql-server-and-clr"></a><span data-ttu-id="d853e-114">Быстрые переходы между СУБД SQL Server и средой CLR</span><span class="sxs-lookup"><span data-stu-id="d853e-114">Fast Transitions Between SQL Server and CLR</span></span>  
 <span data-ttu-id="d853e-115">Процесс компиляции возвращает указатель на функцию, с помощью которого можно вызвать функцию во время выполнения из машинного кода.</span><span class="sxs-lookup"><span data-stu-id="d853e-115">The compilation process yields a function pointer that can be called at run time from native code.</span></span> <span data-ttu-id="d853e-116">Для определяемых пользователем скалярных функций этот вызов функции происходит по строкам.</span><span class="sxs-lookup"><span data-stu-id="d853e-116">In the case of scalar-valued user-defined functions, this function invocation happens on a per-row basis.</span></span> <span data-ttu-id="d853e-117">Для максимального снижения стоимости перехода между [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] и средой CLR все инструкции, содержащие вызов управляемого кода, проделывают начальный шаг для выявления целевого домена приложения.</span><span class="sxs-lookup"><span data-stu-id="d853e-117">To minimize the cost of transitioning between [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and the CLR, statements that contain any managed invocation have a startup step to identify the target application domain.</span></span> <span data-ttu-id="d853e-118">Этот шаг идентификации снижает стоимость перехода для каждой строки.</span><span class="sxs-lookup"><span data-stu-id="d853e-118">This identification step reduces the cost of transitioning for each row.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="d853e-119">Вопросы производительности</span><span class="sxs-lookup"><span data-stu-id="d853e-119">Performance Considerations</span></span>  
 <span data-ttu-id="d853e-120">Далее проводится краткое перечисление факторов производительности, специфичных для интеграции со средой CLR и [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="d853e-120">The following summarizes performance considerations specific to CLR integration in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="d853e-121">Более подробные сведения можно найти в статье «[Использование интеграции со средой CLR в SQL Server 2005](https://go.microsoft.com/fwlink/?LinkId=50332)» на веб-сайте MSDN.</span><span class="sxs-lookup"><span data-stu-id="d853e-121">More detailed information can be found in "[Using CLR Integration in SQL Server 2005](https://go.microsoft.com/fwlink/?LinkId=50332)" on the MSDN Web site.</span></span> <span data-ttu-id="d853e-122">Общие сведения о производительности управляемого кода можно найти в статье "[повышение производительности и масштабируемости приложений .NET](https://go.microsoft.com/fwlink/?LinkId=50333)" на веб-сайте MSDN.</span><span class="sxs-lookup"><span data-stu-id="d853e-122">General information regarding managed code performance can be found in "[Improving .NET Application Performance and Scalability](https://go.microsoft.com/fwlink/?LinkId=50333)" on the MSDN Web site.</span></span>  
  
### <a name="user-defined-functions"></a><span data-ttu-id="d853e-123">Определяемые пользователем функции</span><span class="sxs-lookup"><span data-stu-id="d853e-123">User-Defined Functions</span></span>  
 <span data-ttu-id="d853e-124">Функции CLR используют ускоренный путь вызова по сравнению с определяемыми пользователем функциями в [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="d853e-124">CLR functions benefit from a quicker invocation path than that of [!INCLUDE[tsql](../../../includes/tsql-md.md)] user-defined functions.</span></span> <span data-ttu-id="d853e-125">Кроме того, производительность управляемого кода заметно выше, чем у [!INCLUDE[tsql](../../../includes/tsql-md.md)], в том, что касается процедурного кода, вычислений и операций со строками.</span><span class="sxs-lookup"><span data-stu-id="d853e-125">Additionally, managed code has a decisive performance advantage over [!INCLUDE[tsql](../../../includes/tsql-md.md)] in terms of procedural code, computation, and string manipulation.</span></span> <span data-ttu-id="d853e-126">Функции CLR, которые требуют большого объема вычислений и не требуют доступа к данным, лучше писать в управляемом коде.</span><span class="sxs-lookup"><span data-stu-id="d853e-126">CLR functions that are computing-intensive and that do not perform data access are better written in managed code.</span></span> <span data-ttu-id="d853e-127">Однако функции [!INCLUDE[tsql](../../../includes/tsql-md.md)] осуществляют доступ к данным более эффективно, чем функции интеграции со средой CLR.</span><span class="sxs-lookup"><span data-stu-id="d853e-127">[!INCLUDE[tsql](../../../includes/tsql-md.md)] functions do, however, perform data access more efficiently than CLR integration.</span></span>  
  
### <a name="user-defined-aggregates"></a><span data-ttu-id="d853e-128">Определяемые пользователем статистические функции</span><span class="sxs-lookup"><span data-stu-id="d853e-128">User-Defined Aggregates</span></span>  
 <span data-ttu-id="d853e-129">Управляемый код может значительно опережать по производительности статическую обработку на основе курсора.</span><span class="sxs-lookup"><span data-stu-id="d853e-129">Managed code can significantly outperform cursor-based aggregation.</span></span> <span data-ttu-id="d853e-130">Управляемый код обычно работает несколько медленнее, чем встроенные агрегатные функции [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="d853e-130">Managed code generally performs slightly slower than built-in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] aggregate functions.</span></span> <span data-ttu-id="d853e-131">Если существует собственная встроенная агрегатная функция SQL Server, рекомендуется использовать ее.</span><span class="sxs-lookup"><span data-stu-id="d853e-131">We recommend that if a native built-in aggregate function exists, you should use it.</span></span> <span data-ttu-id="d853e-132">В случаях, когда нужные статистические вычисления не поддерживаются встроенными функциями, из соображений производительности можно использовать созданную пользователем статистическую функцию среды CLR, реализованную на основе курсора.</span><span class="sxs-lookup"><span data-stu-id="d853e-132">In cases in which the needed aggregation is not natively supported, consider a CLR user-defined aggregate over a cursor-based implementation for performance reasons.</span></span>  
  
### <a name="streaming-table-valued-functions"></a><span data-ttu-id="d853e-133">Функции потока с табличным значением</span><span class="sxs-lookup"><span data-stu-id="d853e-133">Streaming Table-Valued Functions</span></span>  
 <span data-ttu-id="d853e-134">Часто бывает нужно, чтобы в результате вызова функции приложение вернуло таблицу.</span><span class="sxs-lookup"><span data-stu-id="d853e-134">Applications often need to return a table as a result of invoking a function.</span></span> <span data-ttu-id="d853e-135">Например, в качестве части операции импорта приложение читает табличные данные из файла; нужно преобразовать их из формата величин с разделителями-запятыми в реляционное представление.</span><span class="sxs-lookup"><span data-stu-id="d853e-135">Examples include reading tabular data from a file as part of an import operation, and converting comma-separated-values to a relational representation.</span></span> <span data-ttu-id="d853e-136">Обычно это достигается с помощью материализации и заполнения таблицы результатов до ее использования вызывающим объектом.</span><span class="sxs-lookup"><span data-stu-id="d853e-136">Typically, you can accomplish this by materializing and populating the result table before it can be consumed by the caller.</span></span> <span data-ttu-id="d853e-137">Интеграция CLR в [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] использует новый механизм расширяемости — функции потока с табличным значением (streaming table-valued function, STVF).</span><span class="sxs-lookup"><span data-stu-id="d853e-137">The integration of the CLR into [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] introduces a new extensibility mechanism called a streaming table-valued function (STVF).</span></span> <span data-ttu-id="d853e-138">Управляемые функции потока, возвращающие табличное значение, по производительности опережают реализации на основе расширенных хранимых процедур.</span><span class="sxs-lookup"><span data-stu-id="d853e-138">Managed STVFs perform better than comparable extended stored procedure implementations.</span></span>  
  
 <span data-ttu-id="d853e-139">Потоковые функции с табличными значениями — это управляемые функции, которые возвращают интерфейс `IEnumerable`.</span><span class="sxs-lookup"><span data-stu-id="d853e-139">STVFs are managed functions that return an `IEnumerable` interface.</span></span> <span data-ttu-id="d853e-140">У интерфейса `IEnumerable` есть методы для навигации по результирующему набору, возвращенному потоковой функцией с табличными значениями.</span><span class="sxs-lookup"><span data-stu-id="d853e-140">`IEnumerable` has methods to navigate the result set returned by the STVF.</span></span> <span data-ttu-id="d853e-141">При вызове возвращающей табличное значение функции потока возвращенный интерфейс `IEnumerable` непосредственно соединен с планом запроса.</span><span class="sxs-lookup"><span data-stu-id="d853e-141">When the STVF is invoked, the returned `IEnumerable` is directly connected to the query plan.</span></span> <span data-ttu-id="d853e-142">Когда плану запроса нужно получить строки, он вызывает методы интерфейса `IEnumerable`.</span><span class="sxs-lookup"><span data-stu-id="d853e-142">The query plan calls `IEnumerable` methods when it needs to fetch rows.</span></span> <span data-ttu-id="d853e-143">Такая модель итерации позволяет провести немедленную обработку результатов сразу после получения первой строки, не ожидая заполнения всей таблицы.</span><span class="sxs-lookup"><span data-stu-id="d853e-143">This iteration model allows results to be consumed immediately after the first row is produced, instead of waiting until the entire table is populated.</span></span> <span data-ttu-id="d853e-144">Она также существенно снижает затраты памяти на вызов функции.</span><span class="sxs-lookup"><span data-stu-id="d853e-144">It also significantly reduces the memory consumed by invoking the function.</span></span>  
  
### <a name="arrays-vs-cursors"></a><span data-ttu-id="d853e-145">Сравнение массивов и курсоров</span><span class="sxs-lookup"><span data-stu-id="d853e-145">Arrays vs. Cursors</span></span>  
 <span data-ttu-id="d853e-146">Если курсорам [!INCLUDE[tsql](../../../includes/tsql-md.md)] нужно перемещаться по данным, которые проще реализовать как массив, использование управляемого кода принесет существенный выигрыш в производительности.</span><span class="sxs-lookup"><span data-stu-id="d853e-146">When [!INCLUDE[tsql](../../../includes/tsql-md.md)] cursors must traverse data that is more easily expressed as an array, managed code can be used with significant performance gains.</span></span>  
  
### <a name="string-data"></a><span data-ttu-id="d853e-147">Строковые данные</span><span class="sxs-lookup"><span data-stu-id="d853e-147">String Data</span></span>  
 <span data-ttu-id="d853e-148">Символьные данные в [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], например `varchar`, в управляемых функциях могут принадлежать к типу SqlString или SqlChars.</span><span class="sxs-lookup"><span data-stu-id="d853e-148">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] character data, such as `varchar`, can be of the type SqlString or SqlChars in managed functions.</span></span> <span data-ttu-id="d853e-149">Переменные типа SqlString создают в памяти экземпляр всего значения целиком.</span><span class="sxs-lookup"><span data-stu-id="d853e-149">SqlString variables create an instance of the entire value into memory.</span></span> <span data-ttu-id="d853e-150">Переменные типа SqlChars обеспечивают потоковый интерфейс, который позволяет добиться более высокой производительности и масштабируемости, так как не создает в памяти экземпляра всего значения сразу.</span><span class="sxs-lookup"><span data-stu-id="d853e-150">SqlChars variables provide a streaming interface that can be used to achieve better performance and scalability by not creating an instance of the entire value into memory.</span></span> <span data-ttu-id="d853e-151">Это особенно важно для типов больших объектов (LOB).</span><span class="sxs-lookup"><span data-stu-id="d853e-151">This becomes particularly important for large object (LOB) data.</span></span> <span data-ttu-id="d853e-152">Кроме того, с помощью потокового интерфейса, возвращаемого методом `SqlXml.CreateReader()`, можно получить доступ к XML-данным на сервере.</span><span class="sxs-lookup"><span data-stu-id="d853e-152">Additionally, server XML data can be accessed through a streaming interface returned by `SqlXml.CreateReader()`.</span></span>  
  
### <a name="clr-vs-extended-stored-procedures"></a><span data-ttu-id="d853e-153">Сравнение CLR и расширенных хранимых процедур</span><span class="sxs-lookup"><span data-stu-id="d853e-153">CLR vs. Extended Stored Procedures</span></span>  
 <span data-ttu-id="d853e-154">API-интерфейсы Microsoft.SqlServer.Server, позволяющие управляемым процедурам отсылать результирующие наборы обратно клиенту, имеют более высокую производительность, чем API-интерфейсы служб Open Data Services (ODS), используемые расширенными хранимыми процедурами.</span><span class="sxs-lookup"><span data-stu-id="d853e-154">The Microsoft.SqlServer.Server application programming interfaces (APIs) that allow managed procedures to send result sets back to the client perform better than the Open Data Services (ODS) APIs used by extended stored procedures.</span></span> <span data-ttu-id="d853e-155">Более того, API-интерфейсы System.Data.SqlServer поддерживают такие типы данных, как `xml`, `varchar(max)`, `nvarchar(max)` и `varbinary(max)`, введенные в версии [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)], в то время как в ODS API-интерфейсах поддержка этих типов еще не добавлена.</span><span class="sxs-lookup"><span data-stu-id="d853e-155">Furthermore, the System.Data.SqlServer APIs support data types such as `xml`, `varchar(max)`, `nvarchar(max)`, and `varbinary(max)`, introduced in [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)], while the ODS APIs have not been extended to support the new data types.</span></span>  
  
 <span data-ttu-id="d853e-156">При использовании управляемого кода [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] управляет использованием ресурсов памяти, потоков и синхронизации.</span><span class="sxs-lookup"><span data-stu-id="d853e-156">With managed code, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] manages use of resources such as memory, threads, and synchronization.</span></span> <span data-ttu-id="d853e-157">Это происходит потому, что управляемые API-интерфейсы, предоставляющие доступ к этим ресурсам, реализованы поверх диспетчера ресурсов [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="d853e-157">This is because the managed APIs that expose these resources are implemented on top of the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] resource manager.</span></span> <span data-ttu-id="d853e-158">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], напротив, не может управлять использованием ресурсов расширенных хранимых процедур.</span><span class="sxs-lookup"><span data-stu-id="d853e-158">Conversely, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] has no view or control over the resource usage of the extended stored procedure.</span></span> <span data-ttu-id="d853e-159">Например, если расширенная хранимая процедура потребляет слишком много ресурсов процессора или памяти, в [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] нет никаких средств, чтобы это обнаружить или управлять этим.</span><span class="sxs-lookup"><span data-stu-id="d853e-159">For example, if an extended stored procedure consumes too much CPU or memory resources, there is no way to detect or control this with [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="d853e-160">Напротив, при использовании управляемого кода [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] может увидеть, что конкретный поток давно не отдает управление, и заставить задачу отдать управление, чтобы можно было планировать выполнение других задач.</span><span class="sxs-lookup"><span data-stu-id="d853e-160">With managed code, however, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can detect that a given thread has not yielded for a long period of time, and then force the task to yield so that other work can be scheduled.</span></span> <span data-ttu-id="d853e-161">Поэтому использование управляемого кода позволяет лучше масштабировать выполнение и оптимизировать использование системных ресурсов.</span><span class="sxs-lookup"><span data-stu-id="d853e-161">Consequently, using managed code provides for better scalability and system resource usage.</span></span>  
  
 <span data-ttu-id="d853e-162">Управляемый код может вызывать дополнительные расходы на поддержку среды выполнения и проверки безопасности.</span><span class="sxs-lookup"><span data-stu-id="d853e-162">Managed code may incur additional overhead necessary to maintain the execution environment and perform security checks.</span></span> <span data-ttu-id="d853e-163">Это происходит, например, при выполнении внутри [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], когда требуются многочисленные переходы от управляемого кода к собственному и обратно (потому что [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] вынужден проводить дополнительное обслуживание настроек конкретных потоков при переходе к машинному коду и обратно).</span><span class="sxs-lookup"><span data-stu-id="d853e-163">This is the case, for example, when running inside [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and numerous transitions from managed to native code are required (because [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] needs to do additional maintenance on thread-specific settings when moving out to native code and back).</span></span> <span data-ttu-id="d853e-164">Следовательно, расширенные хранимые процедуры могут выполняться значительно быстрее управляемого кода внутри [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] в случаях, когда требуются многочисленные переходы от управляемого к машинному коду и обратно.</span><span class="sxs-lookup"><span data-stu-id="d853e-164">Consequently, extended stored procedures can significantly outperform managed code running inside [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] for cases in which there are frequent transitions between managed and native code.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="d853e-165">Не рекомендуется разрабатывать новые расширенные хранимые процедуры, поскольку эта функциональная возможность устарела.</span><span class="sxs-lookup"><span data-stu-id="d853e-165">It is recommended that you do not develop new extended stored procedures, because this feature has been deprecated.</span></span>  
  
### <a name="native-serialization-for-user-defined-types"></a><span data-ttu-id="d853e-166">Собственная сериализация для определяемых пользователем типов</span><span class="sxs-lookup"><span data-stu-id="d853e-166">Native Serialization for User-Defined Types</span></span>  
 <span data-ttu-id="d853e-167">Определяемые пользователем типы (UDT) представляют собой механизм расширения скалярной системы типов.</span><span class="sxs-lookup"><span data-stu-id="d853e-167">User-defined types (UDTs) are designed as an extensibility mechanism for the scalar type system.</span></span> <span data-ttu-id="d853e-168">В [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] реализован формат сериализации для определяемого пользователем типа — `Format.Native`.</span><span class="sxs-lookup"><span data-stu-id="d853e-168">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] implements a serialization format for UDTs called `Format.Native`.</span></span> <span data-ttu-id="d853e-169">Во время компиляции исследуется структура типа, а затем создается код MSIL, настраиваемый для данного конкретного определения типа.</span><span class="sxs-lookup"><span data-stu-id="d853e-169">During compilation, the structure of the type is examined to generate MSIL that is customized for that particular type definition.</span></span>  
  
 <span data-ttu-id="d853e-170">Собственная сериализация используется в [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="d853e-170">Native serialization is the default implementation for [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="d853e-171">Сериализация, определяемая пользователем, вызывает для сериализации метод, указанный автором типа.</span><span class="sxs-lookup"><span data-stu-id="d853e-171">User-defined serialization invokes a method defined by the type author to do the serialization.</span></span> <span data-ttu-id="d853e-172">По возможности следует использовать метод `Format.Native`, так как он обеспечивает наилучшую производительность.</span><span class="sxs-lookup"><span data-stu-id="d853e-172">`Format.Native` serialization should be used when possible for best performance.</span></span>  
  
### <a name="normalization-of-comparable-udts"></a><span data-ttu-id="d853e-173">Нормализация сравнимых определяемых пользователем типов</span><span class="sxs-lookup"><span data-stu-id="d853e-173">Normalization of Comparable UDTs</span></span>  
 <span data-ttu-id="d853e-174">Операции отношения, например сортировка и сравнение определяемых пользователем типов, работают непосредственно с двоичным представлением значения.</span><span class="sxs-lookup"><span data-stu-id="d853e-174">Relational operations, such as sorting and comparing UDTs, operate directly on the binary representation of the value.</span></span> <span data-ttu-id="d853e-175">Для этого на диске хранится нормализованное (двоичное, упорядоченное) представление состояния определяемого пользователем типа.</span><span class="sxs-lookup"><span data-stu-id="d853e-175">This is accomplished by storing a normalized (binary ordered) representation of the state of the UDT on disk.</span></span>  
  
 <span data-ttu-id="d853e-176">Нормализация имеет два преимущества: ее использование значительно «удешевляет» операцию сравнения, так как избавляет от необходимости создания экземпляра типа и вызова метода; кроме того, нормализация создает двоичное представление определяемого пользователем типа, что позволяет строить гистограммы, индексы и гистограммы для значений этого типа.</span><span class="sxs-lookup"><span data-stu-id="d853e-176">Normalization has two benefits: it makes the comparison operation considerably less expensive by avoiding the construction of the type instance and the method invocation overhead; and it creates a binary domain for the UDT, enabling the construction of histograms, indexes, and histograms for values of the type.</span></span> <span data-ttu-id="d853e-177">Поэтому производительность операций с нормализованными определяемыми пользователем типами почти такая же, как у операций, не требующих вызова методов, над встроенными типами.</span><span class="sxs-lookup"><span data-stu-id="d853e-177">Consequently, normalized UDTs have a very similar performance profile to the native built-in types for operations that do not involve method invocation.</span></span>  
  
### <a name="scalable-memory-usage"></a><span data-ttu-id="d853e-178">Масштабируемое использование памяти</span><span class="sxs-lookup"><span data-stu-id="d853e-178">Scalable Memory Usage</span></span>  
 <span data-ttu-id="d853e-179">Чтобы управляемая сборка мусора в [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] имела высокую производительность и хорошо масштабировалась, следует избегать выделения памяти одним большим блоком.</span><span class="sxs-lookup"><span data-stu-id="d853e-179">In order for managed garbage collection to perform and scale well in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], avoid large, single allocation.</span></span> <span data-ttu-id="d853e-180">Выделенные области памяти размером больше 88 КБ помещаются в кучу для больших объектов, для которой сборка мусора работает гораздо медленнее и хуже масштабируется, чем для небольших областей памяти.</span><span class="sxs-lookup"><span data-stu-id="d853e-180">Allocations greater than 88 kilobytes (KB) in size will be placed on the Large Object Heap, which will cause garbage collection to perform and scale much worse than many smaller allocations.</span></span> <span data-ttu-id="d853e-181">Например, если нужно выделить память для большого многомерного массива, лучше выделить память под массив массивов (разреженный массив).</span><span class="sxs-lookup"><span data-stu-id="d853e-181">For example, if you need to allocate a large multi-dimensional array, it is better to allocate a jagged (scattered) array.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d853e-182">См. также:</span><span class="sxs-lookup"><span data-stu-id="d853e-182">See Also</span></span>  
 [<span data-ttu-id="d853e-183">Определяемые пользователем типы CLR</span><span class="sxs-lookup"><span data-stu-id="d853e-183">CLR User-Defined Types</span></span>](../clr-integration-database-objects-user-defined-types/clr-user-defined-types.md)  
  
  

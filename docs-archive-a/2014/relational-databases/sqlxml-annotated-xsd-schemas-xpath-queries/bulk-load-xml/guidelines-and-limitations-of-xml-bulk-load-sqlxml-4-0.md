---
title: Рекомендации и ограничения при выполнении групповой загрузки XML (SQLXML 4,0) | Документация Майкрософт
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: reference
helpviewer_keywords:
- XML Bulk Load [SQLXML], about XML Bulk Load
- bulk load [SQLXML], about bulk load
ms.assetid: c5885d14-c7c1-47b3-a389-455e99a7ece1
author: rothja
ms.author: jroth
ms.openlocfilehash: 08c0020ac7b28702f5a573c6158ec9d50c735b2a
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87665971"
---
# <a name="guidelines-and-limitations-of-xml-bulk-load-sqlxml-40"></a>Правила и ограничения массовой загрузки XML (SQLXML 4.0)
  Использование массовой загрузки XML требует понимания следующих рекомендаций и ограничений.  
  
-   Встроенные схемы не поддерживаются.  
  
     Если в исходном XML-документе содержится встроенная схема, при массовой загрузке XML она не учитывается. Для массовой загрузки XML нужно задать схему сопоставления, внешнюю по отношению к XML-данным. Нельзя указать схему сопоставления в узле с помощью атрибута **xmlns = "КС:счема"** .  
  
-   Проверяется правильность формата XML-документа, но сам документ не проверяется.  
  
     При выполнении операции XML-загрузки выполняется проверка XML-документа, чтобы определить, соответствует ли он правильному формату, т. е. чтобы XML-код соответствует требованиям, предъявляемым к синтаксису XML-1,0 консорциум W3C. Если формат документа содержит ошибки, массовая загрузка XML прекращается и возвращает ошибку. Единственное исключение — когда документ является фрагментом (например, когда у него не один корневой элемент), в этом случае массовая загрузка XML загружает документ.  
  
     Массовая загрузка XML не проверяет документ на соответствие какой-либо схеме DTD или XML-Data, которую содержит или на которую ссылается файл XML-данных. Кроме того, массовая загрузка XML-данных не проверяет файл XML-данных на соответствие переданной схеме сопоставления.  
  
-   Никакая информация из пролога XML-документа не учитывается.  
  
     При выполнении операции XML-загрузки вся информация пропускается до и после \<root> элемента в XML-документе. В частности, массовая загрузка XML не учитывает никаких XML-деклараций, внутренних определений DTD, ссылок на внешние DTD, комментариев и тому подобное.  
  
-   При наличии схемы сопоставления, задающей связь «первичный ключ — внешний ключ» между двумя таблицами (например, между таблицами Customer и CustOrder), таблица, содержащая первичный ключ, должна описываться в схеме первой. Таблица с внешним ключевым столбцом должна располагаться после нее. Причина заключается в том, что порядок, в котором таблицы определяются в схеме, является порядком, который используется для их загрузки в базу данных. Например, следующая схема XDR выдаст ошибку при выполнении групповой загрузки XML, так как **\<Order>** элемент описан перед **\<Customer>** элементом. Столбец CustomerID в таблице CustOrder представляет собой внешний ключевой столбец, ссылающийся на первичный ключевой столбец CustomerID в таблице Cust.  
  
    ```  
    <?xml version="1.0" ?>  
    <Schema xmlns="urn:schemas-microsoft-com:xml-data"   
            xmlns:dt="urn:schemas-microsoft-com:xml:datatypes"    
            xmlns:sql="urn:schemas-microsoft-com:xml-sql" >  
  
        <ElementType name="Order" sql:relation="CustOrder" >  
          <AttributeType name="OrderID" />  
          <AttributeType name="CustomerID" />  
          <attribute type="OrderID" />  
          <attribute type="CustomerID" />  
        </ElementType>  
  
       <ElementType name="CustomerID" dt:type="int" />  
       <ElementType name="CompanyName" dt:type="string" />  
       <ElementType name="City" dt:type="string" />  
  
       <ElementType name="root" sql:is-constant="1">  
          <element type="Customers" />  
       </ElementType>  
       <ElementType name="Customers" sql:relation="Cust"   
                         sql:overflow-field="OverflowColumn"  >  
          <element type="CustomerID" sql:field="CustomerID" />  
          <element type="CompanyName" sql:field="CompanyName" />  
          <element type="City" sql:field="City" />  
          <element type="Order" >   
               <sql:relationship  
                   key-relation="Cust"  
                    key="CustomerID"  
                    foreign-key="CustomerID"  
                    foreign-relation="CustOrder" />  
          </element>  
       </ElementType>  
    </Schema>  
    ```  
  
-   Если в схеме не задан явным образом столбец переполнения с помощью заметки `sql:overflow-field`, массовая загрузка XML пропускает любые данные, которые присутствуют в XML-документе, но не описаны в схеме сопоставления.  
  
     Массовая загрузка XML применяет заданную схему сопоставления каждый раз, как в потоке XML-данных попадаются известные теги. Данные, которые присутствуют в XML-документе, но не описаны в схеме, пропускаются. Например, предположим, что имеется схема сопоставления, описывающая **\<Customer>** элемент. Файл данных XML содержит **\<AllCustomers>** корневой тег (не описанный в схеме), включающий все **\<Customer>** элементы:  
  
    ```  
    <AllCustomers>  
      <Customer>...</Customer>  
      <Customer>...</Customer>  
       ...  
    </AllCustomers>  
    ```  
  
     В этом случае при выполнении операции XML с массовым загрузкой элемент не учитывается **\<AllCustomers>** и начинается сопоставление в **\<Customer>** элементе. Массовая загрузка XML пропускает все элементы, не описанные в схеме, но присутствующие в XML-документе.  
  
     Рассмотрите другой исходный XML-файл данных, содержащий **\<Order>** элементы. Эти элементы не описаны в схеме сопоставления.  
  
    ```  
    <AllCustomers>  
      <Customer>...</Customer>  
        <Order> ... </Order>  
        <Order> ... </Order>  
         ...  
      <Customer>...</Customer>  
        <Order> ... </Order>  
        <Order> ... </Order>  
         ...  
      ...  
    </AllCustomers>  
    ```  
  
     При выполнении групповой загрузки XML эти **\<Order>** элементы игнорируются. Но если вы используете `sql:overflow-field` заметку в схеме для того, чтобы указать столбец в качестве столбца переполнения, при выполнении операции XML-загрузки в этом столбце хранятся все невостребованные данные.  
  
-   Разделы CDATA и ссылки на сущности для сохранения их в базе данных преобразуются в эквивалентные строки.  
  
     В этом примере раздел CDATA заключает в оболочку значение для **\<City>** элемента. При выполнении групповой загрузки XML извлекается строковое значение ("Нью-Йорк") перед вставкой **\<City>** элемента в базу данных.  
  
    ```  
    <City><![CDATA[NY]]> </City>  
    ```  
  
     Массовая загрузка XML не сохраняет ссылки на сущности.  
  
-   Если в схеме сопоставления задано значение по умолчанию для атрибута и в исходных XML-данных этот атрибут отсутствует, при массовой загрузке XML будет использовано значение по умолчанию.  
  
     Следующий пример схемы XDR присваивает атрибуту **HireDate** значение по умолчанию:  
  
    ```  
    <?xml version="1.0" ?>  
    <Schema xmlns="urn:schemas-microsoft-com:xml-data"   
            xmlns:dt="urn:schemas-microsoft-com:xml:datatypes"    
            xmlns:sql="urn:schemas-microsoft-com:xml-sql" >  
       <ElementType name="root" sql:is-constant="1">  
          <element type="Customers" />  
       </ElementType>  
  
       <ElementType name="Customers" sql:relation="Cust3" >  
          <AttributeType name="CustomerID" dt:type="int"  />  
          <AttributeType name="HireDate"  default="2000-01-01" />  
          <AttributeType name="Salary"   />  
  
          <attribute type="CustomerID" sql:field="CustomerID" />  
          <attribute type="HireDate"   sql:field="HireDate"  />  
          <attribute type="Salary"     sql:field="Salary"    />  
       </ElementType>  
    </Schema>  
    ```  
  
     В этих XML-данных атрибут **HireDate** отсутствует во втором **\<Customers>** элементе. Когда при выполнении операции XML-загрузки в базу данных вставляется второй **\<Customers>** элемент, используется значение по умолчанию, указанное в схеме.  
  
    ```  
    <ROOT>  
      <Customers CustomerID="1" HireDate="1999-01-01" Salary="10000" />  
      <Customers CustomerID="2" Salary="10000" />  
    </ROOT>  
    ```  
  
-   Заметка `sql:url-encode` не поддерживается.  
  
     Нельзя задать во вводных XML-данных URL-адрес и ждать, что массовая загрузка XML прочтет данные, находящиеся по этому адресу.  
  
     Создаются таблицы, заданные в схеме сопоставления (база данных должна существовать). Если одна или несколько таблиц уже существуют в базе данных, свойство Сгдроптаблес определяет, нужно ли удалять и повторно создавать эти предварительно существовавшие таблицы.  
  
-   Если указать свойство SchemaGen (например, SchemaGen = true), то будут созданы таблицы, определенные в схеме сопоставления. Но SchemaGen не создает никаких ограничений (таких как ограничения ПЕРВИЧного и внешнего ключей) в этих таблицах с одним исключением: Если XML-узлы, составляющие первичный ключ в связи, определены как имеющие тип XML ID (то есть `type="xsd:ID"` для XSD), а свойство сгусеид имеет значение true для SchemaGen, то не только первичные ключи создаются из узлов с типом ID, но связи первичного и внешнего ключей создаются из связей схемы сопоставления.  
  
-   SchemaGen не использует аспекты и расширения схемы XSD для создания реляционной [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] схемы.  
  
-   Если указать свойство SchemaGen (например, SchemaGen = true) при выполнении групповой загрузки, обновляются только таблицы (а не представления общего имени), которые задаются.  
  
-   SchemaGen предоставляет базовую функциональность только для создания реляционной схемы из аннотации XSD. При необходимости пользователь должен изменить созданные таблицы вручную.  
  
-   Если между таблицами существует больше связей, SchemaGen пытается создать единую связь, включающую все ключи, участвующие в двух таблицах. Это ограничение может вызвать ошибку [!INCLUDE[tsql](../../../includes/tsql-md.md)].  
  
-   При массовой загрузке XML-данных в базу по меньшей мере один атрибут или дочерний элемент в схеме сопоставления должен быть сопоставлен со столбцом базы данных.  
  
-   Если при массовой загрузке XML происходит вставка значений дат, эти значения должны быть заданы в формате (-)CCYY-MM-DD((+-)TZ). Это стандартный формат даты в XSD.  
  
-   Некоторые флаги свойств несовместимы друг с другом. Например, при массовой загрузке не поддерживается значение `Ignoreduplicatekeys=true` вместе со значением `Keepidentity=false`. При использовании значения `Keepidentity=false` в операции массовой загрузки происходит ожидание создания сервером значений ключа. Таблицы должны иметь ограничение `IDENTITY`, которое распространяется на этот ключ. Сервер не создает повторяющиеся ключи, поэтому нет необходимости присваивать свойству `Ignoreduplicatekeys` значение `true`. Свойство `Ignoreduplicatekeys` должно иметь значение `true` только при передаче значений первичного ключа из входящих данных в таблицу, содержащую строки, если существует вероятность конфликта значений первичного ключа.  
  
  

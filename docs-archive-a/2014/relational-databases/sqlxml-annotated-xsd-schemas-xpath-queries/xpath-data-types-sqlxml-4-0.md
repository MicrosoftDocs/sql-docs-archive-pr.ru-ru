---
title: Типы данных XPath (SQLXML 4,0) | Документация Майкрософт
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: reference
helpviewer_keywords:
- mapping XDR types to XPath types [SQLXML]
- data types [XPath]
- arithmetic operators
- mapping data types [SQLXML]
- relational operators [SQLXML]
- node-set [SQLXML]
- data types [SQLXML], XPath
- XPath operators [SQLXML]
- XDR data type [SQLXML]
- equality operators [SQLXML]
- XPath conversions [SQLXML]
- converting data types [SQLXML]
- Boolean operators
- XPath queries [SQLXML], data types
- XPath data types [SQLXML]
- operators [SQLXML]
ms.assetid: a90374bf-406f-4384-ba81-59478017db68
author: rothja
ms.author: jroth
ms.openlocfilehash: 846fc5a17ac97d30b6f0ab65fee176ac459c20cc
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/04/2020
ms.locfileid: "87665952"
---
# <a name="xpath-data-types-sqlxml-40"></a><span data-ttu-id="c5d22-102">Типы данных XPath (SQLXML 4.0)</span><span class="sxs-lookup"><span data-stu-id="c5d22-102">XPath Data Types (SQLXML 4.0)</span></span>
  [!INCLUDE[msCoName](../../includes/msconame-md.md)]<span data-ttu-id="c5d22-103">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], XPath и XML Schema (XSD) имеют очень разные типы данных.</span><span class="sxs-lookup"><span data-stu-id="c5d22-103">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], XPath, and XML Schema (XSD) have very different data types.</span></span> <span data-ttu-id="c5d22-104">Например, в XPath отсутствуют целочисленные типы данных и тип данных для обозначения даты, а в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] и XSD таких типов множество.</span><span class="sxs-lookup"><span data-stu-id="c5d22-104">For example, XPath does not have integer or date data types, but [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] and XSD have many.</span></span> <span data-ttu-id="c5d22-105">Типы данных XSD определяют время с точностью до наносекунды, а [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] только до одной трехсотой доли секунды.</span><span class="sxs-lookup"><span data-stu-id="c5d22-105">XSD uses nanosecond precision for time values, and [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] uses at most 1/300-second precision.</span></span> <span data-ttu-id="c5d22-106">Поэтому не всегда возможно сопоставить один тип другому.</span><span class="sxs-lookup"><span data-stu-id="c5d22-106">Consequently, mapping one data type to another is not always possible.</span></span> <span data-ttu-id="c5d22-107">Дополнительные сведения о сопоставлении [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] типов данных с типами данных XSD см. [в разделе приведение типов данных и аннотация SQL: datatype &#40;&#41;SQLXML 4,0 ](../sqlxml-annotated-xsd-schemas-using/data-type-coercions-and-the-sql-datatype-annotation-sqlxml-4-0.md).</span><span class="sxs-lookup"><span data-stu-id="c5d22-107">For more information about mapping [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] data types to XSD data types, see [Data Type Coercions and the sql:datatype Annotation &#40;SQLXML 4.0&#41;](../sqlxml-annotated-xsd-schemas-using/data-type-coercions-and-the-sql-datatype-annotation-sqlxml-4-0.md).</span></span>  
  
 <span data-ttu-id="c5d22-108">XPath имеет три типа данных: `string` , `number` и `boolean` .</span><span class="sxs-lookup"><span data-stu-id="c5d22-108">XPath has three data types: `string`, `number`, and `boolean`.</span></span> <span data-ttu-id="c5d22-109">Тип данных `number` — это всегда тип двойной точности с плавающей запятой, соответствующий стандарту IEEE 754.</span><span class="sxs-lookup"><span data-stu-id="c5d22-109">The `number` data type is always an IEEE 754 double-precision floating-point.</span></span> <span data-ttu-id="c5d22-110">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] `float(53)` Тип данных является ближайшим к XPath `number` .</span><span class="sxs-lookup"><span data-stu-id="c5d22-110">The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]`float(53)` data type is the closest to XPath `number`.</span></span> <span data-ttu-id="c5d22-111">Однако `float(53)` не совсем соответствует IEEE 754.</span><span class="sxs-lookup"><span data-stu-id="c5d22-111">However, `float(53)` is not exactly IEEE 754.</span></span> <span data-ttu-id="c5d22-112">В частности, этот тип не содержит ни значения NaN (не число), ни значения бесконечности.</span><span class="sxs-lookup"><span data-stu-id="c5d22-112">For example, neither NaN (Not-a-Number) nor infinity is used.</span></span> <span data-ttu-id="c5d22-113">Попытка преобразовать нечисловую строку в тип `number` и попытка деления на ноль вызывают ошибки.</span><span class="sxs-lookup"><span data-stu-id="c5d22-113">Attempting to convert a nonnumeric string to `number` and trying to divide by zero results in an error.</span></span>  
  
## <a name="xpath-conversions"></a><span data-ttu-id="c5d22-114">Преобразования в XPath</span><span class="sxs-lookup"><span data-stu-id="c5d22-114">XPath Conversions</span></span>  
 <span data-ttu-id="c5d22-115">При использовании запроса XPath, например, `OrderDetail[@UnitPrice > "10.0"]`, явные и неявные преобразования типов данных могут различными неочевидными способами изменить значение запроса.</span><span class="sxs-lookup"><span data-stu-id="c5d22-115">When you use an XPath query such as `OrderDetail[@UnitPrice > "10.0"]`, implicit and explicit data type conversions can change the meaning of the query in subtle ways.</span></span> <span data-ttu-id="c5d22-116">Поэтому важно знать, как реализована система типов данных в XPath.</span><span class="sxs-lookup"><span data-stu-id="c5d22-116">Therefore, it is important to understand how XPath data types are implemented.</span></span> <span data-ttu-id="c5d22-117">Спецификация языка XPath, язык XML Path (XPath) версии 1,0 W3C предложенная рекомендация 8 1999 октября, находится на веб-сайте W3C по адресу http://www.w3.org/TR/1999/PR-xpath-19991008.html .</span><span class="sxs-lookup"><span data-stu-id="c5d22-117">The XPath language specification, XML Path Language (XPath) version 1.0 W3C Proposed Recommendation 8 October 1999, can be found at the W3C Web site at http://www.w3.org/TR/1999/PR-xpath-19991008.html.</span></span>  
  
 <span data-ttu-id="c5d22-118">Операторы XPath делятся на четыре категории:</span><span class="sxs-lookup"><span data-stu-id="c5d22-118">XPath operators are divided into four categories:</span></span>  
  
-   <span data-ttu-id="c5d22-119">Логические операторы (и, или)</span><span class="sxs-lookup"><span data-stu-id="c5d22-119">Boolean operators (and, or)</span></span>  
  
-   <span data-ttu-id="c5d22-120">Операторы отношения ( \<, > , \<=, > =)</span><span class="sxs-lookup"><span data-stu-id="c5d22-120">Relational operators (\<, >, \<=, >=)</span></span>  
  
-   <span data-ttu-id="c5d22-121">Операторы равенства (=, !=)</span><span class="sxs-lookup"><span data-stu-id="c5d22-121">Equality operators (=, !=)</span></span>  
  
-   <span data-ttu-id="c5d22-122">Арифметические операторы (+, -, \*, div, mod)</span><span class="sxs-lookup"><span data-stu-id="c5d22-122">Arithmetic operators (+, -, \*, div, mod)</span></span>  
  
 <span data-ttu-id="c5d22-123">Операторы разных категорий по-разному преобразуют операнды.</span><span class="sxs-lookup"><span data-stu-id="c5d22-123">Each category of operator converts its operands differently.</span></span> <span data-ttu-id="c5d22-124">При необходимости операторы XPath неявно преобразуют операнды.</span><span class="sxs-lookup"><span data-stu-id="c5d22-124">XPath operators implicitly convert their operands if necessary.</span></span> <span data-ttu-id="c5d22-125">Арифметические операторы преобразуют операнды к типу `number`, и результатом их выполнения является число.</span><span class="sxs-lookup"><span data-stu-id="c5d22-125">Arithmetic operators convert their operands to `number`, and result in a number value.</span></span> <span data-ttu-id="c5d22-126">Логические операторы преобразуют операнды к типу `boolean`, и результатом их выполнения является логическое значение.</span><span class="sxs-lookup"><span data-stu-id="c5d22-126">Boolean operators convert their operands to `boolean`, and result in a Boolean value.</span></span> <span data-ttu-id="c5d22-127">Результатом выполнения реляционных операторов и операторов равенства является логическое значение.</span><span class="sxs-lookup"><span data-stu-id="c5d22-127">Relational operators and equality operators result in a Boolean value.</span></span> <span data-ttu-id="c5d22-128">Однако правила преобразования, которыми пользуются операторы, зависят от первоначальных типов операндов, как показано в таблице.</span><span class="sxs-lookup"><span data-stu-id="c5d22-128">However, they have different conversion rules depending on the original data types of their operands, as shown in this table.</span></span>  
  
|<span data-ttu-id="c5d22-129">Операнд</span><span class="sxs-lookup"><span data-stu-id="c5d22-129">Operand</span></span>|<span data-ttu-id="c5d22-130">Реляционный оператор</span><span class="sxs-lookup"><span data-stu-id="c5d22-130">Relational operator</span></span>|<span data-ttu-id="c5d22-131">Оператор равенства</span><span class="sxs-lookup"><span data-stu-id="c5d22-131">Equality operator</span></span>|  
|-------------|-------------------------|-----------------------|  
|<span data-ttu-id="c5d22-132">Оба операнда представляют собой наборы узлов.</span><span class="sxs-lookup"><span data-stu-id="c5d22-132">Both operands are node-sets.</span></span>|<span data-ttu-id="c5d22-133">Значение TRUE, если и только если в первом наборе узлов есть такой узел и во втором наборе узлов есть такой узел, что сравнение их значений `string` вернет значение TRUE.</span><span class="sxs-lookup"><span data-stu-id="c5d22-133">TRUE if and only if there is a node in one set and a node in the second set such that the comparison of their `string` values is TRUE.</span></span>|<span data-ttu-id="c5d22-134">То же.</span><span class="sxs-lookup"><span data-stu-id="c5d22-134">Same.</span></span>|  
|<span data-ttu-id="c5d22-135">Один — набор узлов, другой — `string`.</span><span class="sxs-lookup"><span data-stu-id="c5d22-135">One is a node-set, the other a `string`.</span></span>|<span data-ttu-id="c5d22-136">Значение TRUE, если и только если в наборе узлов есть такой узел, который после преобразования в `number` при сравнении с объектом типа `string`, преобразованным в тип `number`, вернет значение TRUE.</span><span class="sxs-lookup"><span data-stu-id="c5d22-136">TRUE if and only if there is a node in the node-set such that when converted to `number`, the comparison of it with the `string` converted to `number` is TRUE.</span></span>|<span data-ttu-id="c5d22-137">Значение TRUE, если и только в том случае, когда в наборе узлов есть такой узел, который после преобразования в `string` при сравнении с `string` вернет значение TRUE.</span><span class="sxs-lookup"><span data-stu-id="c5d22-137">TRUE if and only if there is a node in the node-set such that when converted to `string`, the comparison of it with the `string` is TRUE.</span></span>|  
|<span data-ttu-id="c5d22-138">Один — набор узлов, другой — `number`.</span><span class="sxs-lookup"><span data-stu-id="c5d22-138">One is a node-set, the other a `number`.</span></span>|<span data-ttu-id="c5d22-139">Значение TRUE, если и только в том случае, когда в наборе узлов есть такой узел, который после преобразования в `number` при сравнении с `number` вернет значение TRUE.</span><span class="sxs-lookup"><span data-stu-id="c5d22-139">TRUE if and only if there is a node in the node-set such that when converted to `number`, the comparison of it with the `number` is TRUE.</span></span>|<span data-ttu-id="c5d22-140">То же.</span><span class="sxs-lookup"><span data-stu-id="c5d22-140">Same.</span></span>|  
|<span data-ttu-id="c5d22-141">Один — набор узлов, другой — `boolean`.</span><span class="sxs-lookup"><span data-stu-id="c5d22-141">One is a node-set, the other a `boolean`.</span></span>|<span data-ttu-id="c5d22-142">Значение TRUE, если и только если в наборе узлов есть такой узел, который после преобразования в `boolean`, а затем в `number` при сравнении с объектом типа `boolean`, преобразованным в тип `number`, вернет значение TRUE.</span><span class="sxs-lookup"><span data-stu-id="c5d22-142">TRUE if and only if there is a node in the node-set such that when converted to `boolean` and then to `number`, the comparison of it with the `boolean` converted to `number` is TRUE.</span></span>|<span data-ttu-id="c5d22-143">Значение TRUE, если и только в том случае, когда в наборе узлов есть такой узел, который после преобразования в `boolean` при сравнении с `boolean` вернет значение TRUE.</span><span class="sxs-lookup"><span data-stu-id="c5d22-143">TRUE if and only if there is a node in the node-set such that when converted to `boolean`, the comparison of it with the `boolean` is TRUE.</span></span>|  
|<span data-ttu-id="c5d22-144">Ни один из них не представляет собой набор узлов.</span><span class="sxs-lookup"><span data-stu-id="c5d22-144">Neither is a node-set.</span></span>|<span data-ttu-id="c5d22-145">Преобразует оба операнда к типу `number`, а затем сравнивает их.</span><span class="sxs-lookup"><span data-stu-id="c5d22-145">Convert both operands to `number` and then compare.</span></span>|<span data-ttu-id="c5d22-146">Преобразует оба операнда к одному типу, а затем сравнивает их.</span><span class="sxs-lookup"><span data-stu-id="c5d22-146">Convert both operands to a common type and then compare.</span></span> <span data-ttu-id="c5d22-147">Преобразует к типу `boolean`, если хотя бы один из операндов принадлежит к типу `boolean`, и к типу `number`, если хотя бы один из операндов принадлежит к типу `number`; в противном случае преобразует к типу `string`.</span><span class="sxs-lookup"><span data-stu-id="c5d22-147">Convert to `boolean` if either is `boolean`, `number` if either is `number`; otherwise, convert to `string`.</span></span>|  
  
> [!NOTE]  
>  <span data-ttu-id="c5d22-148">Поскольку реляционные операторы XPath всегда преобразуют операнды к типу `number`, сравнение типов `string` невозможно.</span><span class="sxs-lookup"><span data-stu-id="c5d22-148">Because XPath relational operators always convert their operands to `number`, `string` comparisons are not possible.</span></span> <span data-ttu-id="c5d22-149">Чтобы включить сравнения дат, SQL Server 2000 предлагает этот вариант для спецификации XPath: если реляционный оператор сравнивает объект с `string` `string` , набор узлов со значением `string` или набор узлов со строковыми значениями, равным набору узлов со строковыми значениями, `string` выполняется сравнение (не `number` Сравнение).</span><span class="sxs-lookup"><span data-stu-id="c5d22-149">To include date comparisons, SQL Server 2000 offers this variation to the XPath specification: When a relational operator compares a `string` to a `string`, a node-set to a `string`, or a string-valued node-set to a string-valued node-set, a `string` comparison (not a `number` comparison) is performed.</span></span>  
  
## <a name="node-set-conversions"></a><span data-ttu-id="c5d22-150">Преобразования наборов узлов</span><span class="sxs-lookup"><span data-stu-id="c5d22-150">Node-Set Conversions</span></span>  
 <span data-ttu-id="c5d22-151">Преобразования наборов узлов не всегда интуитивно понятны.</span><span class="sxs-lookup"><span data-stu-id="c5d22-151">Node-set conversions are not always intuitive.</span></span> <span data-ttu-id="c5d22-152">Чтобы преобразовать набор узлов в тип `string`, берется строковое значение только первого узла набора.</span><span class="sxs-lookup"><span data-stu-id="c5d22-152">A node-set is converted to a `string` by taking the string value of only the first node in the set.</span></span> <span data-ttu-id="c5d22-153">Чтобы преобразовать набор узлов к типу `number`, он сначала преобразуется в тип `string`, а затем значение типа `string` преобразуется в тип `number`.</span><span class="sxs-lookup"><span data-stu-id="c5d22-153">A node-set is converted to `number` by converting it to `string`, and then converting `string` to `number`.</span></span> <span data-ttu-id="c5d22-154">Чтобы преобразовать набор узлов к типу `boolean`, производится его проверка на существование.</span><span class="sxs-lookup"><span data-stu-id="c5d22-154">A node-set is converted to `boolean` by testing for its existence.</span></span>  
  
> [!NOTE]  
>  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="c5d22-155">не производит выборку по положению в наборах узлов — например, запрос XPath `Customer[3]` указывает на третьего заказчика; такой тип выборки по положению не поддерживается в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="c5d22-155">does not perform positional selection on node-sets: for example, the XPath query `Customer[3]` means the third customer; this type of positional selection is not supported in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="c5d22-156">Поэтому преобразования набора узлов в тип `string` или в тип `number`, согласно спецификации XPath, не реализованы.</span><span class="sxs-lookup"><span data-stu-id="c5d22-156">Therefore, the node-set-to-`string` or node-set-to-`number` conversions as described by the XPath specification are not implemented.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="c5d22-157">использует семантику «любой» там, где спецификация XPath использует семантику «первый».</span><span class="sxs-lookup"><span data-stu-id="c5d22-157">uses "any" semantics wherever the XPath specification specifies "first" semantics.</span></span> <span data-ttu-id="c5d22-158">Например, на основе спецификации W3C XPath запрос XPath `Order[OrderDetail/@UnitPrice > 10.0]` выбирает эти заказы с помощью первого элемента **OrderDetail** , у которого **Цена** больше 10,0.</span><span class="sxs-lookup"><span data-stu-id="c5d22-158">For example, based on the W3C XPath specification, the XPath query `Order[OrderDetail/@UnitPrice > 10.0]` selects those orders with the first **OrderDetail** that has a **UnitPrice** greater than 10.0.</span></span> <span data-ttu-id="c5d22-159">В [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] этот запрос XPath выбирает эти заказы с любым значением **OrderDetail** , имеющим значение **UnitPrice** больше 10,0.</span><span class="sxs-lookup"><span data-stu-id="c5d22-159">In [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], this XPath query selects those orders with any **OrderDetail** that has a **UnitPrice** greater than 10.0.</span></span>  
  
 <span data-ttu-id="c5d22-160">Преобразование к типу `boolean` проводит проверку на существование, поэтому запрос XPath `Products[@Discontinued=true()]` эквивалентен выражению SQL "Products.Discontinued is not null", а не выражению SQL "Products.Discontinued = 1".</span><span class="sxs-lookup"><span data-stu-id="c5d22-160">Conversion to `boolean` generates an existence test; therefore, the XPath query `Products[@Discontinued=true()]` is equivalent to the SQL expression "Products.Discontinued is not null", not the SQL expression "Products.Discontinued = 1".</span></span> <span data-ttu-id="c5d22-161">Чтобы запрос был эквивалентен последнему из приведенных выражений SQL, набор узлов сначала надо преобразовать в тип, отличный от `boolean`, например, `number`.</span><span class="sxs-lookup"><span data-stu-id="c5d22-161">To make the query equivalent to the latter SQL expression, first convert the node-set to a non-`boolean` type, such as `number`.</span></span> <span data-ttu-id="c5d22-162">Например, `Products[number(@Discontinued) = true()]`.</span><span class="sxs-lookup"><span data-stu-id="c5d22-162">For example, `Products[number(@Discontinued) = true()]`.</span></span>  
  
 <span data-ttu-id="c5d22-163">Большинство операторов реализовано так, что они возвращают TRUE, если их результат равен TRUE хотя бы для одного (любого) узла набора, поэтому они возвращают FALSE, если набор узлов пуст.</span><span class="sxs-lookup"><span data-stu-id="c5d22-163">Because most operators are defined to be TRUE if they are TRUE for any or one of the nodes in the node-set, these operations always evaluate to FALSE if the node-set is empty.</span></span> <span data-ttu-id="c5d22-164">Таким образом, если набор узлов A пуст, оба оператора `A = B` и `A != B` вернут FALSE, а `not(A=B)` и `not(A!=B)` — TRUE.</span><span class="sxs-lookup"><span data-stu-id="c5d22-164">Thus, if A is empty, both `A = B` and `A != B` are FALSE, and `not(A=B)` and `not(A!=B)` are TRUE.</span></span>  
  
 <span data-ttu-id="c5d22-165">Обычно атрибут или элемент, сопоставленный столбцу, существует, если значение этого столбца в базе данных не равно `null`.</span><span class="sxs-lookup"><span data-stu-id="c5d22-165">Usually, an attribute or element that maps to a column exists if the value of that column in the database is not `null`.</span></span> <span data-ttu-id="c5d22-166">Элементы, сопоставляемые со строками, существуют, если есть хотя бы один из их дочерних элементов.</span><span class="sxs-lookup"><span data-stu-id="c5d22-166">Elements that map to rows exist if any of their children exist.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="c5d22-167">Элементы с аннотацией `is-constant` существуют всегда.</span><span class="sxs-lookup"><span data-stu-id="c5d22-167">Elements annotated with `is-constant` always exist.</span></span> <span data-ttu-id="c5d22-168">Следовательно, предикаты XPath нельзя использовать для элементов, помеченных как `is-constant`.</span><span class="sxs-lookup"><span data-stu-id="c5d22-168">Consequently, XPath predicates cannot be used on `is-constant` elements.</span></span>  
  
 <span data-ttu-id="c5d22-169">При преобразовании набора узлов в тип `string` или `number` его тип XDR, если таковой указан в аннотируемой схеме, анализируется и при необходимости служит основой для решения о преобразовании типов.</span><span class="sxs-lookup"><span data-stu-id="c5d22-169">When a node-set is converted to `string` or `number`, its XDR type (if any) is inspected in the annotated schema and that type is used to determine the conversion that is required.</span></span>  
  
## <a name="mapping-xdr-data-types-to-xpath-data-types"></a><span data-ttu-id="c5d22-170">Сопоставление типов данных XDR типам данных XPath</span><span class="sxs-lookup"><span data-stu-id="c5d22-170">Mapping XDR Data Types to XPath Data Types</span></span>  
 <span data-ttu-id="c5d22-171">Тип данных XPath узла является производным от типа данных XDR в схеме, как показано в следующей таблице (для наглядного назначения используется узел **EmployeeID** ).</span><span class="sxs-lookup"><span data-stu-id="c5d22-171">The XPath data type of a node is derived from the XDR data type in the schema, as shown in the following table (the node **EmployeeID** is used for illustrative purpose).</span></span>  
  
|<span data-ttu-id="c5d22-172">Тип данных XDR</span><span class="sxs-lookup"><span data-stu-id="c5d22-172">XDR data type</span></span>|<span data-ttu-id="c5d22-173">Эквивалентный</span><span class="sxs-lookup"><span data-stu-id="c5d22-173">Equivalent</span></span><br /><br /> <span data-ttu-id="c5d22-174">тип данных XPath</span><span class="sxs-lookup"><span data-stu-id="c5d22-174">XPath data type</span></span>|<span data-ttu-id="c5d22-175">Использованное преобразование SQL Server</span><span class="sxs-lookup"><span data-stu-id="c5d22-175">SQL Server conversion used</span></span>|  
|-------------------|------------------------------------|--------------------------------|  
|<span data-ttu-id="c5d22-176">Nonebin.base64bin.hex</span><span class="sxs-lookup"><span data-stu-id="c5d22-176">Nonebin.base64bin.hex</span></span>|<span data-ttu-id="c5d22-177">Недоступно</span><span class="sxs-lookup"><span data-stu-id="c5d22-177">N/A</span></span>|<span data-ttu-id="c5d22-178">NoneEmployeeID</span><span class="sxs-lookup"><span data-stu-id="c5d22-178">NoneEmployeeID</span></span>|  
|<span data-ttu-id="c5d22-179">boolean</span><span class="sxs-lookup"><span data-stu-id="c5d22-179">boolean</span></span>|<span data-ttu-id="c5d22-180">boolean</span><span class="sxs-lookup"><span data-stu-id="c5d22-180">boolean</span></span>|<span data-ttu-id="c5d22-181">CONVERT(bit, EmployeeID)</span><span class="sxs-lookup"><span data-stu-id="c5d22-181">CONVERT(bit, EmployeeID)</span></span>|  
|<span data-ttu-id="c5d22-182">number, int, float,i1, i2, i4, i8,r4, r8ui1, ui2, ui4, ui8</span><span class="sxs-lookup"><span data-stu-id="c5d22-182">number, int, float,i1, i2, i4, i8,r4, r8ui1, ui2, ui4, ui8</span></span>|<span data-ttu-id="c5d22-183">число</span><span class="sxs-lookup"><span data-stu-id="c5d22-183">number</span></span>|<span data-ttu-id="c5d22-184">CONVERT(float(53), EmployeeID)</span><span class="sxs-lookup"><span data-stu-id="c5d22-184">CONVERT(float(53), EmployeeID)</span></span>|  
|<span data-ttu-id="c5d22-185">id, idref, idrefsentity, entities, enumerationnotation, nmtoken, nmtokens, chardate, Timedate, Time.tz, string, uri, uuid</span><span class="sxs-lookup"><span data-stu-id="c5d22-185">id, idref, idrefsentity, entities, enumerationnotation, nmtoken, nmtokens, chardate, Timedate, Time.tz, string, uri, uuid</span></span>|<span data-ttu-id="c5d22-186">строка</span><span class="sxs-lookup"><span data-stu-id="c5d22-186">string</span></span>|<span data-ttu-id="c5d22-187">CONVERT(nvarchar(4000), EmployeeID, 126)</span><span class="sxs-lookup"><span data-stu-id="c5d22-187">CONVERT(nvarchar(4000), EmployeeID, 126)</span></span>|  
|<span data-ttu-id="c5d22-188">fixed14.4</span><span class="sxs-lookup"><span data-stu-id="c5d22-188">fixed14.4</span></span>|<span data-ttu-id="c5d22-189">н/д (в XPath нет типа данных, эквивалентного типу fixed14.4 XDR)</span><span class="sxs-lookup"><span data-stu-id="c5d22-189">N/A(There is no data type in XPath that is equivalent to the fixed14.4 XDR data type)</span></span>|<span data-ttu-id="c5d22-190">CONVERT(money, EmployeeID)</span><span class="sxs-lookup"><span data-stu-id="c5d22-190">CONVERT(money, EmployeeID)</span></span>|  
|<span data-ttu-id="c5d22-191">Дата</span><span class="sxs-lookup"><span data-stu-id="c5d22-191">date</span></span>|<span data-ttu-id="c5d22-192">строка</span><span class="sxs-lookup"><span data-stu-id="c5d22-192">string</span></span>|<span data-ttu-id="c5d22-193">LEFT(CONVERT(nvarchar(4000), EmployeeID, 126), 10)</span><span class="sxs-lookup"><span data-stu-id="c5d22-193">LEFT(CONVERT(nvarchar(4000), EmployeeID, 126), 10)</span></span>|  
|<span data-ttu-id="c5d22-194">time</span><span class="sxs-lookup"><span data-stu-id="c5d22-194">time</span></span><br /><br /> <span data-ttu-id="c5d22-195">time.tz</span><span class="sxs-lookup"><span data-stu-id="c5d22-195">time.tz</span></span>|<span data-ttu-id="c5d22-196">строка</span><span class="sxs-lookup"><span data-stu-id="c5d22-196">string</span></span>|<span data-ttu-id="c5d22-197">SUBSTRING(CONVERT(nvarchar(4000), EmployeeID, 126), 1 + CHARINDEX(N'T', CONVERT(nvarchar(4000), EmployeeID, 126)), 24)</span><span class="sxs-lookup"><span data-stu-id="c5d22-197">SUBSTRING(CONVERT(nvarchar(4000), EmployeeID, 126), 1 + CHARINDEX(N'T', CONVERT(nvarchar(4000), EmployeeID, 126)), 24)</span></span>|  
  
 <span data-ttu-id="c5d22-198">Преобразования даты и времени предназначены для работы, если значение хранится в базе данных с использованием [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] `datetime` типа данных или `string` .</span><span class="sxs-lookup"><span data-stu-id="c5d22-198">The date and time conversions are designed to work whether the value is stored in the database using the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]`datetime` data type or a `string`.</span></span> <span data-ttu-id="c5d22-199">Обратите внимание, что [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] `datetime` тип данных не использует `timezone` и имеет меньшую точность, чем `time` тип данных XML.</span><span class="sxs-lookup"><span data-stu-id="c5d22-199">Note that the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]`datetime` data type does not use `timezone` and has a smaller precision than the XML `time` data type.</span></span> <span data-ttu-id="c5d22-200">Чтобы включить тип данных `timezone` или более высокую точность, следует хранить данные в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] с использованием типа `string`.</span><span class="sxs-lookup"><span data-stu-id="c5d22-200">To include the `timezone` data type or additional precision, store the data in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] using a `string` type.</span></span>  
  
 <span data-ttu-id="c5d22-201">При преобразовании узла из типа данных XDR в тип данных XPath иногда требуются дополнительные преобразования (из одного типа XPath в другой тип XPath).</span><span class="sxs-lookup"><span data-stu-id="c5d22-201">When a node is converted from its XDR data type to the XPath data type, additional conversion is sometimes necessary (from one XPath data type to another XPath data type).</span></span> <span data-ttu-id="c5d22-202">В качестве примера рассмотрим следующий запрос XPath:</span><span class="sxs-lookup"><span data-stu-id="c5d22-202">For example, consider this XPath query:</span></span>  
  
```  
(@m + 3) = 4  
```  
  
 <span data-ttu-id="c5d22-203">Если @m имеет `fixed14.4` тип данных XDR, преобразование типа данных XDR в тип данных XPath выполняется с помощью следующих средств:</span><span class="sxs-lookup"><span data-stu-id="c5d22-203">If @m is of the `fixed14.4` XDR data type, the conversion from XDR data type to XPath data type is accomplished using:</span></span>  
  
```  
CONVERT(money, m)  
```  
  
 <span data-ttu-id="c5d22-204">В данном случае узел `m` преобразуется из типа `fixed14.4` в тип `money`.</span><span class="sxs-lookup"><span data-stu-id="c5d22-204">In this conversion, the node `m` is converted from `fixed14.4` to `money`.</span></span> <span data-ttu-id="c5d22-205">Однако для прибавления 3 требуется дополнительное преобразование:</span><span class="sxs-lookup"><span data-stu-id="c5d22-205">However, adding the value of 3, requires additional conversion:</span></span>  
  
```  
CONVERT(float(CONVERT(money, m))  
```  
  
 <span data-ttu-id="c5d22-206">Выражение XPath вычисляется следующим образом:</span><span class="sxs-lookup"><span data-stu-id="c5d22-206">The XPath expression is evaluated as:</span></span>  
  
```  
CONVERT(float(CONVERT(money, m)) + CONVERT(float(53), 3) = CONVERT(float(53), 3)  
```  
  
 <span data-ttu-id="c5d22-207">Как показано в следующей таблице, это то же самое преобразование, которое применялось для других выражений XPath (например, литералов или составных выражений).</span><span class="sxs-lookup"><span data-stu-id="c5d22-207">As shown in the following table, this is the same conversion that is applied for other XPath expressions (such as literals or compound expressions).</span></span>  
  
||||||  
|-|-|-|-|-|  
||<span data-ttu-id="c5d22-208">Х неизвестен</span><span class="sxs-lookup"><span data-stu-id="c5d22-208">X is unknown</span></span>|<span data-ttu-id="c5d22-209">X является `string`</span><span class="sxs-lookup"><span data-stu-id="c5d22-209">X is `string`</span></span>|<span data-ttu-id="c5d22-210">X является `number`</span><span class="sxs-lookup"><span data-stu-id="c5d22-210">X is `number`</span></span>|<span data-ttu-id="c5d22-211">X является `boolean`</span><span class="sxs-lookup"><span data-stu-id="c5d22-211">X is `boolean`</span></span>|  
|<span data-ttu-id="c5d22-212">string(X)</span><span class="sxs-lookup"><span data-stu-id="c5d22-212">string(X)</span></span>|<span data-ttu-id="c5d22-213">CONVERT (nvarchar(4000), X, 126)</span><span class="sxs-lookup"><span data-stu-id="c5d22-213">CONVERT (nvarchar(4000), X, 126)</span></span>|-|<span data-ttu-id="c5d22-214">CONVERT (nvarchar(4000), X, 126)</span><span class="sxs-lookup"><span data-stu-id="c5d22-214">CONVERT (nvarchar(4000), X, 126)</span></span>|<span data-ttu-id="c5d22-215">CASE WHEN X THEN N'true' ELSE N'false' END</span><span class="sxs-lookup"><span data-stu-id="c5d22-215">CASE WHEN X THEN N'true' ELSE N'false' END</span></span>|  
|<span data-ttu-id="c5d22-216">number(X)</span><span class="sxs-lookup"><span data-stu-id="c5d22-216">number(X)</span></span>|<span data-ttu-id="c5d22-217">CONVERT (float(53), X)</span><span class="sxs-lookup"><span data-stu-id="c5d22-217">CONVERT (float(53), X)</span></span>|<span data-ttu-id="c5d22-218">CONVERT (float(53), X)</span><span class="sxs-lookup"><span data-stu-id="c5d22-218">CONVERT (float(53), X)</span></span>|-|<span data-ttu-id="c5d22-219">CASE WHEN X THEN 1 ELSE 0 END</span><span class="sxs-lookup"><span data-stu-id="c5d22-219">CASE WHEN X THEN 1 ELSE 0 END</span></span>|  
|<span data-ttu-id="c5d22-220">boolean(X)</span><span class="sxs-lookup"><span data-stu-id="c5d22-220">boolean(X)</span></span>|-|<span data-ttu-id="c5d22-221">LEN (X) > 0</span><span class="sxs-lookup"><span data-stu-id="c5d22-221">LEN(X) > 0</span></span>|<span data-ttu-id="c5d22-222">X != 0</span><span class="sxs-lookup"><span data-stu-id="c5d22-222">X != 0</span></span>|-|  
  
## <a name="examples"></a><span data-ttu-id="c5d22-223">Примеры</span><span class="sxs-lookup"><span data-stu-id="c5d22-223">Examples</span></span>  
  
### <a name="a-convert-a-data-type-in-an-xpath-query"></a><span data-ttu-id="c5d22-224">A.</span><span class="sxs-lookup"><span data-stu-id="c5d22-224">A.</span></span> <span data-ttu-id="c5d22-225">Преобразование типа данных в запросе XPath</span><span class="sxs-lookup"><span data-stu-id="c5d22-225">Convert a data type in an XPath query</span></span>  
 <span data-ttu-id="c5d22-226">В следующем запросе XPath, указанном для аннотированной схемы XSD, запрос выбирает все узлы **Employee** с атрибутом **EmployeeID** , который имеет значение e-1, где "E-" — это префикс, указанный с помощью `sql:id-prefix` аннотации.</span><span class="sxs-lookup"><span data-stu-id="c5d22-226">In the following XPath query specified against an annotated XSD schema, the query selects all **Employee** nodes with the **EmployeeID** attribute value of E-1, where "E-" is the prefix specified using the `sql:id-prefix` annotation.</span></span>  
  
 `Employee[@EmployeeID="E-1"]`  
  
 <span data-ttu-id="c5d22-227">Предикат в запросе эквивалентен следующему выражению SQL:</span><span class="sxs-lookup"><span data-stu-id="c5d22-227">The predicate in the query is equivalent to the SQL expression:</span></span>  
  
 `N'E-' + CONVERT(nvarchar(4000), Employees.EmployeeID, 126) = N'E-1'`  
  
 <span data-ttu-id="c5d22-228">Поскольку **EmployeeID** является одним из `id` `idref` `idrefs` значений типа данных (,, `nmtoken` , `nmtokens` и т. д.) в схеме XSD, **EmployeeID** преобразуется в `string` тип данных XPath с помощью правил преобразования, описанных выше.</span><span class="sxs-lookup"><span data-stu-id="c5d22-228">Because **EmployeeID** is one of the `id` (`idref`, `idrefs`, `nmtoken`, `nmtokens`, and so on) data type values in the XSD schema, **EmployeeID** is converted to the `string` XPath data type using the conversion rules described previously.</span></span>  
  
 `CONVERT(nvarchar(4000), Employees.EmployeeID, 126)`  
  
 <span data-ttu-id="c5d22-229">К строке добавляется префикс «E-», а результат затем сравнивается с `N'E-1'`.</span><span class="sxs-lookup"><span data-stu-id="c5d22-229">The "E-" prefix is added to the string, and the result is then compared with `N'E-1'`.</span></span>  
  
### <a name="b-perform-several-data-type-conversions-in-an-xpath-query"></a><span data-ttu-id="c5d22-230">Б.</span><span class="sxs-lookup"><span data-stu-id="c5d22-230">B.</span></span> <span data-ttu-id="c5d22-231">Несколько преобразований типов данных в запросе XPath</span><span class="sxs-lookup"><span data-stu-id="c5d22-231">Perform several data type conversions in an XPath query</span></span>  
 <span data-ttu-id="c5d22-232">Рассмотрим этот запрос XPath, заданный для схемы XSD с заметками:`OrderDetail[@UnitPrice * @OrderQty > 98]`</span><span class="sxs-lookup"><span data-stu-id="c5d22-232">Consider this XPath query specified against an annotated XSD schema: `OrderDetail[@UnitPrice * @OrderQty > 98]`</span></span>  
  
 <span data-ttu-id="c5d22-233">Этот запрос XPath возвращает все элементы, которые **\<OrderDetail>** соответствуют предикату `@UnitPrice * @OrderQty > 98` .</span><span class="sxs-lookup"><span data-stu-id="c5d22-233">This XPath query returns all the **\<OrderDetail>** elements satisfying the predicate `@UnitPrice * @OrderQty > 98`.</span></span> <span data-ttu-id="c5d22-234">Если **UnitPrice** помечена `fixed14.4` типом данных в схеме с заметками, этот предикат эквивалентен выражению SQL:</span><span class="sxs-lookup"><span data-stu-id="c5d22-234">If the **UnitPrice** is annotated with a `fixed14.4` data type in the annotated schema, this predicate is equivalent to the SQL expression:</span></span>  
  
 `CONVERT(float(53), CONVERT(money, OrderDetail.UnitPrice)) * CONVERT(float(53), OrderDetail.OrderQty) > CONVERT(float(53), 98)`  
  
 <span data-ttu-id="c5d22-235">В ходе преобразований значений в запросе XPath сначала тип данных XDR преобразуется в тип данных XPath.</span><span class="sxs-lookup"><span data-stu-id="c5d22-235">In converting the values in the XPath query, the first conversion converts the XDR data type to the XPath data type.</span></span> <span data-ttu-id="c5d22-236">Поскольку тип данных XSD для **UnitPrice** имеет значение `fixed14.4` , как описано в предыдущей таблице, это первое используемое преобразование:</span><span class="sxs-lookup"><span data-stu-id="c5d22-236">Because the XSD data type of **UnitPrice** is `fixed14.4`, as described in the previous table, this is the first conversion that is used:</span></span>  
  
```  
CONVERT(money, OrderDetail.UnitPrice))   
```  
  
 <span data-ttu-id="c5d22-237">Поскольку арифметические операторы преобразуют операнды к типу XPath `number`, применяется второе преобразование (от одного типа данных XPath к другому), в результате которого значение преобразуется к типу `float(53)` (тип `float(53)` близок к типу данных XPath `number`):</span><span class="sxs-lookup"><span data-stu-id="c5d22-237">Because the arithmetic operators convert their operands to the `number` XPath data type, the second conversion (from one XPath data type to another XPath data type) is applied in which the value is converted to `float(53)` (`float(53)` is close to the XPath `number` data type):</span></span>  
  
```  
CONVERT(float(53), CONVERT(money, OrderDetail.UnitPrice))   
```  
  
 <span data-ttu-id="c5d22-238">Если атрибут **OrderQty** не имеет типа данных XSD, то **OrderQty** преобразуется в `number` тип данных XPath в одном преобразовании:</span><span class="sxs-lookup"><span data-stu-id="c5d22-238">Assuming the **OrderQty** attribute has no XSD data type, **OrderQty** is converted to a `number` XPath data type in a single conversion:</span></span>  
  
```  
CONVERT(float(53), OrderDetail.OrderQty)  
```  
  
 <span data-ttu-id="c5d22-239">Подобным же образом значение 98 преобразуется к типу данных XPath `number`:</span><span class="sxs-lookup"><span data-stu-id="c5d22-239">Similarly, the value 98 is converted to the `number` XPath data type:</span></span>  
  
```  
CONVERT(float(53), 98)  
```  
  
> [!NOTE]  
>  <span data-ttu-id="c5d22-240">Если используемый в схеме тип данных XSD несовместим с базовым типом [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] в базе данных или нужное преобразование типа данных XPath невозможно выполнить, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] может вернуть ошибку.</span><span class="sxs-lookup"><span data-stu-id="c5d22-240">If the XSD data type used in the schema is incompatible with the underlying [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] data type in the database, or if an impossible XPath data type conversion is performed, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] may return an error.</span></span> <span data-ttu-id="c5d22-241">Например, если атрибут **EmployeeID** помечен аннотацией `id-prefix` , то XPath `Employee[@EmployeeID=1]` выдает ошибку, поскольку **EmployeeID** имеет `id-prefix` заметку и не может быть преобразован в `number` .</span><span class="sxs-lookup"><span data-stu-id="c5d22-241">For example, if the **EmployeeID** attribute is annotated with `id-prefix` annotation, the XPath `Employee[@EmployeeID=1]` generates an error, because **EmployeeID** has the `id-prefix` annotation and cannot be converted to `number`.</span></span>  
  
  
